(async ()=>{
    (function() {
        const $ = document.createElement("link").relList;
        if ($ && $.supports && $.supports("modulepreload")) return;
        for (const z of document.querySelectorAll('link[rel="modulepreload"]'))V(z);
        new MutationObserver((z)=>{
            for (const j of z)if (j.type === "childList") for (const H of j.addedNodes)H.tagName === "LINK" && H.rel === "modulepreload" && V(H);
        }).observe(document, {
            childList: !0,
            subtree: !0
        });
        function N(z) {
            const j = {};
            return z.integrity && (j.integrity = z.integrity), z.referrerPolicy && (j.referrerPolicy = z.referrerPolicy), z.crossOrigin === "use-credentials" ? j.credentials = "include" : z.crossOrigin === "anonymous" ? j.credentials = "omit" : j.credentials = "same-origin", j;
        }
        function V(z) {
            if (z.ep) return;
            z.ep = !0;
            const j = N(z);
            fetch(z.href, j);
        }
    })();
    const ro = "modulepreload", ao = function(At, $) {
        return new URL(At, $).href;
    }, un = {}, oo = function($, N, V) {
        let z = Promise.resolve();
        if (N && N.length > 0) {
            const H = document.getElementsByTagName("link"), Y = document.querySelector("meta[property=csp-nonce]"), bt = Y?.nonce || Y?.getAttribute("nonce");
            z = Promise.allSettled(N.map((ot)=>{
                if (ot = ao(ot, V), ot in un) return;
                un[ot] = !0;
                const Tt = ot.endsWith(".css"), kt = Tt ? '[rel="stylesheet"]' : "";
                if (!!V) for(let ut = H.length - 1; ut >= 0; ut--){
                    const lt = H[ut];
                    if (lt.href === ot && (!Tt || lt.rel === "stylesheet")) return;
                }
                else if (document.querySelector(`link[href="${ot}"]${kt}`)) return;
                const ht = document.createElement("link");
                if (ht.rel = Tt ? "stylesheet" : ro, Tt || (ht.as = "script"), ht.crossOrigin = "", ht.href = ot, bt && ht.setAttribute("nonce", bt), document.head.appendChild(ht), Tt) return new Promise((ut, lt)=>{
                    ht.addEventListener("load", ut), ht.addEventListener("error", ()=>lt(new Error(`Unable to preload CSS for ${ot}`)));
                });
            }));
        }
        function j(H) {
            const Y = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (Y.payload = H, window.dispatchEvent(Y), !Y.defaultPrevented) throw H;
        }
        return z.then((H)=>{
            for (const Y of H || [])Y.status === "rejected" && j(Y.reason);
            return $().catch(j);
        });
    };
    class uo {
        seed;
        a = 1664525;
        c = 1013904223;
        m = 2 ** 32;
        constructor($ = Date.now()){
            this.seed = $ % this.m;
        }
        setSeed($) {
            this.seed = $ % this.m;
        }
        getSeed() {
            return this.seed;
        }
        random() {
            return this.seed = (this.a * this.seed + this.c) % this.m, this.seed / this.m;
        }
        randomRange($, N) {
            return $ + this.random() * (N - $);
        }
        randomInt($, N) {
            return Math.floor(this.randomRange($, N + 1));
        }
    }
    var Li = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
    function ho(At) {
        return At && At.__esModule && Object.prototype.hasOwnProperty.call(At, "default") ? At.default : At;
    }
    var Ai = {
        exports: {}
    };
    (function(At, $) {
        (function(N, V) {
            V($);
        })(Li, function(N) {
            function V(c) {
                return Math.max(0, c);
            }
            function z(c, t) {
                return c <= 0 ? 0 : t;
            }
            var j = Object.freeze({
                __proto__: null,
                activate: V,
                measure: z
            });
            function H(c) {
                return 1 / (1 + Math.exp(-c));
            }
            function Y(c, t) {
                return c * (1 - c) * t;
            }
            var bt = Object.freeze({
                __proto__: null,
                activate: H,
                measure: Y
            });
            function ot(c) {
                return Math.tanh(c);
            }
            function Tt(c, t) {
                return (1 - c * c) * t;
            }
            var kt = Object.freeze({
                __proto__: null,
                activate: ot,
                measure: Tt
            });
            function ct(c) {
                return c > 0 ? c : .01 * c;
            }
            function ht(c, t) {
                return c > 0 ? t : .01 * t;
            }
            var ut = Object.freeze({
                __proto__: null,
                activate: ct,
                measure: ht
            }), lt = Object.freeze({
                __proto__: null,
                relu: j,
                sigmoid: bt,
                tanh: kt,
                leakyRelu: ut
            }), vt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof Li < "u" ? Li : typeof self < "u" ? self : {};
            function Kt(c, t, e) {
                return e = {
                    path: t,
                    exports: {},
                    require: function(i, h) {
                        return It(i, h ?? e.path);
                    }
                }, c(e, e.exports), e.exports;
            }
            function It() {
                throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
            }
            var wt = Kt(function(c, t) {
                (function(e) {
                    c.exports = e();
                })(function() {
                    return function() {
                        function e(i, h, u) {
                            function p(a, o) {
                                if (!h[a]) {
                                    if (!i[a]) {
                                        var n = typeof It == "function" && It;
                                        if (!o && n) return n(a, !0);
                                        if (d) return d(a, !0);
                                        var r = new Error("Cannot find module '" + a + "'");
                                        throw r.code = "MODULE_NOT_FOUND", r;
                                    }
                                    var m = h[a] = {
                                        exports: {}
                                    };
                                    i[a][0].call(m.exports, function(b) {
                                        var E = i[a][1][b];
                                        return p(E || b);
                                    }, m, m.exports, e, i, h, u);
                                }
                                return h[a].exports;
                            }
                            for(var d = typeof It == "function" && It, l = 0; l < u.length; l++)p(u[l]);
                            return p;
                        }
                        return e;
                    }()({
                        1: [
                            function(e, i, h) {
                                (function(u, p) {
                                    typeof h == "object" && typeof i < "u" ? p(h) : (u = u || self, p(u.acorn = {}));
                                })(this, function(u) {
                                    var p = {
                                        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
                                        5: "class enum extends super const export import",
                                        6: "enum",
                                        strict: "implements interface let package private protected public static yield",
                                        strictBind: "eval arguments"
                                    }, d = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", l = {
                                        5: d,
                                        "5module": d + " export import",
                                        6: d + " const class extends export import super"
                                    }, a = /^in(stanceof)?$/, o = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࢠ-ࢴࢶ-ࢽऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೞೠೡೱೲഅ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜌᜎ-ᜑᜠ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭋᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-Ⱞⰰ-ⱞⱠ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆺㇰ-ㇿ㐀-䶵一-鿯ꀀ-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꞿꟂ-Ᶎꟷ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭧꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", n = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࣓-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍ୖୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ංඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-ໍ໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜔ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠐-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷹᷻-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿", r = new RegExp("[" + o + "]"), m = new RegExp("[" + o + n + "]");
                                    o = n = null;
                                    var b = [
                                        0,
                                        11,
                                        2,
                                        25,
                                        2,
                                        18,
                                        2,
                                        1,
                                        2,
                                        14,
                                        3,
                                        13,
                                        35,
                                        122,
                                        70,
                                        52,
                                        268,
                                        28,
                                        4,
                                        48,
                                        48,
                                        31,
                                        14,
                                        29,
                                        6,
                                        37,
                                        11,
                                        29,
                                        3,
                                        35,
                                        5,
                                        7,
                                        2,
                                        4,
                                        43,
                                        157,
                                        19,
                                        35,
                                        5,
                                        35,
                                        5,
                                        39,
                                        9,
                                        51,
                                        157,
                                        310,
                                        10,
                                        21,
                                        11,
                                        7,
                                        153,
                                        5,
                                        3,
                                        0,
                                        2,
                                        43,
                                        2,
                                        1,
                                        4,
                                        0,
                                        3,
                                        22,
                                        11,
                                        22,
                                        10,
                                        30,
                                        66,
                                        18,
                                        2,
                                        1,
                                        11,
                                        21,
                                        11,
                                        25,
                                        71,
                                        55,
                                        7,
                                        1,
                                        65,
                                        0,
                                        16,
                                        3,
                                        2,
                                        2,
                                        2,
                                        28,
                                        43,
                                        28,
                                        4,
                                        28,
                                        36,
                                        7,
                                        2,
                                        27,
                                        28,
                                        53,
                                        11,
                                        21,
                                        11,
                                        18,
                                        14,
                                        17,
                                        111,
                                        72,
                                        56,
                                        50,
                                        14,
                                        50,
                                        14,
                                        35,
                                        477,
                                        28,
                                        11,
                                        0,
                                        9,
                                        21,
                                        155,
                                        22,
                                        13,
                                        52,
                                        76,
                                        44,
                                        33,
                                        24,
                                        27,
                                        35,
                                        30,
                                        0,
                                        12,
                                        34,
                                        4,
                                        0,
                                        13,
                                        47,
                                        15,
                                        3,
                                        22,
                                        0,
                                        2,
                                        0,
                                        36,
                                        17,
                                        2,
                                        24,
                                        85,
                                        6,
                                        2,
                                        0,
                                        2,
                                        3,
                                        2,
                                        14,
                                        2,
                                        9,
                                        8,
                                        46,
                                        39,
                                        7,
                                        3,
                                        1,
                                        3,
                                        21,
                                        2,
                                        6,
                                        2,
                                        1,
                                        2,
                                        4,
                                        4,
                                        0,
                                        19,
                                        0,
                                        13,
                                        4,
                                        159,
                                        52,
                                        19,
                                        3,
                                        21,
                                        0,
                                        33,
                                        47,
                                        21,
                                        1,
                                        2,
                                        0,
                                        185,
                                        46,
                                        42,
                                        3,
                                        37,
                                        47,
                                        21,
                                        0,
                                        60,
                                        42,
                                        14,
                                        0,
                                        72,
                                        26,
                                        230,
                                        43,
                                        117,
                                        63,
                                        32,
                                        0,
                                        161,
                                        7,
                                        3,
                                        38,
                                        17,
                                        0,
                                        2,
                                        0,
                                        29,
                                        0,
                                        11,
                                        39,
                                        8,
                                        0,
                                        22,
                                        0,
                                        12,
                                        45,
                                        20,
                                        0,
                                        35,
                                        56,
                                        264,
                                        8,
                                        2,
                                        36,
                                        18,
                                        0,
                                        50,
                                        29,
                                        113,
                                        6,
                                        2,
                                        1,
                                        2,
                                        37,
                                        22,
                                        0,
                                        26,
                                        5,
                                        2,
                                        1,
                                        2,
                                        31,
                                        15,
                                        0,
                                        328,
                                        18,
                                        270,
                                        921,
                                        103,
                                        110,
                                        18,
                                        195,
                                        2749,
                                        1070,
                                        4050,
                                        582,
                                        8634,
                                        568,
                                        8,
                                        30,
                                        114,
                                        29,
                                        19,
                                        47,
                                        17,
                                        3,
                                        32,
                                        20,
                                        6,
                                        18,
                                        689,
                                        63,
                                        129,
                                        74,
                                        6,
                                        0,
                                        67,
                                        12,
                                        65,
                                        1,
                                        2,
                                        0,
                                        29,
                                        6135,
                                        9,
                                        754,
                                        9486,
                                        286,
                                        50,
                                        2,
                                        18,
                                        3,
                                        9,
                                        395,
                                        2309,
                                        106,
                                        6,
                                        12,
                                        4,
                                        8,
                                        8,
                                        9,
                                        5991,
                                        84,
                                        2,
                                        70,
                                        2,
                                        1,
                                        3,
                                        0,
                                        3,
                                        1,
                                        3,
                                        3,
                                        2,
                                        11,
                                        2,
                                        0,
                                        2,
                                        6,
                                        2,
                                        64,
                                        2,
                                        3,
                                        3,
                                        7,
                                        2,
                                        6,
                                        2,
                                        27,
                                        2,
                                        3,
                                        2,
                                        4,
                                        2,
                                        0,
                                        4,
                                        6,
                                        2,
                                        339,
                                        3,
                                        24,
                                        2,
                                        24,
                                        2,
                                        30,
                                        2,
                                        24,
                                        2,
                                        30,
                                        2,
                                        24,
                                        2,
                                        30,
                                        2,
                                        24,
                                        2,
                                        30,
                                        2,
                                        24,
                                        2,
                                        7,
                                        2357,
                                        44,
                                        11,
                                        6,
                                        17,
                                        0,
                                        370,
                                        43,
                                        1301,
                                        196,
                                        60,
                                        67,
                                        8,
                                        0,
                                        1205,
                                        3,
                                        2,
                                        26,
                                        2,
                                        1,
                                        2,
                                        0,
                                        3,
                                        0,
                                        2,
                                        9,
                                        2,
                                        3,
                                        2,
                                        0,
                                        2,
                                        0,
                                        7,
                                        0,
                                        5,
                                        0,
                                        2,
                                        0,
                                        2,
                                        0,
                                        2,
                                        2,
                                        2,
                                        1,
                                        2,
                                        0,
                                        3,
                                        0,
                                        2,
                                        0,
                                        2,
                                        0,
                                        2,
                                        0,
                                        2,
                                        0,
                                        2,
                                        1,
                                        2,
                                        0,
                                        3,
                                        3,
                                        2,
                                        6,
                                        2,
                                        3,
                                        2,
                                        3,
                                        2,
                                        0,
                                        2,
                                        9,
                                        2,
                                        16,
                                        6,
                                        2,
                                        2,
                                        4,
                                        2,
                                        16,
                                        4421,
                                        42710,
                                        42,
                                        4148,
                                        12,
                                        221,
                                        3,
                                        5761,
                                        15,
                                        7472,
                                        3104,
                                        541
                                    ], E = [
                                        509,
                                        0,
                                        227,
                                        0,
                                        150,
                                        4,
                                        294,
                                        9,
                                        1368,
                                        2,
                                        2,
                                        1,
                                        6,
                                        3,
                                        41,
                                        2,
                                        5,
                                        0,
                                        166,
                                        1,
                                        574,
                                        3,
                                        9,
                                        9,
                                        525,
                                        10,
                                        176,
                                        2,
                                        54,
                                        14,
                                        32,
                                        9,
                                        16,
                                        3,
                                        46,
                                        10,
                                        54,
                                        9,
                                        7,
                                        2,
                                        37,
                                        13,
                                        2,
                                        9,
                                        6,
                                        1,
                                        45,
                                        0,
                                        13,
                                        2,
                                        49,
                                        13,
                                        9,
                                        3,
                                        4,
                                        9,
                                        83,
                                        11,
                                        7,
                                        0,
                                        161,
                                        11,
                                        6,
                                        9,
                                        7,
                                        3,
                                        56,
                                        1,
                                        2,
                                        6,
                                        3,
                                        1,
                                        3,
                                        2,
                                        10,
                                        0,
                                        11,
                                        1,
                                        3,
                                        6,
                                        4,
                                        4,
                                        193,
                                        17,
                                        10,
                                        9,
                                        5,
                                        0,
                                        82,
                                        19,
                                        13,
                                        9,
                                        214,
                                        6,
                                        3,
                                        8,
                                        28,
                                        1,
                                        83,
                                        16,
                                        16,
                                        9,
                                        82,
                                        12,
                                        9,
                                        9,
                                        84,
                                        14,
                                        5,
                                        9,
                                        243,
                                        14,
                                        166,
                                        9,
                                        232,
                                        6,
                                        3,
                                        6,
                                        4,
                                        0,
                                        29,
                                        9,
                                        41,
                                        6,
                                        2,
                                        3,
                                        9,
                                        0,
                                        10,
                                        10,
                                        47,
                                        15,
                                        406,
                                        7,
                                        2,
                                        7,
                                        17,
                                        9,
                                        57,
                                        21,
                                        2,
                                        13,
                                        123,
                                        5,
                                        4,
                                        0,
                                        2,
                                        1,
                                        2,
                                        6,
                                        2,
                                        0,
                                        9,
                                        9,
                                        49,
                                        4,
                                        2,
                                        1,
                                        2,
                                        4,
                                        9,
                                        9,
                                        330,
                                        3,
                                        19306,
                                        9,
                                        135,
                                        4,
                                        60,
                                        6,
                                        26,
                                        9,
                                        1014,
                                        0,
                                        2,
                                        54,
                                        8,
                                        3,
                                        19723,
                                        1,
                                        5319,
                                        4,
                                        4,
                                        5,
                                        9,
                                        7,
                                        3,
                                        6,
                                        31,
                                        3,
                                        149,
                                        2,
                                        1418,
                                        49,
                                        513,
                                        54,
                                        5,
                                        49,
                                        9,
                                        0,
                                        15,
                                        0,
                                        23,
                                        4,
                                        2,
                                        14,
                                        1361,
                                        6,
                                        2,
                                        16,
                                        3,
                                        6,
                                        2,
                                        1,
                                        2,
                                        4,
                                        262,
                                        6,
                                        10,
                                        9,
                                        419,
                                        13,
                                        1495,
                                        6,
                                        110,
                                        6,
                                        6,
                                        9,
                                        792487,
                                        239
                                    ];
                                    function w(s, f) {
                                        for(var S = 65536, L = 0; L < f.length; L += 2){
                                            if (S += f[L], S > s) return !1;
                                            if (S += f[L + 1], S >= s) return !0;
                                        }
                                    }
                                    function v(s, f) {
                                        return s < 65 ? s === 36 : s < 91 ? !0 : s < 97 ? s === 95 : s < 123 ? !0 : s <= 65535 ? s >= 170 && r.test(String.fromCharCode(s)) : f === !1 ? !1 : w(s, b);
                                    }
                                    function y(s, f) {
                                        return s < 48 ? s === 36 : s < 58 ? !0 : s < 65 ? !1 : s < 91 ? !0 : s < 97 ? s === 95 : s < 123 ? !0 : s <= 65535 ? s >= 170 && m.test(String.fromCharCode(s)) : f === !1 ? !1 : w(s, b) || w(s, E);
                                    }
                                    var T = function(f, S) {
                                        S === void 0 && (S = {}), this.label = f, this.keyword = S.keyword, this.beforeExpr = !!S.beforeExpr, this.startsExpr = !!S.startsExpr, this.isLoop = !!S.isLoop, this.isAssign = !!S.isAssign, this.prefix = !!S.prefix, this.postfix = !!S.postfix, this.binop = S.binop || null, this.updateContext = null;
                                    };
                                    function _(s, f) {
                                        return new T(s, {
                                            beforeExpr: !0,
                                            binop: f
                                        });
                                    }
                                    var k = {
                                        beforeExpr: !0
                                    }, C = {
                                        startsExpr: !0
                                    }, M = {};
                                    function x(s, f) {
                                        return f === void 0 && (f = {}), f.keyword = s, M[s] = new T(s, f);
                                    }
                                    var g = {
                                        num: new T("num", C),
                                        regexp: new T("regexp", C),
                                        string: new T("string", C),
                                        name: new T("name", C),
                                        eof: new T("eof"),
                                        bracketL: new T("[", {
                                            beforeExpr: !0,
                                            startsExpr: !0
                                        }),
                                        bracketR: new T("]"),
                                        braceL: new T("{", {
                                            beforeExpr: !0,
                                            startsExpr: !0
                                        }),
                                        braceR: new T("}"),
                                        parenL: new T("(", {
                                            beforeExpr: !0,
                                            startsExpr: !0
                                        }),
                                        parenR: new T(")"),
                                        comma: new T(",", k),
                                        semi: new T(";", k),
                                        colon: new T(":", k),
                                        dot: new T("."),
                                        question: new T("?", k),
                                        arrow: new T("=>", k),
                                        template: new T("template"),
                                        invalidTemplate: new T("invalidTemplate"),
                                        ellipsis: new T("...", k),
                                        backQuote: new T("`", C),
                                        dollarBraceL: new T("${", {
                                            beforeExpr: !0,
                                            startsExpr: !0
                                        }),
                                        eq: new T("=", {
                                            beforeExpr: !0,
                                            isAssign: !0
                                        }),
                                        assign: new T("_=", {
                                            beforeExpr: !0,
                                            isAssign: !0
                                        }),
                                        incDec: new T("++/--", {
                                            prefix: !0,
                                            postfix: !0,
                                            startsExpr: !0
                                        }),
                                        prefix: new T("!/~", {
                                            beforeExpr: !0,
                                            prefix: !0,
                                            startsExpr: !0
                                        }),
                                        logicalOR: _("||", 1),
                                        logicalAND: _("&&", 2),
                                        bitwiseOR: _("|", 3),
                                        bitwiseXOR: _("^", 4),
                                        bitwiseAND: _("&", 5),
                                        equality: _("==/!=/===/!==", 6),
                                        relational: _("</>/<=/>=", 7),
                                        bitShift: _("<</>>/>>>", 8),
                                        plusMin: new T("+/-", {
                                            beforeExpr: !0,
                                            binop: 9,
                                            prefix: !0,
                                            startsExpr: !0
                                        }),
                                        modulo: _("%", 10),
                                        star: _("*", 10),
                                        slash: _("/", 10),
                                        starstar: new T("**", {
                                            beforeExpr: !0
                                        }),
                                        _break: x("break"),
                                        _case: x("case", k),
                                        _catch: x("catch"),
                                        _continue: x("continue"),
                                        _debugger: x("debugger"),
                                        _default: x("default", k),
                                        _do: x("do", {
                                            isLoop: !0,
                                            beforeExpr: !0
                                        }),
                                        _else: x("else", k),
                                        _finally: x("finally"),
                                        _for: x("for", {
                                            isLoop: !0
                                        }),
                                        _function: x("function", C),
                                        _if: x("if"),
                                        _return: x("return", k),
                                        _switch: x("switch"),
                                        _throw: x("throw", k),
                                        _try: x("try"),
                                        _var: x("var"),
                                        _const: x("const"),
                                        _while: x("while", {
                                            isLoop: !0
                                        }),
                                        _with: x("with"),
                                        _new: x("new", {
                                            beforeExpr: !0,
                                            startsExpr: !0
                                        }),
                                        _this: x("this", C),
                                        _super: x("super", C),
                                        _class: x("class", C),
                                        _extends: x("extends", k),
                                        _export: x("export"),
                                        _import: x("import", C),
                                        _null: x("null", C),
                                        _true: x("true", C),
                                        _false: x("false", C),
                                        _in: x("in", {
                                            beforeExpr: !0,
                                            binop: 7
                                        }),
                                        _instanceof: x("instanceof", {
                                            beforeExpr: !0,
                                            binop: 7
                                        }),
                                        _typeof: x("typeof", {
                                            beforeExpr: !0,
                                            prefix: !0,
                                            startsExpr: !0
                                        }),
                                        _void: x("void", {
                                            beforeExpr: !0,
                                            prefix: !0,
                                            startsExpr: !0
                                        }),
                                        _delete: x("delete", {
                                            beforeExpr: !0,
                                            prefix: !0,
                                            startsExpr: !0
                                        })
                                    }, I = /\r\n?|\n|\u2028|\u2029/, A = new RegExp(I.source, "g");
                                    function P(s, f) {
                                        return s === 10 || s === 13 || !f && (s === 8232 || s === 8233);
                                    }
                                    var O = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, R = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, G = Object.prototype, U = G.hasOwnProperty, it = G.toString;
                                    function q(s, f) {
                                        return U.call(s, f);
                                    }
                                    var B = Array.isArray || function(s) {
                                        return it.call(s) === "[object Array]";
                                    };
                                    function st(s) {
                                        return new RegExp("^(?:" + s.replace(/ /g, "|") + ")$");
                                    }
                                    var rt = function(f, S) {
                                        this.line = f, this.column = S;
                                    };
                                    rt.prototype.offset = function(f) {
                                        return new rt(this.line, this.column + f);
                                    };
                                    var mt = function(f, S, L) {
                                        this.start = S, this.end = L, f.sourceFile !== null && (this.source = f.sourceFile);
                                    };
                                    function tt(s, f) {
                                        for(var S = 1, L = 0;;){
                                            A.lastIndex = L;
                                            var D = A.exec(s);
                                            if (D && D.index < f) ++S, L = D.index + D[0].length;
                                            else return new rt(S, f - L);
                                        }
                                    }
                                    var et = {
                                        ecmaVersion: 10,
                                        sourceType: "script",
                                        onInsertedSemicolon: null,
                                        onTrailingComma: null,
                                        allowReserved: null,
                                        allowReturnOutsideFunction: !1,
                                        allowImportExportEverywhere: !1,
                                        allowAwaitOutsideFunction: !1,
                                        allowHashBang: !1,
                                        locations: !1,
                                        onToken: null,
                                        onComment: null,
                                        ranges: !1,
                                        program: null,
                                        sourceFile: null,
                                        directSourceFile: null,
                                        preserveParens: !1
                                    };
                                    function J(s) {
                                        var f = {};
                                        for(var S in et)f[S] = s && q(s, S) ? s[S] : et[S];
                                        if (f.ecmaVersion >= 2015 && (f.ecmaVersion -= 2009), f.allowReserved == null && (f.allowReserved = f.ecmaVersion < 5), B(f.onToken)) {
                                            var L = f.onToken;
                                            f.onToken = function(D) {
                                                return L.push(D);
                                            };
                                        }
                                        return B(f.onComment) && (f.onComment = yt(f, f.onComment)), f;
                                    }
                                    function yt(s, f) {
                                        return function(S, L, D, F, K, W) {
                                            var nt = {
                                                type: S ? "Block" : "Line",
                                                value: L,
                                                start: D,
                                                end: F
                                            };
                                            s.locations && (nt.loc = new mt(this, K, W)), s.ranges && (nt.range = [
                                                D,
                                                F
                                            ]), f.push(nt);
                                        };
                                    }
                                    var Pt = 1, pt = 2, _t = Pt | pt, Dt = 4, Ut = 8, Gt = 16, at = 32, Lt = 64, Nt = 128;
                                    function Ht(s, f) {
                                        return pt | (s ? Dt : 0) | (f ? Ut : 0);
                                    }
                                    var ie = 0, Si = 1, se = 2, Ks = 3, Gs = 4, Us = 5, Ct = function(f, S, L) {
                                        this.options = f = J(f), this.sourceFile = f.sourceFile, this.keywords = st(l[f.ecmaVersion >= 6 ? 6 : f.sourceType === "module" ? "5module" : 5]);
                                        var D = "";
                                        if (f.allowReserved !== !0) {
                                            for(var F = f.ecmaVersion; !(D = p[F]); F--);
                                            f.sourceType === "module" && (D += " await");
                                        }
                                        this.reservedWords = st(D);
                                        var K = (D ? D + " " : "") + p.strict;
                                        this.reservedWordsStrict = st(K), this.reservedWordsStrictBind = st(K + " " + p.strictBind), this.input = String(S), this.containsEsc = !1, L ? (this.pos = L, this.lineStart = this.input.lastIndexOf(`
`, L - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(I).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = g.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = f.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = {}, this.pos === 0 && f.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(Pt), this.regexpState = null;
                                    }, me = {
                                        inFunction: {
                                            configurable: !0
                                        },
                                        inGenerator: {
                                            configurable: !0
                                        },
                                        inAsync: {
                                            configurable: !0
                                        },
                                        allowSuper: {
                                            configurable: !0
                                        },
                                        allowDirectSuper: {
                                            configurable: !0
                                        },
                                        treatFunctionsAsVar: {
                                            configurable: !0
                                        }
                                    };
                                    Ct.prototype.parse = function() {
                                        var f = this.options.program || this.startNode();
                                        return this.nextToken(), this.parseTopLevel(f);
                                    }, me.inFunction.get = function() {
                                        return (this.currentVarScope().flags & pt) > 0;
                                    }, me.inGenerator.get = function() {
                                        return (this.currentVarScope().flags & Ut) > 0;
                                    }, me.inAsync.get = function() {
                                        return (this.currentVarScope().flags & Dt) > 0;
                                    }, me.allowSuper.get = function() {
                                        return (this.currentThisScope().flags & Lt) > 0;
                                    }, me.allowDirectSuper.get = function() {
                                        return (this.currentThisScope().flags & Nt) > 0;
                                    }, me.treatFunctionsAsVar.get = function() {
                                        return this.treatFunctionsAsVarInScope(this.currentScope());
                                    }, Ct.prototype.inNonArrowFunction = function() {
                                        return (this.currentThisScope().flags & pt) > 0;
                                    }, Ct.extend = function() {
                                        for(var f = [], S = arguments.length; S--;)f[S] = arguments[S];
                                        for(var L = this, D = 0; D < f.length; D++)L = f[D](L);
                                        return L;
                                    }, Ct.parse = function(f, S) {
                                        return new this(S, f).parse();
                                    }, Ct.parseExpressionAt = function(f, S, L) {
                                        var D = new this(L, f, S);
                                        return D.nextToken(), D.parseExpression();
                                    }, Ct.tokenizer = function(f, S) {
                                        return new this(S, f);
                                    }, Object.defineProperties(Ct.prototype, me);
                                    var Bt = Ct.prototype, Va = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
                                    Bt.strictDirective = function(s) {
                                        for(;;){
                                            R.lastIndex = s, s += R.exec(this.input)[0].length;
                                            var f = Va.exec(this.input.slice(s));
                                            if (!f) return !1;
                                            if ((f[1] || f[2]) === "use strict") return !0;
                                            s += f[0].length, R.lastIndex = s, s += R.exec(this.input)[0].length, this.input[s] === ";" && s++;
                                        }
                                    }, Bt.eat = function(s) {
                                        return this.type === s ? (this.next(), !0) : !1;
                                    }, Bt.isContextual = function(s) {
                                        return this.type === g.name && this.value === s && !this.containsEsc;
                                    }, Bt.eatContextual = function(s) {
                                        return this.isContextual(s) ? (this.next(), !0) : !1;
                                    }, Bt.expectContextual = function(s) {
                                        this.eatContextual(s) || this.unexpected();
                                    }, Bt.canInsertSemicolon = function() {
                                        return this.type === g.eof || this.type === g.braceR || I.test(this.input.slice(this.lastTokEnd, this.start));
                                    }, Bt.insertSemicolon = function() {
                                        if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
                                    }, Bt.semicolon = function() {
                                        !this.eat(g.semi) && !this.insertSemicolon() && this.unexpected();
                                    }, Bt.afterTrailingComma = function(s, f) {
                                        if (this.type === s) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), f || this.next(), !0;
                                    }, Bt.expect = function(s) {
                                        this.eat(s) || this.unexpected();
                                    }, Bt.unexpected = function(s) {
                                        this.raise(s ?? this.start, "Unexpected token");
                                    };
                                    function Ze() {
                                        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
                                    }
                                    Bt.checkPatternErrors = function(s, f) {
                                        if (s) {
                                            s.trailingComma > -1 && this.raiseRecoverable(s.trailingComma, "Comma is not permitted after the rest element");
                                            var S = f ? s.parenthesizedAssign : s.parenthesizedBind;
                                            S > -1 && this.raiseRecoverable(S, "Parenthesized pattern");
                                        }
                                    }, Bt.checkExpressionErrors = function(s, f) {
                                        if (!s) return !1;
                                        var S = s.shorthandAssign, L = s.doubleProto;
                                        if (!f) return S >= 0 || L >= 0;
                                        S >= 0 && this.raise(S, "Shorthand property assignments are valid only in destructuring patterns"), L >= 0 && this.raiseRecoverable(L, "Redefinition of __proto__ property");
                                    }, Bt.checkYieldAwaitInDefaultParams = function() {
                                        this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
                                    }, Bt.isSimpleAssignTarget = function(s) {
                                        return s.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(s.expression) : s.type === "Identifier" || s.type === "MemberExpression";
                                    };
                                    var ft = Ct.prototype;
                                    ft.parseTopLevel = function(s) {
                                        var f = {};
                                        for(s.body || (s.body = []); this.type !== g.eof;){
                                            var S = this.parseStatement(null, !0, f);
                                            s.body.push(S);
                                        }
                                        if (this.inModule) for(var L = 0, D = Object.keys(this.undefinedExports); L < D.length; L += 1){
                                            var F = D[L];
                                            this.raiseRecoverable(this.undefinedExports[F].start, "Export '" + F + "' is not defined");
                                        }
                                        return this.adaptDirectivePrologue(s.body), this.next(), s.sourceType = this.options.sourceType, this.finishNode(s, "Program");
                                    };
                                    var vi = {
                                        kind: "loop"
                                    }, Ka = {
                                        kind: "switch"
                                    };
                                    ft.isLet = function(s) {
                                        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1;
                                        R.lastIndex = this.pos;
                                        var f = R.exec(this.input), S = this.pos + f[0].length, L = this.input.charCodeAt(S);
                                        if (L === 91) return !0;
                                        if (s) return !1;
                                        if (L === 123) return !0;
                                        if (v(L, !0)) {
                                            for(var D = S + 1; y(this.input.charCodeAt(D), !0);)++D;
                                            var F = this.input.slice(S, D);
                                            if (!a.test(F)) return !0;
                                        }
                                        return !1;
                                    }, ft.isAsyncFunction = function() {
                                        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1;
                                        R.lastIndex = this.pos;
                                        var s = R.exec(this.input), f = this.pos + s[0].length;
                                        return !I.test(this.input.slice(this.pos, f)) && this.input.slice(f, f + 8) === "function" && (f + 8 === this.input.length || !y(this.input.charAt(f + 8)));
                                    }, ft.parseStatement = function(s, f, S) {
                                        var L = this.type, D = this.startNode(), F;
                                        switch(this.isLet(s) && (L = g._var, F = "let"), L){
                                            case g._break:
                                            case g._continue:
                                                return this.parseBreakContinueStatement(D, L.keyword);
                                            case g._debugger:
                                                return this.parseDebuggerStatement(D);
                                            case g._do:
                                                return this.parseDoStatement(D);
                                            case g._for:
                                                return this.parseForStatement(D);
                                            case g._function:
                                                return s && (this.strict || s !== "if" && s !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(D, !1, !s);
                                            case g._class:
                                                return s && this.unexpected(), this.parseClass(D, !0);
                                            case g._if:
                                                return this.parseIfStatement(D);
                                            case g._return:
                                                return this.parseReturnStatement(D);
                                            case g._switch:
                                                return this.parseSwitchStatement(D);
                                            case g._throw:
                                                return this.parseThrowStatement(D);
                                            case g._try:
                                                return this.parseTryStatement(D);
                                            case g._const:
                                            case g._var:
                                                return F = F || this.value, s && F !== "var" && this.unexpected(), this.parseVarStatement(D, F);
                                            case g._while:
                                                return this.parseWhileStatement(D);
                                            case g._with:
                                                return this.parseWithStatement(D);
                                            case g.braceL:
                                                return this.parseBlock(!0, D);
                                            case g.semi:
                                                return this.parseEmptyStatement(D);
                                            case g._export:
                                            case g._import:
                                                if (this.options.ecmaVersion > 10 && L === g._import) {
                                                    R.lastIndex = this.pos;
                                                    var K = R.exec(this.input), W = this.pos + K[0].length, nt = this.input.charCodeAt(W);
                                                    if (nt === 40) return this.parseExpressionStatement(D, this.parseExpression());
                                                }
                                                return this.options.allowImportExportEverywhere || (f || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), L === g._import ? this.parseImport(D) : this.parseExport(D, S);
                                            default:
                                                if (this.isAsyncFunction()) return s && this.unexpected(), this.next(), this.parseFunctionStatement(D, !0, !s);
                                                var Et = this.value, jt = this.parseExpression();
                                                return L === g.name && jt.type === "Identifier" && this.eat(g.colon) ? this.parseLabeledStatement(D, Et, jt, s) : this.parseExpressionStatement(D, jt);
                                        }
                                    }, ft.parseBreakContinueStatement = function(s, f) {
                                        var S = f === "break";
                                        this.next(), this.eat(g.semi) || this.insertSemicolon() ? s.label = null : this.type !== g.name ? this.unexpected() : (s.label = this.parseIdent(), this.semicolon());
                                        for(var L = 0; L < this.labels.length; ++L){
                                            var D = this.labels[L];
                                            if ((s.label == null || D.name === s.label.name) && (D.kind != null && (S || D.kind === "loop") || s.label && S)) break;
                                        }
                                        return L === this.labels.length && this.raise(s.start, "Unsyntactic " + f), this.finishNode(s, S ? "BreakStatement" : "ContinueStatement");
                                    }, ft.parseDebuggerStatement = function(s) {
                                        return this.next(), this.semicolon(), this.finishNode(s, "DebuggerStatement");
                                    }, ft.parseDoStatement = function(s) {
                                        return this.next(), this.labels.push(vi), s.body = this.parseStatement("do"), this.labels.pop(), this.expect(g._while), s.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(g.semi) : this.semicolon(), this.finishNode(s, "DoWhileStatement");
                                    }, ft.parseForStatement = function(s) {
                                        this.next();
                                        var f = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
                                        if (this.labels.push(vi), this.enterScope(0), this.expect(g.parenL), this.type === g.semi) return f > -1 && this.unexpected(f), this.parseFor(s, null);
                                        var S = this.isLet();
                                        if (this.type === g._var || this.type === g._const || S) {
                                            var L = this.startNode(), D = S ? "let" : this.value;
                                            return this.next(), this.parseVar(L, !0, D), this.finishNode(L, "VariableDeclaration"), (this.type === g._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && L.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === g._in ? f > -1 && this.unexpected(f) : s.await = f > -1), this.parseForIn(s, L)) : (f > -1 && this.unexpected(f), this.parseFor(s, L));
                                        }
                                        var F = new Ze, K = this.parseExpression(!0, F);
                                        return this.type === g._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? (this.options.ecmaVersion >= 9 && (this.type === g._in ? f > -1 && this.unexpected(f) : s.await = f > -1), this.toAssignable(K, !1, F), this.checkLVal(K), this.parseForIn(s, K)) : (this.checkExpressionErrors(F, !0), f > -1 && this.unexpected(f), this.parseFor(s, K));
                                    }, ft.parseFunctionStatement = function(s, f, S) {
                                        return this.next(), this.parseFunction(s, ze | (S ? 0 : _i), !1, f);
                                    }, ft.parseIfStatement = function(s) {
                                        return this.next(), s.test = this.parseParenExpression(), s.consequent = this.parseStatement("if"), s.alternate = this.eat(g._else) ? this.parseStatement("if") : null, this.finishNode(s, "IfStatement");
                                    }, ft.parseReturnStatement = function(s) {
                                        return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(g.semi) || this.insertSemicolon() ? s.argument = null : (s.argument = this.parseExpression(), this.semicolon()), this.finishNode(s, "ReturnStatement");
                                    }, ft.parseSwitchStatement = function(s) {
                                        this.next(), s.discriminant = this.parseParenExpression(), s.cases = [], this.expect(g.braceL), this.labels.push(Ka), this.enterScope(0);
                                        for(var f, S = !1; this.type !== g.braceR;)if (this.type === g._case || this.type === g._default) {
                                            var L = this.type === g._case;
                                            f && this.finishNode(f, "SwitchCase"), s.cases.push(f = this.startNode()), f.consequent = [], this.next(), L ? f.test = this.parseExpression() : (S && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), S = !0, f.test = null), this.expect(g.colon);
                                        } else f || this.unexpected(), f.consequent.push(this.parseStatement(null));
                                        return this.exitScope(), f && this.finishNode(f, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(s, "SwitchStatement");
                                    }, ft.parseThrowStatement = function(s) {
                                        return this.next(), I.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), s.argument = this.parseExpression(), this.semicolon(), this.finishNode(s, "ThrowStatement");
                                    };
                                    var Ga = [];
                                    ft.parseTryStatement = function(s) {
                                        if (this.next(), s.block = this.parseBlock(), s.handler = null, this.type === g._catch) {
                                            var f = this.startNode();
                                            if (this.next(), this.eat(g.parenL)) {
                                                f.param = this.parseBindingAtom();
                                                var S = f.param.type === "Identifier";
                                                this.enterScope(S ? at : 0), this.checkLVal(f.param, S ? Gs : se), this.expect(g.parenR);
                                            } else this.options.ecmaVersion < 10 && this.unexpected(), f.param = null, this.enterScope(0);
                                            f.body = this.parseBlock(!1), this.exitScope(), s.handler = this.finishNode(f, "CatchClause");
                                        }
                                        return s.finalizer = this.eat(g._finally) ? this.parseBlock() : null, !s.handler && !s.finalizer && this.raise(s.start, "Missing catch or finally clause"), this.finishNode(s, "TryStatement");
                                    }, ft.parseVarStatement = function(s, f) {
                                        return this.next(), this.parseVar(s, !1, f), this.semicolon(), this.finishNode(s, "VariableDeclaration");
                                    }, ft.parseWhileStatement = function(s) {
                                        return this.next(), s.test = this.parseParenExpression(), this.labels.push(vi), s.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(s, "WhileStatement");
                                    }, ft.parseWithStatement = function(s) {
                                        return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), s.object = this.parseParenExpression(), s.body = this.parseStatement("with"), this.finishNode(s, "WithStatement");
                                    }, ft.parseEmptyStatement = function(s) {
                                        return this.next(), this.finishNode(s, "EmptyStatement");
                                    }, ft.parseLabeledStatement = function(s, f, S, L) {
                                        for(var D = 0, F = this.labels; D < F.length; D += 1){
                                            var K = F[D];
                                            K.name === f && this.raise(S.start, "Label '" + f + "' is already declared");
                                        }
                                        for(var W = this.type.isLoop ? "loop" : this.type === g._switch ? "switch" : null, nt = this.labels.length - 1; nt >= 0; nt--){
                                            var Et = this.labels[nt];
                                            if (Et.statementStart === s.start) Et.statementStart = this.start, Et.kind = W;
                                            else break;
                                        }
                                        return this.labels.push({
                                            name: f,
                                            kind: W,
                                            statementStart: this.start
                                        }), s.body = this.parseStatement(L ? L.indexOf("label") === -1 ? L + "label" : L : "label"), this.labels.pop(), s.label = S, this.finishNode(s, "LabeledStatement");
                                    }, ft.parseExpressionStatement = function(s, f) {
                                        return s.expression = f, this.semicolon(), this.finishNode(s, "ExpressionStatement");
                                    }, ft.parseBlock = function(s, f) {
                                        for(s === void 0 && (s = !0), f === void 0 && (f = this.startNode()), f.body = [], this.expect(g.braceL), s && this.enterScope(0); !this.eat(g.braceR);){
                                            var S = this.parseStatement(null);
                                            f.body.push(S);
                                        }
                                        return s && this.exitScope(), this.finishNode(f, "BlockStatement");
                                    }, ft.parseFor = function(s, f) {
                                        return s.init = f, this.expect(g.semi), s.test = this.type === g.semi ? null : this.parseExpression(), this.expect(g.semi), s.update = this.type === g.parenR ? null : this.parseExpression(), this.expect(g.parenR), s.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(s, "ForStatement");
                                    }, ft.parseForIn = function(s, f) {
                                        var S = this.type === g._in;
                                        return this.next(), f.type === "VariableDeclaration" && f.declarations[0].init != null && (!S || this.options.ecmaVersion < 8 || this.strict || f.kind !== "var" || f.declarations[0].id.type !== "Identifier") ? this.raise(f.start, (S ? "for-in" : "for-of") + " loop variable declaration may not have an initializer") : f.type === "AssignmentPattern" && this.raise(f.start, "Invalid left-hand side in for-loop"), s.left = f, s.right = S ? this.parseExpression() : this.parseMaybeAssign(), this.expect(g.parenR), s.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(s, S ? "ForInStatement" : "ForOfStatement");
                                    }, ft.parseVar = function(s, f, S) {
                                        for(s.declarations = [], s.kind = S;;){
                                            var L = this.startNode();
                                            if (this.parseVarId(L, S), this.eat(g.eq) ? L.init = this.parseMaybeAssign(f) : S === "const" && !(this.type === g._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : L.id.type !== "Identifier" && !(f && (this.type === g._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : L.init = null, s.declarations.push(this.finishNode(L, "VariableDeclarator")), !this.eat(g.comma)) break;
                                        }
                                        return s;
                                    }, ft.parseVarId = function(s, f) {
                                        s.id = this.parseBindingAtom(), this.checkLVal(s.id, f === "var" ? Si : se, !1);
                                    };
                                    var ze = 1, _i = 2, Bs = 4;
                                    ft.parseFunction = function(s, f, S, L) {
                                        this.initFunction(s), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !L) && (this.type === g.star && f & _i && this.unexpected(), s.generator = this.eat(g.star)), this.options.ecmaVersion >= 8 && (s.async = !!L), f & ze && (s.id = f & Bs && this.type !== g.name ? null : this.parseIdent(), s.id && !(f & _i) && this.checkLVal(s.id, this.strict || s.generator || s.async ? this.treatFunctionsAsVar ? Si : se : Ks));
                                        var D = this.yieldPos, F = this.awaitPos, K = this.awaitIdentPos;
                                        return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Ht(s.async, s.generator)), f & ze || (s.id = this.type === g.name ? this.parseIdent() : null), this.parseFunctionParams(s), this.parseFunctionBody(s, S, !1), this.yieldPos = D, this.awaitPos = F, this.awaitIdentPos = K, this.finishNode(s, f & ze ? "FunctionDeclaration" : "FunctionExpression");
                                    }, ft.parseFunctionParams = function(s) {
                                        this.expect(g.parenL), s.params = this.parseBindingList(g.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
                                    }, ft.parseClass = function(s, f) {
                                        this.next();
                                        var S = this.strict;
                                        this.strict = !0, this.parseClassId(s, f), this.parseClassSuper(s);
                                        var L = this.startNode(), D = !1;
                                        for(L.body = [], this.expect(g.braceL); !this.eat(g.braceR);){
                                            var F = this.parseClassElement(s.superClass !== null);
                                            F && (L.body.push(F), F.type === "MethodDefinition" && F.kind === "constructor" && (D && this.raise(F.start, "Duplicate constructor in the same class"), D = !0));
                                        }
                                        return s.body = this.finishNode(L, "ClassBody"), this.strict = S, this.finishNode(s, f ? "ClassDeclaration" : "ClassExpression");
                                    }, ft.parseClassElement = function(s) {
                                        var f = this;
                                        if (this.eat(g.semi)) return null;
                                        var S = this.startNode(), L = function(nt, Et) {
                                            Et === void 0 && (Et = !1);
                                            var jt = f.start, ae = f.startLoc;
                                            return f.eatContextual(nt) ? f.type !== g.parenL && (!Et || !f.canInsertSemicolon()) ? !0 : (S.key && f.unexpected(), S.computed = !1, S.key = f.startNodeAt(jt, ae), S.key.name = nt, f.finishNode(S.key, "Identifier"), !1) : !1;
                                        };
                                        S.kind = "method", S.static = L("static");
                                        var D = this.eat(g.star), F = !1;
                                        D || (this.options.ecmaVersion >= 8 && L("async", !0) ? (F = !0, D = this.options.ecmaVersion >= 9 && this.eat(g.star)) : L("get") ? S.kind = "get" : L("set") && (S.kind = "set")), S.key || this.parsePropertyName(S);
                                        var K = S.key, W = !1;
                                        return !S.computed && !S.static && (K.type === "Identifier" && K.name === "constructor" || K.type === "Literal" && K.value === "constructor") ? (S.kind !== "method" && this.raise(K.start, "Constructor can't have get/set modifier"), D && this.raise(K.start, "Constructor can't be a generator"), F && this.raise(K.start, "Constructor can't be an async method"), S.kind = "constructor", W = s) : S.static && K.type === "Identifier" && K.name === "prototype" && this.raise(K.start, "Classes may not have a static property named prototype"), this.parseClassMethod(S, D, F, W), S.kind === "get" && S.value.params.length !== 0 && this.raiseRecoverable(S.value.start, "getter should have no params"), S.kind === "set" && S.value.params.length !== 1 && this.raiseRecoverable(S.value.start, "setter should have exactly one param"), S.kind === "set" && S.value.params[0].type === "RestElement" && this.raiseRecoverable(S.value.params[0].start, "Setter cannot use rest params"), S;
                                    }, ft.parseClassMethod = function(s, f, S, L) {
                                        return s.value = this.parseMethod(f, S, L), this.finishNode(s, "MethodDefinition");
                                    }, ft.parseClassId = function(s, f) {
                                        this.type === g.name ? (s.id = this.parseIdent(), f && this.checkLVal(s.id, se, !1)) : (f === !0 && this.unexpected(), s.id = null);
                                    }, ft.parseClassSuper = function(s) {
                                        s.superClass = this.eat(g._extends) ? this.parseExprSubscripts() : null;
                                    }, ft.parseExport = function(s, f) {
                                        if (this.next(), this.eat(g.star)) return this.expectContextual("from"), this.type !== g.string && this.unexpected(), s.source = this.parseExprAtom(), this.semicolon(), this.finishNode(s, "ExportAllDeclaration");
                                        if (this.eat(g._default)) {
                                            this.checkExport(f, "default", this.lastTokStart);
                                            var S;
                                            if (this.type === g._function || (S = this.isAsyncFunction())) {
                                                var L = this.startNode();
                                                this.next(), S && this.next(), s.declaration = this.parseFunction(L, ze | Bs, !1, S);
                                            } else if (this.type === g._class) {
                                                var D = this.startNode();
                                                s.declaration = this.parseClass(D, "nullableID");
                                            } else s.declaration = this.parseMaybeAssign(), this.semicolon();
                                            return this.finishNode(s, "ExportDefaultDeclaration");
                                        }
                                        if (this.shouldParseExportStatement()) s.declaration = this.parseStatement(null), s.declaration.type === "VariableDeclaration" ? this.checkVariableExport(f, s.declaration.declarations) : this.checkExport(f, s.declaration.id.name, s.declaration.id.start), s.specifiers = [], s.source = null;
                                        else {
                                            if (s.declaration = null, s.specifiers = this.parseExportSpecifiers(f), this.eatContextual("from")) this.type !== g.string && this.unexpected(), s.source = this.parseExprAtom();
                                            else {
                                                for(var F = 0, K = s.specifiers; F < K.length; F += 1){
                                                    var W = K[F];
                                                    this.checkUnreserved(W.local), this.checkLocalExport(W.local);
                                                }
                                                s.source = null;
                                            }
                                            this.semicolon();
                                        }
                                        return this.finishNode(s, "ExportNamedDeclaration");
                                    }, ft.checkExport = function(s, f, S) {
                                        s && (q(s, f) && this.raiseRecoverable(S, "Duplicate export '" + f + "'"), s[f] = !0);
                                    }, ft.checkPatternExport = function(s, f) {
                                        var S = f.type;
                                        if (S === "Identifier") this.checkExport(s, f.name, f.start);
                                        else if (S === "ObjectPattern") for(var L = 0, D = f.properties; L < D.length; L += 1){
                                            var F = D[L];
                                            this.checkPatternExport(s, F);
                                        }
                                        else if (S === "ArrayPattern") for(var K = 0, W = f.elements; K < W.length; K += 1){
                                            var nt = W[K];
                                            nt && this.checkPatternExport(s, nt);
                                        }
                                        else S === "Property" ? this.checkPatternExport(s, f.value) : S === "AssignmentPattern" ? this.checkPatternExport(s, f.left) : S === "RestElement" ? this.checkPatternExport(s, f.argument) : S === "ParenthesizedExpression" && this.checkPatternExport(s, f.expression);
                                    }, ft.checkVariableExport = function(s, f) {
                                        if (s) for(var S = 0, L = f; S < L.length; S += 1){
                                            var D = L[S];
                                            this.checkPatternExport(s, D.id);
                                        }
                                    }, ft.shouldParseExportStatement = function() {
                                        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
                                    }, ft.parseExportSpecifiers = function(s) {
                                        var f = [], S = !0;
                                        for(this.expect(g.braceL); !this.eat(g.braceR);){
                                            if (S) S = !1;
                                            else if (this.expect(g.comma), this.afterTrailingComma(g.braceR)) break;
                                            var L = this.startNode();
                                            L.local = this.parseIdent(!0), L.exported = this.eatContextual("as") ? this.parseIdent(!0) : L.local, this.checkExport(s, L.exported.name, L.exported.start), f.push(this.finishNode(L, "ExportSpecifier"));
                                        }
                                        return f;
                                    }, ft.parseImport = function(s) {
                                        return this.next(), this.type === g.string ? (s.specifiers = Ga, s.source = this.parseExprAtom()) : (s.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), s.source = this.type === g.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(s, "ImportDeclaration");
                                    }, ft.parseImportSpecifiers = function() {
                                        var s = [], f = !0;
                                        if (this.type === g.name) {
                                            var S = this.startNode();
                                            if (S.local = this.parseIdent(), this.checkLVal(S.local, se), s.push(this.finishNode(S, "ImportDefaultSpecifier")), !this.eat(g.comma)) return s;
                                        }
                                        if (this.type === g.star) {
                                            var L = this.startNode();
                                            return this.next(), this.expectContextual("as"), L.local = this.parseIdent(), this.checkLVal(L.local, se), s.push(this.finishNode(L, "ImportNamespaceSpecifier")), s;
                                        }
                                        for(this.expect(g.braceL); !this.eat(g.braceR);){
                                            if (f) f = !1;
                                            else if (this.expect(g.comma), this.afterTrailingComma(g.braceR)) break;
                                            var D = this.startNode();
                                            D.imported = this.parseIdent(!0), this.eatContextual("as") ? D.local = this.parseIdent() : (this.checkUnreserved(D.imported), D.local = D.imported), this.checkLVal(D.local, se), s.push(this.finishNode(D, "ImportSpecifier"));
                                        }
                                        return s;
                                    }, ft.adaptDirectivePrologue = function(s) {
                                        for(var f = 0; f < s.length && this.isDirectiveCandidate(s[f]); ++f)s[f].directive = s[f].expression.raw.slice(1, -1);
                                    }, ft.isDirectiveCandidate = function(s) {
                                        return s.type === "ExpressionStatement" && s.expression.type === "Literal" && typeof s.expression.value == "string" && (this.input[s.start] === '"' || this.input[s.start] === "'");
                                    };
                                    var ne = Ct.prototype;
                                    ne.toAssignable = function(s, f, S) {
                                        if (this.options.ecmaVersion >= 6 && s) switch(s.type){
                                            case "Identifier":
                                                this.inAsync && s.name === "await" && this.raise(s.start, "Cannot use 'await' as identifier inside an async function");
                                                break;
                                            case "ObjectPattern":
                                            case "ArrayPattern":
                                            case "RestElement":
                                                break;
                                            case "ObjectExpression":
                                                s.type = "ObjectPattern", S && this.checkPatternErrors(S, !0);
                                                for(var L = 0, D = s.properties; L < D.length; L += 1){
                                                    var F = D[L];
                                                    this.toAssignable(F, f), F.type === "RestElement" && (F.argument.type === "ArrayPattern" || F.argument.type === "ObjectPattern") && this.raise(F.argument.start, "Unexpected token");
                                                }
                                                break;
                                            case "Property":
                                                s.kind !== "init" && this.raise(s.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(s.value, f);
                                                break;
                                            case "ArrayExpression":
                                                s.type = "ArrayPattern", S && this.checkPatternErrors(S, !0), this.toAssignableList(s.elements, f);
                                                break;
                                            case "SpreadElement":
                                                s.type = "RestElement", this.toAssignable(s.argument, f), s.argument.type === "AssignmentPattern" && this.raise(s.argument.start, "Rest elements cannot have a default value");
                                                break;
                                            case "AssignmentExpression":
                                                s.operator !== "=" && this.raise(s.left.end, "Only '=' operator can be used for specifying default value."), s.type = "AssignmentPattern", delete s.operator, this.toAssignable(s.left, f);
                                            case "AssignmentPattern":
                                                break;
                                            case "ParenthesizedExpression":
                                                this.toAssignable(s.expression, f, S);
                                                break;
                                            case "MemberExpression":
                                                if (!f) break;
                                            default:
                                                this.raise(s.start, "Assigning to rvalue");
                                        }
                                        else S && this.checkPatternErrors(S, !0);
                                        return s;
                                    }, ne.toAssignableList = function(s, f) {
                                        for(var S = s.length, L = 0; L < S; L++){
                                            var D = s[L];
                                            D && this.toAssignable(D, f);
                                        }
                                        if (S) {
                                            var F = s[S - 1];
                                            this.options.ecmaVersion === 6 && f && F && F.type === "RestElement" && F.argument.type !== "Identifier" && this.unexpected(F.argument.start);
                                        }
                                        return s;
                                    }, ne.parseSpread = function(s) {
                                        var f = this.startNode();
                                        return this.next(), f.argument = this.parseMaybeAssign(!1, s), this.finishNode(f, "SpreadElement");
                                    }, ne.parseRestBinding = function() {
                                        var s = this.startNode();
                                        return this.next(), this.options.ecmaVersion === 6 && this.type !== g.name && this.unexpected(), s.argument = this.parseBindingAtom(), this.finishNode(s, "RestElement");
                                    }, ne.parseBindingAtom = function() {
                                        if (this.options.ecmaVersion >= 6) switch(this.type){
                                            case g.bracketL:
                                                var s = this.startNode();
                                                return this.next(), s.elements = this.parseBindingList(g.bracketR, !0, !0), this.finishNode(s, "ArrayPattern");
                                            case g.braceL:
                                                return this.parseObj(!0);
                                        }
                                        return this.parseIdent();
                                    }, ne.parseBindingList = function(s, f, S) {
                                        for(var L = [], D = !0; !this.eat(s);)if (D ? D = !1 : this.expect(g.comma), f && this.type === g.comma) L.push(null);
                                        else {
                                            if (S && this.afterTrailingComma(s)) break;
                                            if (this.type === g.ellipsis) {
                                                var F = this.parseRestBinding();
                                                this.parseBindingListItem(F), L.push(F), this.type === g.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(s);
                                                break;
                                            } else {
                                                var K = this.parseMaybeDefault(this.start, this.startLoc);
                                                this.parseBindingListItem(K), L.push(K);
                                            }
                                        }
                                        return L;
                                    }, ne.parseBindingListItem = function(s) {
                                        return s;
                                    }, ne.parseMaybeDefault = function(s, f, S) {
                                        if (S = S || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(g.eq)) return S;
                                        var L = this.startNodeAt(s, f);
                                        return L.left = S, L.right = this.parseMaybeAssign(), this.finishNode(L, "AssignmentPattern");
                                    }, ne.checkLVal = function(s, f, S) {
                                        switch(f === void 0 && (f = ie), s.type){
                                            case "Identifier":
                                                f === se && s.name === "let" && this.raiseRecoverable(s.start, "let is disallowed as a lexically bound name"), this.strict && this.reservedWordsStrictBind.test(s.name) && this.raiseRecoverable(s.start, (f ? "Binding " : "Assigning to ") + s.name + " in strict mode"), S && (q(S, s.name) && this.raiseRecoverable(s.start, "Argument name clash"), S[s.name] = !0), f !== ie && f !== Us && this.declareName(s.name, f, s.start);
                                                break;
                                            case "MemberExpression":
                                                f && this.raiseRecoverable(s.start, "Binding member expression");
                                                break;
                                            case "ObjectPattern":
                                                for(var L = 0, D = s.properties; L < D.length; L += 1){
                                                    var F = D[L];
                                                    this.checkLVal(F, f, S);
                                                }
                                                break;
                                            case "Property":
                                                this.checkLVal(s.value, f, S);
                                                break;
                                            case "ArrayPattern":
                                                for(var K = 0, W = s.elements; K < W.length; K += 1){
                                                    var nt = W[K];
                                                    nt && this.checkLVal(nt, f, S);
                                                }
                                                break;
                                            case "AssignmentPattern":
                                                this.checkLVal(s.left, f, S);
                                                break;
                                            case "RestElement":
                                                this.checkLVal(s.argument, f, S);
                                                break;
                                            case "ParenthesizedExpression":
                                                this.checkLVal(s.expression, f, S);
                                                break;
                                            default:
                                                this.raise(s.start, (f ? "Binding" : "Assigning to") + " rvalue");
                                        }
                                    };
                                    var xt = Ct.prototype;
                                    xt.checkPropClash = function(s, f, S) {
                                        if (!(this.options.ecmaVersion >= 9 && s.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (s.computed || s.method || s.shorthand))) {
                                            var L = s.key, D;
                                            switch(L.type){
                                                case "Identifier":
                                                    D = L.name;
                                                    break;
                                                case "Literal":
                                                    D = String(L.value);
                                                    break;
                                                default:
                                                    return;
                                            }
                                            var F = s.kind;
                                            if (this.options.ecmaVersion >= 6) {
                                                D === "__proto__" && F === "init" && (f.proto && (S ? S.doubleProto < 0 && (S.doubleProto = L.start) : this.raiseRecoverable(L.start, "Redefinition of __proto__ property")), f.proto = !0);
                                                return;
                                            }
                                            D = "$" + D;
                                            var K = f[D];
                                            if (K) {
                                                var W;
                                                F === "init" ? W = this.strict && K.init || K.get || K.set : W = K.init || K[F], W && this.raiseRecoverable(L.start, "Redefinition of property");
                                            } else K = f[D] = {
                                                init: !1,
                                                get: !1,
                                                set: !1
                                            };
                                            K[F] = !0;
                                        }
                                    }, xt.parseExpression = function(s, f) {
                                        var S = this.start, L = this.startLoc, D = this.parseMaybeAssign(s, f);
                                        if (this.type === g.comma) {
                                            var F = this.startNodeAt(S, L);
                                            for(F.expressions = [
                                                D
                                            ]; this.eat(g.comma);)F.expressions.push(this.parseMaybeAssign(s, f));
                                            return this.finishNode(F, "SequenceExpression");
                                        }
                                        return D;
                                    }, xt.parseMaybeAssign = function(s, f, S) {
                                        if (this.isContextual("yield")) {
                                            if (this.inGenerator) return this.parseYield(s);
                                            this.exprAllowed = !1;
                                        }
                                        var L = !1, D = -1, F = -1;
                                        f ? (D = f.parenthesizedAssign, F = f.trailingComma, f.parenthesizedAssign = f.trailingComma = -1) : (f = new Ze, L = !0);
                                        var K = this.start, W = this.startLoc;
                                        (this.type === g.parenL || this.type === g.name) && (this.potentialArrowAt = this.start);
                                        var nt = this.parseMaybeConditional(s, f);
                                        if (S && (nt = S.call(this, nt, K, W)), this.type.isAssign) {
                                            var Et = this.startNodeAt(K, W);
                                            return Et.operator = this.value, Et.left = this.type === g.eq ? this.toAssignable(nt, !1, f) : nt, L || (f.parenthesizedAssign = f.trailingComma = f.doubleProto = -1), f.shorthandAssign >= Et.left.start && (f.shorthandAssign = -1), this.checkLVal(nt), this.next(), Et.right = this.parseMaybeAssign(s), this.finishNode(Et, "AssignmentExpression");
                                        } else L && this.checkExpressionErrors(f, !0);
                                        return D > -1 && (f.parenthesizedAssign = D), F > -1 && (f.trailingComma = F), nt;
                                    }, xt.parseMaybeConditional = function(s, f) {
                                        var S = this.start, L = this.startLoc, D = this.parseExprOps(s, f);
                                        if (this.checkExpressionErrors(f)) return D;
                                        if (this.eat(g.question)) {
                                            var F = this.startNodeAt(S, L);
                                            return F.test = D, F.consequent = this.parseMaybeAssign(), this.expect(g.colon), F.alternate = this.parseMaybeAssign(s), this.finishNode(F, "ConditionalExpression");
                                        }
                                        return D;
                                    }, xt.parseExprOps = function(s, f) {
                                        var S = this.start, L = this.startLoc, D = this.parseMaybeUnary(f, !1);
                                        return this.checkExpressionErrors(f) || D.start === S && D.type === "ArrowFunctionExpression" ? D : this.parseExprOp(D, S, L, -1, s);
                                    }, xt.parseExprOp = function(s, f, S, L, D) {
                                        var F = this.type.binop;
                                        if (F != null && (!D || this.type !== g._in) && F > L) {
                                            var K = this.type === g.logicalOR || this.type === g.logicalAND, W = this.value;
                                            this.next();
                                            var nt = this.start, Et = this.startLoc, jt = this.parseExprOp(this.parseMaybeUnary(null, !1), nt, Et, F, D), ae = this.buildBinary(f, S, s, jt, W, K);
                                            return this.parseExprOp(ae, f, S, L, D);
                                        }
                                        return s;
                                    }, xt.buildBinary = function(s, f, S, L, D, F) {
                                        var K = this.startNodeAt(s, f);
                                        return K.left = S, K.operator = D, K.right = L, this.finishNode(K, F ? "LogicalExpression" : "BinaryExpression");
                                    }, xt.parseMaybeUnary = function(s, f) {
                                        var S = this.start, L = this.startLoc, D;
                                        if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) D = this.parseAwait(), f = !0;
                                        else if (this.type.prefix) {
                                            var F = this.startNode(), K = this.type === g.incDec;
                                            F.operator = this.value, F.prefix = !0, this.next(), F.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(s, !0), K ? this.checkLVal(F.argument) : this.strict && F.operator === "delete" && F.argument.type === "Identifier" ? this.raiseRecoverable(F.start, "Deleting local variable in strict mode") : f = !0, D = this.finishNode(F, K ? "UpdateExpression" : "UnaryExpression");
                                        } else {
                                            if (D = this.parseExprSubscripts(s), this.checkExpressionErrors(s)) return D;
                                            for(; this.type.postfix && !this.canInsertSemicolon();){
                                                var W = this.startNodeAt(S, L);
                                                W.operator = this.value, W.prefix = !1, W.argument = D, this.checkLVal(D), this.next(), D = this.finishNode(W, "UpdateExpression");
                                            }
                                        }
                                        return !f && this.eat(g.starstar) ? this.buildBinary(S, L, D, this.parseMaybeUnary(null, !1), "**", !1) : D;
                                    }, xt.parseExprSubscripts = function(s) {
                                        var f = this.start, S = this.startLoc, L = this.parseExprAtom(s);
                                        if (L.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return L;
                                        var D = this.parseSubscripts(L, f, S);
                                        return s && D.type === "MemberExpression" && (s.parenthesizedAssign >= D.start && (s.parenthesizedAssign = -1), s.parenthesizedBind >= D.start && (s.parenthesizedBind = -1)), D;
                                    }, xt.parseSubscripts = function(s, f, S, L) {
                                        for(var D = this.options.ecmaVersion >= 8 && s.type === "Identifier" && s.name === "async" && this.lastTokEnd === s.end && !this.canInsertSemicolon() && this.input.slice(s.start, s.end) === "async";;){
                                            var F = this.parseSubscript(s, f, S, L, D);
                                            if (F === s || F.type === "ArrowFunctionExpression") return F;
                                            s = F;
                                        }
                                    }, xt.parseSubscript = function(s, f, S, L, D) {
                                        var F = this.eat(g.bracketL);
                                        if (F || this.eat(g.dot)) {
                                            var K = this.startNodeAt(f, S);
                                            K.object = s, K.property = F ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never"), K.computed = !!F, F && this.expect(g.bracketR), s = this.finishNode(K, "MemberExpression");
                                        } else if (!L && this.eat(g.parenL)) {
                                            var W = new Ze, nt = this.yieldPos, Et = this.awaitPos, jt = this.awaitIdentPos;
                                            this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
                                            var ae = this.parseExprList(g.parenR, this.options.ecmaVersion >= 8, !1, W);
                                            if (D && !this.canInsertSemicolon() && this.eat(g.arrow)) return this.checkPatternErrors(W, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = nt, this.awaitPos = Et, this.awaitIdentPos = jt, this.parseArrowExpression(this.startNodeAt(f, S), ae, !0);
                                            this.checkExpressionErrors(W, !0), this.yieldPos = nt || this.yieldPos, this.awaitPos = Et || this.awaitPos, this.awaitIdentPos = jt || this.awaitIdentPos;
                                            var _e = this.startNodeAt(f, S);
                                            _e.callee = s, _e.arguments = ae, s = this.finishNode(_e, "CallExpression");
                                        } else if (this.type === g.backQuote) {
                                            var ye = this.startNodeAt(f, S);
                                            ye.tag = s, ye.quasi = this.parseTemplate({
                                                isTagged: !0
                                            }), s = this.finishNode(ye, "TaggedTemplateExpression");
                                        }
                                        return s;
                                    }, xt.parseExprAtom = function(s) {
                                        this.type === g.slash && this.readRegexp();
                                        var f, S = this.potentialArrowAt === this.start;
                                        switch(this.type){
                                            case g._super:
                                                return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), f = this.startNode(), this.next(), this.type === g.parenL && !this.allowDirectSuper && this.raise(f.start, "super() call outside constructor of a subclass"), this.type !== g.dot && this.type !== g.bracketL && this.type !== g.parenL && this.unexpected(), this.finishNode(f, "Super");
                                            case g._this:
                                                return f = this.startNode(), this.next(), this.finishNode(f, "ThisExpression");
                                            case g.name:
                                                var L = this.start, D = this.startLoc, F = this.containsEsc, K = this.parseIdent(!1);
                                                if (this.options.ecmaVersion >= 8 && !F && K.name === "async" && !this.canInsertSemicolon() && this.eat(g._function)) return this.parseFunction(this.startNodeAt(L, D), 0, !1, !0);
                                                if (S && !this.canInsertSemicolon()) {
                                                    if (this.eat(g.arrow)) return this.parseArrowExpression(this.startNodeAt(L, D), [
                                                        K
                                                    ], !1);
                                                    if (this.options.ecmaVersion >= 8 && K.name === "async" && this.type === g.name && !F) return K = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(g.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(L, D), [
                                                        K
                                                    ], !0);
                                                }
                                                return K;
                                            case g.regexp:
                                                var W = this.value;
                                                return f = this.parseLiteral(W.value), f.regex = {
                                                    pattern: W.pattern,
                                                    flags: W.flags
                                                }, f;
                                            case g.num:
                                            case g.string:
                                                return this.parseLiteral(this.value);
                                            case g._null:
                                            case g._true:
                                            case g._false:
                                                return f = this.startNode(), f.value = this.type === g._null ? null : this.type === g._true, f.raw = this.type.keyword, this.next(), this.finishNode(f, "Literal");
                                            case g.parenL:
                                                var nt = this.start, Et = this.parseParenAndDistinguishExpression(S);
                                                return s && (s.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(Et) && (s.parenthesizedAssign = nt), s.parenthesizedBind < 0 && (s.parenthesizedBind = nt)), Et;
                                            case g.bracketL:
                                                return f = this.startNode(), this.next(), f.elements = this.parseExprList(g.bracketR, !0, !0, s), this.finishNode(f, "ArrayExpression");
                                            case g.braceL:
                                                return this.parseObj(!1, s);
                                            case g._function:
                                                return f = this.startNode(), this.next(), this.parseFunction(f, 0);
                                            case g._class:
                                                return this.parseClass(this.startNode(), !1);
                                            case g._new:
                                                return this.parseNew();
                                            case g.backQuote:
                                                return this.parseTemplate();
                                            case g._import:
                                                return this.options.ecmaVersion >= 11 ? this.parseExprImport() : this.unexpected();
                                            default:
                                                this.unexpected();
                                        }
                                    }, xt.parseExprImport = function() {
                                        var s = this.startNode();
                                        switch(this.next(), this.type){
                                            case g.parenL:
                                                return this.parseDynamicImport(s);
                                            default:
                                                this.unexpected();
                                        }
                                    }, xt.parseDynamicImport = function(s) {
                                        if (this.next(), s.source = this.parseMaybeAssign(), !this.eat(g.parenR)) {
                                            var f = this.start;
                                            this.eat(g.comma) && this.eat(g.parenR) ? this.raiseRecoverable(f, "Trailing comma is not allowed in import()") : this.unexpected(f);
                                        }
                                        return this.finishNode(s, "ImportExpression");
                                    }, xt.parseLiteral = function(s) {
                                        var f = this.startNode();
                                        return f.value = s, f.raw = this.input.slice(this.start, this.end), f.raw.charCodeAt(f.raw.length - 1) === 110 && (f.bigint = f.raw.slice(0, -1)), this.next(), this.finishNode(f, "Literal");
                                    }, xt.parseParenExpression = function() {
                                        this.expect(g.parenL);
                                        var s = this.parseExpression();
                                        return this.expect(g.parenR), s;
                                    }, xt.parseParenAndDistinguishExpression = function(s) {
                                        var f = this.start, S = this.startLoc, L, D = this.options.ecmaVersion >= 8;
                                        if (this.options.ecmaVersion >= 6) {
                                            this.next();
                                            var F = this.start, K = this.startLoc, W = [], nt = !0, Et = !1, jt = new Ze, ae = this.yieldPos, _e = this.awaitPos, ye;
                                            for(this.yieldPos = 0, this.awaitPos = 0; this.type !== g.parenR;)if (nt ? nt = !1 : this.expect(g.comma), D && this.afterTrailingComma(g.parenR, !0)) {
                                                Et = !0;
                                                break;
                                            } else if (this.type === g.ellipsis) {
                                                ye = this.start, W.push(this.parseParenItem(this.parseRestBinding())), this.type === g.comma && this.raise(this.start, "Comma is not permitted after the rest element");
                                                break;
                                            } else W.push(this.parseMaybeAssign(!1, jt, this.parseParenItem));
                                            var so = this.start, no = this.startLoc;
                                            if (this.expect(g.parenR), s && !this.canInsertSemicolon() && this.eat(g.arrow)) return this.checkPatternErrors(jt, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = ae, this.awaitPos = _e, this.parseParenArrowList(f, S, W);
                                            (!W.length || Et) && this.unexpected(this.lastTokStart), ye && this.unexpected(ye), this.checkExpressionErrors(jt, !0), this.yieldPos = ae || this.yieldPos, this.awaitPos = _e || this.awaitPos, W.length > 1 ? (L = this.startNodeAt(F, K), L.expressions = W, this.finishNodeAt(L, "SequenceExpression", so, no)) : L = W[0];
                                        } else L = this.parseParenExpression();
                                        if (this.options.preserveParens) {
                                            var on = this.startNodeAt(f, S);
                                            return on.expression = L, this.finishNode(on, "ParenthesizedExpression");
                                        } else return L;
                                    }, xt.parseParenItem = function(s) {
                                        return s;
                                    }, xt.parseParenArrowList = function(s, f, S) {
                                        return this.parseArrowExpression(this.startNodeAt(s, f), S);
                                    };
                                    var Ua = [];
                                    xt.parseNew = function() {
                                        this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
                                        var s = this.startNode(), f = this.parseIdent(!0);
                                        if (this.options.ecmaVersion >= 6 && this.eat(g.dot)) {
                                            s.meta = f;
                                            var S = this.containsEsc;
                                            return s.property = this.parseIdent(!0), (s.property.name !== "target" || S) && this.raiseRecoverable(s.property.start, "The only valid meta property for new is new.target"), this.inNonArrowFunction() || this.raiseRecoverable(s.start, "new.target can only be used in functions"), this.finishNode(s, "MetaProperty");
                                        }
                                        var L = this.start, D = this.startLoc, F = this.type === g._import;
                                        return s.callee = this.parseSubscripts(this.parseExprAtom(), L, D, !0), F && s.callee.type === "ImportExpression" && this.raise(L, "Cannot use new with import()"), this.eat(g.parenL) ? s.arguments = this.parseExprList(g.parenR, this.options.ecmaVersion >= 8, !1) : s.arguments = Ua, this.finishNode(s, "NewExpression");
                                    }, xt.parseTemplateElement = function(s) {
                                        var f = s.isTagged, S = this.startNode();
                                        return this.type === g.invalidTemplate ? (f || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), S.value = {
                                            raw: this.value,
                                            cooked: null
                                        }) : S.value = {
                                            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
                                            cooked: this.value
                                        }, this.next(), S.tail = this.type === g.backQuote, this.finishNode(S, "TemplateElement");
                                    }, xt.parseTemplate = function(s) {
                                        s === void 0 && (s = {});
                                        var f = s.isTagged;
                                        f === void 0 && (f = !1);
                                        var S = this.startNode();
                                        this.next(), S.expressions = [];
                                        var L = this.parseTemplateElement({
                                            isTagged: f
                                        });
                                        for(S.quasis = [
                                            L
                                        ]; !L.tail;)this.type === g.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(g.dollarBraceL), S.expressions.push(this.parseExpression()), this.expect(g.braceR), S.quasis.push(L = this.parseTemplateElement({
                                            isTagged: f
                                        }));
                                        return this.next(), this.finishNode(S, "TemplateLiteral");
                                    }, xt.isAsyncProp = function(s) {
                                        return !s.computed && s.key.type === "Identifier" && s.key.name === "async" && (this.type === g.name || this.type === g.num || this.type === g.string || this.type === g.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === g.star) && !I.test(this.input.slice(this.lastTokEnd, this.start));
                                    }, xt.parseObj = function(s, f) {
                                        var S = this.startNode(), L = !0, D = {};
                                        for(S.properties = [], this.next(); !this.eat(g.braceR);){
                                            if (L) L = !1;
                                            else if (this.expect(g.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(g.braceR)) break;
                                            var F = this.parseProperty(s, f);
                                            s || this.checkPropClash(F, D, f), S.properties.push(F);
                                        }
                                        return this.finishNode(S, s ? "ObjectPattern" : "ObjectExpression");
                                    }, xt.parseProperty = function(s, f) {
                                        var S = this.startNode(), L, D, F, K;
                                        if (this.options.ecmaVersion >= 9 && this.eat(g.ellipsis)) return s ? (S.argument = this.parseIdent(!1), this.type === g.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.finishNode(S, "RestElement")) : (this.type === g.parenL && f && (f.parenthesizedAssign < 0 && (f.parenthesizedAssign = this.start), f.parenthesizedBind < 0 && (f.parenthesizedBind = this.start)), S.argument = this.parseMaybeAssign(!1, f), this.type === g.comma && f && f.trailingComma < 0 && (f.trailingComma = this.start), this.finishNode(S, "SpreadElement"));
                                        this.options.ecmaVersion >= 6 && (S.method = !1, S.shorthand = !1, (s || f) && (F = this.start, K = this.startLoc), s || (L = this.eat(g.star)));
                                        var W = this.containsEsc;
                                        return this.parsePropertyName(S), !s && !W && this.options.ecmaVersion >= 8 && !L && this.isAsyncProp(S) ? (D = !0, L = this.options.ecmaVersion >= 9 && this.eat(g.star), this.parsePropertyName(S, f)) : D = !1, this.parsePropertyValue(S, s, L, D, F, K, f, W), this.finishNode(S, "Property");
                                    }, xt.parsePropertyValue = function(s, f, S, L, D, F, K, W) {
                                        if ((S || L) && this.type === g.colon && this.unexpected(), this.eat(g.colon)) s.value = f ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, K), s.kind = "init";
                                        else if (this.options.ecmaVersion >= 6 && this.type === g.parenL) f && this.unexpected(), s.kind = "init", s.method = !0, s.value = this.parseMethod(S, L);
                                        else if (!f && !W && this.options.ecmaVersion >= 5 && !s.computed && s.key.type === "Identifier" && (s.key.name === "get" || s.key.name === "set") && this.type !== g.comma && this.type !== g.braceR) {
                                            (S || L) && this.unexpected(), s.kind = s.key.name, this.parsePropertyName(s), s.value = this.parseMethod(!1);
                                            var nt = s.kind === "get" ? 0 : 1;
                                            if (s.value.params.length !== nt) {
                                                var Et = s.value.start;
                                                s.kind === "get" ? this.raiseRecoverable(Et, "getter should have no params") : this.raiseRecoverable(Et, "setter should have exactly one param");
                                            } else s.kind === "set" && s.value.params[0].type === "RestElement" && this.raiseRecoverable(s.value.params[0].start, "Setter cannot use rest params");
                                        } else this.options.ecmaVersion >= 6 && !s.computed && s.key.type === "Identifier" ? ((S || L) && this.unexpected(), this.checkUnreserved(s.key), s.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = D), s.kind = "init", f ? s.value = this.parseMaybeDefault(D, F, s.key) : this.type === g.eq && K ? (K.shorthandAssign < 0 && (K.shorthandAssign = this.start), s.value = this.parseMaybeDefault(D, F, s.key)) : s.value = s.key, s.shorthand = !0) : this.unexpected();
                                    }, xt.parsePropertyName = function(s) {
                                        if (this.options.ecmaVersion >= 6) {
                                            if (this.eat(g.bracketL)) return s.computed = !0, s.key = this.parseMaybeAssign(), this.expect(g.bracketR), s.key;
                                            s.computed = !1;
                                        }
                                        return s.key = this.type === g.num || this.type === g.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
                                    }, xt.initFunction = function(s) {
                                        s.id = null, this.options.ecmaVersion >= 6 && (s.generator = s.expression = !1), this.options.ecmaVersion >= 8 && (s.async = !1);
                                    }, xt.parseMethod = function(s, f, S) {
                                        var L = this.startNode(), D = this.yieldPos, F = this.awaitPos, K = this.awaitIdentPos;
                                        return this.initFunction(L), this.options.ecmaVersion >= 6 && (L.generator = s), this.options.ecmaVersion >= 8 && (L.async = !!f), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Ht(f, L.generator) | Lt | (S ? Nt : 0)), this.expect(g.parenL), L.params = this.parseBindingList(g.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(L, !1, !0), this.yieldPos = D, this.awaitPos = F, this.awaitIdentPos = K, this.finishNode(L, "FunctionExpression");
                                    }, xt.parseArrowExpression = function(s, f, S) {
                                        var L = this.yieldPos, D = this.awaitPos, F = this.awaitIdentPos;
                                        return this.enterScope(Ht(S, !1) | Gt), this.initFunction(s), this.options.ecmaVersion >= 8 && (s.async = !!S), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, s.params = this.toAssignableList(f, !0), this.parseFunctionBody(s, !0, !1), this.yieldPos = L, this.awaitPos = D, this.awaitIdentPos = F, this.finishNode(s, "ArrowFunctionExpression");
                                    }, xt.parseFunctionBody = function(s, f, S) {
                                        var L = f && this.type !== g.braceL, D = this.strict, F = !1;
                                        if (L) s.body = this.parseMaybeAssign(), s.expression = !0, this.checkParams(s, !1);
                                        else {
                                            var K = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(s.params);
                                            (!D || K) && (F = this.strictDirective(this.end), F && K && this.raiseRecoverable(s.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
                                            var W = this.labels;
                                            this.labels = [], F && (this.strict = !0), this.checkParams(s, !D && !F && !f && !S && this.isSimpleParamList(s.params)), s.body = this.parseBlock(!1), s.expression = !1, this.adaptDirectivePrologue(s.body.body), this.labels = W;
                                        }
                                        this.exitScope(), this.strict && s.id && this.checkLVal(s.id, Us), this.strict = D;
                                    }, xt.isSimpleParamList = function(s) {
                                        for(var f = 0, S = s; f < S.length; f += 1){
                                            var L = S[f];
                                            if (L.type !== "Identifier") return !1;
                                        }
                                        return !0;
                                    }, xt.checkParams = function(s, f) {
                                        for(var S = {}, L = 0, D = s.params; L < D.length; L += 1){
                                            var F = D[L];
                                            this.checkLVal(F, Si, f ? null : S);
                                        }
                                    }, xt.parseExprList = function(s, f, S, L) {
                                        for(var D = [], F = !0; !this.eat(s);){
                                            if (F) F = !1;
                                            else if (this.expect(g.comma), f && this.afterTrailingComma(s)) break;
                                            var K = void 0;
                                            S && this.type === g.comma ? K = null : this.type === g.ellipsis ? (K = this.parseSpread(L), L && this.type === g.comma && L.trailingComma < 0 && (L.trailingComma = this.start)) : K = this.parseMaybeAssign(!1, L), D.push(K);
                                        }
                                        return D;
                                    }, xt.checkUnreserved = function(s) {
                                        var f = s.start, S = s.end, L = s.name;
                                        if (this.inGenerator && L === "yield" && this.raiseRecoverable(f, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && L === "await" && this.raiseRecoverable(f, "Cannot use 'await' as identifier inside an async function"), this.keywords.test(L) && this.raise(f, "Unexpected keyword '" + L + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(f, S).indexOf("\\") !== -1)) {
                                            var D = this.strict ? this.reservedWordsStrict : this.reservedWords;
                                            D.test(L) && (!this.inAsync && L === "await" && this.raiseRecoverable(f, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(f, "The keyword '" + L + "' is reserved"));
                                        }
                                    }, xt.parseIdent = function(s, f) {
                                        var S = this.startNode();
                                        return this.type === g.name ? S.name = this.value : this.type.keyword ? (S.name = this.type.keyword, (S.name === "class" || S.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop()) : this.unexpected(), this.next(!!s), this.finishNode(S, "Identifier"), s || (this.checkUnreserved(S), S.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = S.start)), S;
                                    }, xt.parseYield = function(s) {
                                        this.yieldPos || (this.yieldPos = this.start);
                                        var f = this.startNode();
                                        return this.next(), this.type === g.semi || this.canInsertSemicolon() || this.type !== g.star && !this.type.startsExpr ? (f.delegate = !1, f.argument = null) : (f.delegate = this.eat(g.star), f.argument = this.parseMaybeAssign(s)), this.finishNode(f, "YieldExpression");
                                    }, xt.parseAwait = function() {
                                        this.awaitPos || (this.awaitPos = this.start);
                                        var s = this.startNode();
                                        return this.next(), s.argument = this.parseMaybeUnary(null, !1), this.finishNode(s, "AwaitExpression");
                                    };
                                    var qe = Ct.prototype;
                                    qe.raise = function(s, f) {
                                        var S = tt(this.input, s);
                                        f += " (" + S.line + ":" + S.column + ")";
                                        var L = new SyntaxError(f);
                                        throw L.pos = s, L.loc = S, L.raisedAt = this.pos, L;
                                    }, qe.raiseRecoverable = qe.raise, qe.curPosition = function() {
                                        if (this.options.locations) return new rt(this.curLine, this.pos - this.lineStart);
                                    };
                                    var pe = Ct.prototype, Ba = function(f) {
                                        this.flags = f, this.var = [], this.lexical = [], this.functions = [];
                                    };
                                    pe.enterScope = function(s) {
                                        this.scopeStack.push(new Ba(s));
                                    }, pe.exitScope = function() {
                                        this.scopeStack.pop();
                                    }, pe.treatFunctionsAsVarInScope = function(s) {
                                        return s.flags & pt || !this.inModule && s.flags & Pt;
                                    }, pe.declareName = function(s, f, S) {
                                        var L = !1;
                                        if (f === se) {
                                            var D = this.currentScope();
                                            L = D.lexical.indexOf(s) > -1 || D.functions.indexOf(s) > -1 || D.var.indexOf(s) > -1, D.lexical.push(s), this.inModule && D.flags & Pt && delete this.undefinedExports[s];
                                        } else if (f === Gs) {
                                            var F = this.currentScope();
                                            F.lexical.push(s);
                                        } else if (f === Ks) {
                                            var K = this.currentScope();
                                            this.treatFunctionsAsVar ? L = K.lexical.indexOf(s) > -1 : L = K.lexical.indexOf(s) > -1 || K.var.indexOf(s) > -1, K.functions.push(s);
                                        } else for(var W = this.scopeStack.length - 1; W >= 0; --W){
                                            var nt = this.scopeStack[W];
                                            if (nt.lexical.indexOf(s) > -1 && !(nt.flags & at && nt.lexical[0] === s) || !this.treatFunctionsAsVarInScope(nt) && nt.functions.indexOf(s) > -1) {
                                                L = !0;
                                                break;
                                            }
                                            if (nt.var.push(s), this.inModule && nt.flags & Pt && delete this.undefinedExports[s], nt.flags & _t) break;
                                        }
                                        L && this.raiseRecoverable(S, "Identifier '" + s + "' has already been declared");
                                    }, pe.checkLocalExport = function(s) {
                                        this.scopeStack[0].lexical.indexOf(s.name) === -1 && this.scopeStack[0].var.indexOf(s.name) === -1 && (this.undefinedExports[s.name] = s);
                                    }, pe.currentScope = function() {
                                        return this.scopeStack[this.scopeStack.length - 1];
                                    }, pe.currentVarScope = function() {
                                        for(var s = this.scopeStack.length - 1;; s--){
                                            var f = this.scopeStack[s];
                                            if (f.flags & _t) return f;
                                        }
                                    }, pe.currentThisScope = function() {
                                        for(var s = this.scopeStack.length - 1;; s--){
                                            var f = this.scopeStack[s];
                                            if (f.flags & _t && !(f.flags & Gt)) return f;
                                        }
                                    };
                                    var Qe = function(f, S, L) {
                                        this.type = "", this.start = S, this.end = 0, f.options.locations && (this.loc = new mt(f, L)), f.options.directSourceFile && (this.sourceFile = f.options.directSourceFile), f.options.ranges && (this.range = [
                                            S,
                                            0
                                        ]);
                                    }, ti = Ct.prototype;
                                    ti.startNode = function() {
                                        return new Qe(this, this.start, this.startLoc);
                                    }, ti.startNodeAt = function(s, f) {
                                        return new Qe(this, s, f);
                                    };
                                    function Ws(s, f, S, L) {
                                        return s.type = f, s.end = S, this.options.locations && (s.loc.end = L), this.options.ranges && (s.range[1] = S), s;
                                    }
                                    ti.finishNode = function(s, f) {
                                        return Ws.call(this, s, f, this.lastTokEnd, this.lastTokEndLoc);
                                    }, ti.finishNodeAt = function(s, f, S, L) {
                                        return Ws.call(this, s, f, S, L);
                                    };
                                    var Yt = function(f, S, L, D, F) {
                                        this.token = f, this.isExpr = !!S, this.preserveSpace = !!L, this.override = D, this.generator = !!F;
                                    }, Ft = {
                                        b_stat: new Yt("{", !1),
                                        b_expr: new Yt("{", !0),
                                        b_tmpl: new Yt("${", !1),
                                        p_stat: new Yt("(", !1),
                                        p_expr: new Yt("(", !0),
                                        q_tmpl: new Yt("`", !0, !0, function(s) {
                                            return s.tryReadTemplateToken();
                                        }),
                                        f_stat: new Yt("function", !1),
                                        f_expr: new Yt("function", !0),
                                        f_expr_gen: new Yt("function", !0, !1, null, !0),
                                        f_gen: new Yt("function", !1, !1, null, !0)
                                    }, ei = Ct.prototype;
                                    ei.initialContext = function() {
                                        return [
                                            Ft.b_stat
                                        ];
                                    }, ei.braceIsBlock = function(s) {
                                        var f = this.curContext();
                                        return f === Ft.f_expr || f === Ft.f_stat ? !0 : s === g.colon && (f === Ft.b_stat || f === Ft.b_expr) ? !f.isExpr : s === g._return || s === g.name && this.exprAllowed ? I.test(this.input.slice(this.lastTokEnd, this.start)) : s === g._else || s === g.semi || s === g.eof || s === g.parenR || s === g.arrow ? !0 : s === g.braceL ? f === Ft.b_stat : s === g._var || s === g._const || s === g.name ? !1 : !this.exprAllowed;
                                    }, ei.inGeneratorContext = function() {
                                        for(var s = this.context.length - 1; s >= 1; s--){
                                            var f = this.context[s];
                                            if (f.token === "function") return f.generator;
                                        }
                                        return !1;
                                    }, ei.updateContext = function(s) {
                                        var f, S = this.type;
                                        S.keyword && s === g.dot ? this.exprAllowed = !1 : (f = S.updateContext) ? f.call(this, s) : this.exprAllowed = S.beforeExpr;
                                    }, g.parenR.updateContext = g.braceR.updateContext = function() {
                                        if (this.context.length === 1) {
                                            this.exprAllowed = !0;
                                            return;
                                        }
                                        var s = this.context.pop();
                                        s === Ft.b_stat && this.curContext().token === "function" && (s = this.context.pop()), this.exprAllowed = !s.isExpr;
                                    }, g.braceL.updateContext = function(s) {
                                        this.context.push(this.braceIsBlock(s) ? Ft.b_stat : Ft.b_expr), this.exprAllowed = !0;
                                    }, g.dollarBraceL.updateContext = function() {
                                        this.context.push(Ft.b_tmpl), this.exprAllowed = !0;
                                    }, g.parenL.updateContext = function(s) {
                                        var f = s === g._if || s === g._for || s === g._with || s === g._while;
                                        this.context.push(f ? Ft.p_stat : Ft.p_expr), this.exprAllowed = !0;
                                    }, g.incDec.updateContext = function() {}, g._function.updateContext = g._class.updateContext = function(s) {
                                        s.beforeExpr && s !== g.semi && s !== g._else && !(s === g._return && I.test(this.input.slice(this.lastTokEnd, this.start))) && !((s === g.colon || s === g.braceL) && this.curContext() === Ft.b_stat) ? this.context.push(Ft.f_expr) : this.context.push(Ft.f_stat), this.exprAllowed = !1;
                                    }, g.backQuote.updateContext = function() {
                                        this.curContext() === Ft.q_tmpl ? this.context.pop() : this.context.push(Ft.q_tmpl), this.exprAllowed = !1;
                                    }, g.star.updateContext = function(s) {
                                        if (s === g._function) {
                                            var f = this.context.length - 1;
                                            this.context[f] === Ft.f_expr ? this.context[f] = Ft.f_expr_gen : this.context[f] = Ft.f_gen;
                                        }
                                        this.exprAllowed = !0;
                                    }, g.name.updateContext = function(s) {
                                        var f = !1;
                                        this.options.ecmaVersion >= 6 && s !== g.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (f = !0), this.exprAllowed = f;
                                    };
                                    var js = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", Hs = js + " Extended_Pictographic", Wa = Hs, ja = {
                                        9: js,
                                        10: Hs,
                                        11: Wa
                                    }, Xs = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", Ys = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", Js = Ys + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", Ha = Js + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", Xa = {
                                        9: Ys,
                                        10: Js,
                                        11: Ha
                                    }, Zs = {};
                                    function Ei(s) {
                                        var f = Zs[s] = {
                                            binary: st(ja[s] + " " + Xs),
                                            nonBinary: {
                                                General_Category: st(Xs),
                                                Script: st(Xa[s])
                                            }
                                        };
                                        f.nonBinary.Script_Extensions = f.nonBinary.Script, f.nonBinary.gc = f.nonBinary.General_Category, f.nonBinary.sc = f.nonBinary.Script, f.nonBinary.scx = f.nonBinary.Script_Extensions;
                                    }
                                    Ei(9), Ei(10), Ei(11);
                                    var Q = Ct.prototype, re = function(f) {
                                        this.parser = f, this.validFlags = "gim" + (f.options.ecmaVersion >= 6 ? "uy" : "") + (f.options.ecmaVersion >= 9 ? "s" : ""), this.unicodeProperties = Zs[f.options.ecmaVersion >= 11 ? 11 : f.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
                                    };
                                    re.prototype.reset = function(f, S, L) {
                                        var D = L.indexOf("u") !== -1;
                                        this.start = f | 0, this.source = S + "", this.flags = L, this.switchU = D && this.parser.options.ecmaVersion >= 6, this.switchN = D && this.parser.options.ecmaVersion >= 9;
                                    }, re.prototype.raise = function(f) {
                                        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + f);
                                    }, re.prototype.at = function(f) {
                                        var S = this.source, L = S.length;
                                        if (f >= L) return -1;
                                        var D = S.charCodeAt(f);
                                        if (!this.switchU || D <= 55295 || D >= 57344 || f + 1 >= L) return D;
                                        var F = S.charCodeAt(f + 1);
                                        return F >= 56320 && F <= 57343 ? (D << 10) + F - 56613888 : D;
                                    }, re.prototype.nextIndex = function(f) {
                                        var S = this.source, L = S.length;
                                        if (f >= L) return L;
                                        var D = S.charCodeAt(f), F;
                                        return !this.switchU || D <= 55295 || D >= 57344 || f + 1 >= L || (F = S.charCodeAt(f + 1)) < 56320 || F > 57343 ? f + 1 : f + 2;
                                    }, re.prototype.current = function() {
                                        return this.at(this.pos);
                                    }, re.prototype.lookahead = function() {
                                        return this.at(this.nextIndex(this.pos));
                                    }, re.prototype.advance = function() {
                                        this.pos = this.nextIndex(this.pos);
                                    }, re.prototype.eat = function(f) {
                                        return this.current() === f ? (this.advance(), !0) : !1;
                                    };
                                    function ii(s) {
                                        return s <= 65535 ? String.fromCharCode(s) : (s -= 65536, String.fromCharCode((s >> 10) + 55296, (s & 1023) + 56320));
                                    }
                                    Q.validateRegExpFlags = function(s) {
                                        for(var f = s.validFlags, S = s.flags, L = 0; L < S.length; L++){
                                            var D = S.charAt(L);
                                            f.indexOf(D) === -1 && this.raise(s.start, "Invalid regular expression flag"), S.indexOf(D, L + 1) > -1 && this.raise(s.start, "Duplicate regular expression flag");
                                        }
                                    }, Q.validateRegExpPattern = function(s) {
                                        this.regexp_pattern(s), !s.switchN && this.options.ecmaVersion >= 9 && s.groupNames.length > 0 && (s.switchN = !0, this.regexp_pattern(s));
                                    }, Q.regexp_pattern = function(s) {
                                        s.pos = 0, s.lastIntValue = 0, s.lastStringValue = "", s.lastAssertionIsQuantifiable = !1, s.numCapturingParens = 0, s.maxBackReference = 0, s.groupNames.length = 0, s.backReferenceNames.length = 0, this.regexp_disjunction(s), s.pos !== s.source.length && (s.eat(41) && s.raise("Unmatched ')'"), (s.eat(93) || s.eat(125)) && s.raise("Lone quantifier brackets")), s.maxBackReference > s.numCapturingParens && s.raise("Invalid escape");
                                        for(var f = 0, S = s.backReferenceNames; f < S.length; f += 1){
                                            var L = S[f];
                                            s.groupNames.indexOf(L) === -1 && s.raise("Invalid named capture referenced");
                                        }
                                    }, Q.regexp_disjunction = function(s) {
                                        for(this.regexp_alternative(s); s.eat(124);)this.regexp_alternative(s);
                                        this.regexp_eatQuantifier(s, !0) && s.raise("Nothing to repeat"), s.eat(123) && s.raise("Lone quantifier brackets");
                                    }, Q.regexp_alternative = function(s) {
                                        for(; s.pos < s.source.length && this.regexp_eatTerm(s););
                                    }, Q.regexp_eatTerm = function(s) {
                                        return this.regexp_eatAssertion(s) ? (s.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(s) && s.switchU && s.raise("Invalid quantifier"), !0) : (s.switchU ? this.regexp_eatAtom(s) : this.regexp_eatExtendedAtom(s)) ? (this.regexp_eatQuantifier(s), !0) : !1;
                                    }, Q.regexp_eatAssertion = function(s) {
                                        var f = s.pos;
                                        if (s.lastAssertionIsQuantifiable = !1, s.eat(94) || s.eat(36)) return !0;
                                        if (s.eat(92)) {
                                            if (s.eat(66) || s.eat(98)) return !0;
                                            s.pos = f;
                                        }
                                        if (s.eat(40) && s.eat(63)) {
                                            var S = !1;
                                            if (this.options.ecmaVersion >= 9 && (S = s.eat(60)), s.eat(61) || s.eat(33)) return this.regexp_disjunction(s), s.eat(41) || s.raise("Unterminated group"), s.lastAssertionIsQuantifiable = !S, !0;
                                        }
                                        return s.pos = f, !1;
                                    }, Q.regexp_eatQuantifier = function(s, f) {
                                        return f === void 0 && (f = !1), this.regexp_eatQuantifierPrefix(s, f) ? (s.eat(63), !0) : !1;
                                    }, Q.regexp_eatQuantifierPrefix = function(s, f) {
                                        return s.eat(42) || s.eat(43) || s.eat(63) || this.regexp_eatBracedQuantifier(s, f);
                                    }, Q.regexp_eatBracedQuantifier = function(s, f) {
                                        var S = s.pos;
                                        if (s.eat(123)) {
                                            var L = 0, D = -1;
                                            if (this.regexp_eatDecimalDigits(s) && (L = s.lastIntValue, s.eat(44) && this.regexp_eatDecimalDigits(s) && (D = s.lastIntValue), s.eat(125))) return D !== -1 && D < L && !f && s.raise("numbers out of order in {} quantifier"), !0;
                                            s.switchU && !f && s.raise("Incomplete quantifier"), s.pos = S;
                                        }
                                        return !1;
                                    }, Q.regexp_eatAtom = function(s) {
                                        return this.regexp_eatPatternCharacters(s) || s.eat(46) || this.regexp_eatReverseSolidusAtomEscape(s) || this.regexp_eatCharacterClass(s) || this.regexp_eatUncapturingGroup(s) || this.regexp_eatCapturingGroup(s);
                                    }, Q.regexp_eatReverseSolidusAtomEscape = function(s) {
                                        var f = s.pos;
                                        if (s.eat(92)) {
                                            if (this.regexp_eatAtomEscape(s)) return !0;
                                            s.pos = f;
                                        }
                                        return !1;
                                    }, Q.regexp_eatUncapturingGroup = function(s) {
                                        var f = s.pos;
                                        if (s.eat(40)) {
                                            if (s.eat(63) && s.eat(58)) {
                                                if (this.regexp_disjunction(s), s.eat(41)) return !0;
                                                s.raise("Unterminated group");
                                            }
                                            s.pos = f;
                                        }
                                        return !1;
                                    }, Q.regexp_eatCapturingGroup = function(s) {
                                        if (s.eat(40)) {
                                            if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(s) : s.current() === 63 && s.raise("Invalid group"), this.regexp_disjunction(s), s.eat(41)) return s.numCapturingParens += 1, !0;
                                            s.raise("Unterminated group");
                                        }
                                        return !1;
                                    }, Q.regexp_eatExtendedAtom = function(s) {
                                        return s.eat(46) || this.regexp_eatReverseSolidusAtomEscape(s) || this.regexp_eatCharacterClass(s) || this.regexp_eatUncapturingGroup(s) || this.regexp_eatCapturingGroup(s) || this.regexp_eatInvalidBracedQuantifier(s) || this.regexp_eatExtendedPatternCharacter(s);
                                    }, Q.regexp_eatInvalidBracedQuantifier = function(s) {
                                        return this.regexp_eatBracedQuantifier(s, !0) && s.raise("Nothing to repeat"), !1;
                                    }, Q.regexp_eatSyntaxCharacter = function(s) {
                                        var f = s.current();
                                        return qs(f) ? (s.lastIntValue = f, s.advance(), !0) : !1;
                                    };
                                    function qs(s) {
                                        return s === 36 || s >= 40 && s <= 43 || s === 46 || s === 63 || s >= 91 && s <= 94 || s >= 123 && s <= 125;
                                    }
                                    Q.regexp_eatPatternCharacters = function(s) {
                                        for(var f = s.pos, S = 0; (S = s.current()) !== -1 && !qs(S);)s.advance();
                                        return s.pos !== f;
                                    }, Q.regexp_eatExtendedPatternCharacter = function(s) {
                                        var f = s.current();
                                        return f !== -1 && f !== 36 && !(f >= 40 && f <= 43) && f !== 46 && f !== 63 && f !== 91 && f !== 94 && f !== 124 ? (s.advance(), !0) : !1;
                                    }, Q.regexp_groupSpecifier = function(s) {
                                        if (s.eat(63)) {
                                            if (this.regexp_eatGroupName(s)) {
                                                s.groupNames.indexOf(s.lastStringValue) !== -1 && s.raise("Duplicate capture group name"), s.groupNames.push(s.lastStringValue);
                                                return;
                                            }
                                            s.raise("Invalid group");
                                        }
                                    }, Q.regexp_eatGroupName = function(s) {
                                        if (s.lastStringValue = "", s.eat(60)) {
                                            if (this.regexp_eatRegExpIdentifierName(s) && s.eat(62)) return !0;
                                            s.raise("Invalid capture group name");
                                        }
                                        return !1;
                                    }, Q.regexp_eatRegExpIdentifierName = function(s) {
                                        if (s.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(s)) {
                                            for(s.lastStringValue += ii(s.lastIntValue); this.regexp_eatRegExpIdentifierPart(s);)s.lastStringValue += ii(s.lastIntValue);
                                            return !0;
                                        }
                                        return !1;
                                    }, Q.regexp_eatRegExpIdentifierStart = function(s) {
                                        var f = s.pos, S = s.current();
                                        return s.advance(), S === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(s) && (S = s.lastIntValue), Ya(S) ? (s.lastIntValue = S, !0) : (s.pos = f, !1);
                                    };
                                    function Ya(s) {
                                        return v(s, !0) || s === 36 || s === 95;
                                    }
                                    Q.regexp_eatRegExpIdentifierPart = function(s) {
                                        var f = s.pos, S = s.current();
                                        return s.advance(), S === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(s) && (S = s.lastIntValue), Ja(S) ? (s.lastIntValue = S, !0) : (s.pos = f, !1);
                                    };
                                    function Ja(s) {
                                        return y(s, !0) || s === 36 || s === 95 || s === 8204 || s === 8205;
                                    }
                                    Q.regexp_eatAtomEscape = function(s) {
                                        return this.regexp_eatBackReference(s) || this.regexp_eatCharacterClassEscape(s) || this.regexp_eatCharacterEscape(s) || s.switchN && this.regexp_eatKGroupName(s) ? !0 : (s.switchU && (s.current() === 99 && s.raise("Invalid unicode escape"), s.raise("Invalid escape")), !1);
                                    }, Q.regexp_eatBackReference = function(s) {
                                        var f = s.pos;
                                        if (this.regexp_eatDecimalEscape(s)) {
                                            var S = s.lastIntValue;
                                            if (s.switchU) return S > s.maxBackReference && (s.maxBackReference = S), !0;
                                            if (S <= s.numCapturingParens) return !0;
                                            s.pos = f;
                                        }
                                        return !1;
                                    }, Q.regexp_eatKGroupName = function(s) {
                                        if (s.eat(107)) {
                                            if (this.regexp_eatGroupName(s)) return s.backReferenceNames.push(s.lastStringValue), !0;
                                            s.raise("Invalid named reference");
                                        }
                                        return !1;
                                    }, Q.regexp_eatCharacterEscape = function(s) {
                                        return this.regexp_eatControlEscape(s) || this.regexp_eatCControlLetter(s) || this.regexp_eatZero(s) || this.regexp_eatHexEscapeSequence(s) || this.regexp_eatRegExpUnicodeEscapeSequence(s) || !s.switchU && this.regexp_eatLegacyOctalEscapeSequence(s) || this.regexp_eatIdentityEscape(s);
                                    }, Q.regexp_eatCControlLetter = function(s) {
                                        var f = s.pos;
                                        if (s.eat(99)) {
                                            if (this.regexp_eatControlLetter(s)) return !0;
                                            s.pos = f;
                                        }
                                        return !1;
                                    }, Q.regexp_eatZero = function(s) {
                                        return s.current() === 48 && !si(s.lookahead()) ? (s.lastIntValue = 0, s.advance(), !0) : !1;
                                    }, Q.regexp_eatControlEscape = function(s) {
                                        var f = s.current();
                                        return f === 116 ? (s.lastIntValue = 9, s.advance(), !0) : f === 110 ? (s.lastIntValue = 10, s.advance(), !0) : f === 118 ? (s.lastIntValue = 11, s.advance(), !0) : f === 102 ? (s.lastIntValue = 12, s.advance(), !0) : f === 114 ? (s.lastIntValue = 13, s.advance(), !0) : !1;
                                    }, Q.regexp_eatControlLetter = function(s) {
                                        var f = s.current();
                                        return Qs(f) ? (s.lastIntValue = f % 32, s.advance(), !0) : !1;
                                    };
                                    function Qs(s) {
                                        return s >= 65 && s <= 90 || s >= 97 && s <= 122;
                                    }
                                    Q.regexp_eatRegExpUnicodeEscapeSequence = function(s) {
                                        var f = s.pos;
                                        if (s.eat(117)) {
                                            if (this.regexp_eatFixedHexDigits(s, 4)) {
                                                var S = s.lastIntValue;
                                                if (s.switchU && S >= 55296 && S <= 56319) {
                                                    var L = s.pos;
                                                    if (s.eat(92) && s.eat(117) && this.regexp_eatFixedHexDigits(s, 4)) {
                                                        var D = s.lastIntValue;
                                                        if (D >= 56320 && D <= 57343) return s.lastIntValue = (S - 55296) * 1024 + (D - 56320) + 65536, !0;
                                                    }
                                                    s.pos = L, s.lastIntValue = S;
                                                }
                                                return !0;
                                            }
                                            if (s.switchU && s.eat(123) && this.regexp_eatHexDigits(s) && s.eat(125) && Za(s.lastIntValue)) return !0;
                                            s.switchU && s.raise("Invalid unicode escape"), s.pos = f;
                                        }
                                        return !1;
                                    };
                                    function Za(s) {
                                        return s >= 0 && s <= 1114111;
                                    }
                                    Q.regexp_eatIdentityEscape = function(s) {
                                        if (s.switchU) return this.regexp_eatSyntaxCharacter(s) ? !0 : s.eat(47) ? (s.lastIntValue = 47, !0) : !1;
                                        var f = s.current();
                                        return f !== 99 && (!s.switchN || f !== 107) ? (s.lastIntValue = f, s.advance(), !0) : !1;
                                    }, Q.regexp_eatDecimalEscape = function(s) {
                                        s.lastIntValue = 0;
                                        var f = s.current();
                                        if (f >= 49 && f <= 57) {
                                            do s.lastIntValue = 10 * s.lastIntValue + (f - 48), s.advance();
                                            while ((f = s.current()) >= 48 && f <= 57);
                                            return !0;
                                        }
                                        return !1;
                                    }, Q.regexp_eatCharacterClassEscape = function(s) {
                                        var f = s.current();
                                        if (qa(f)) return s.lastIntValue = -1, s.advance(), !0;
                                        if (s.switchU && this.options.ecmaVersion >= 9 && (f === 80 || f === 112)) {
                                            if (s.lastIntValue = -1, s.advance(), s.eat(123) && this.regexp_eatUnicodePropertyValueExpression(s) && s.eat(125)) return !0;
                                            s.raise("Invalid property name");
                                        }
                                        return !1;
                                    };
                                    function qa(s) {
                                        return s === 100 || s === 68 || s === 115 || s === 83 || s === 119 || s === 87;
                                    }
                                    Q.regexp_eatUnicodePropertyValueExpression = function(s) {
                                        var f = s.pos;
                                        if (this.regexp_eatUnicodePropertyName(s) && s.eat(61)) {
                                            var S = s.lastStringValue;
                                            if (this.regexp_eatUnicodePropertyValue(s)) {
                                                var L = s.lastStringValue;
                                                return this.regexp_validateUnicodePropertyNameAndValue(s, S, L), !0;
                                            }
                                        }
                                        if (s.pos = f, this.regexp_eatLoneUnicodePropertyNameOrValue(s)) {
                                            var D = s.lastStringValue;
                                            return this.regexp_validateUnicodePropertyNameOrValue(s, D), !0;
                                        }
                                        return !1;
                                    }, Q.regexp_validateUnicodePropertyNameAndValue = function(s, f, S) {
                                        q(s.unicodeProperties.nonBinary, f) || s.raise("Invalid property name"), s.unicodeProperties.nonBinary[f].test(S) || s.raise("Invalid property value");
                                    }, Q.regexp_validateUnicodePropertyNameOrValue = function(s, f) {
                                        s.unicodeProperties.binary.test(f) || s.raise("Invalid property name");
                                    }, Q.regexp_eatUnicodePropertyName = function(s) {
                                        var f = 0;
                                        for(s.lastStringValue = ""; tn(f = s.current());)s.lastStringValue += ii(f), s.advance();
                                        return s.lastStringValue !== "";
                                    };
                                    function tn(s) {
                                        return Qs(s) || s === 95;
                                    }
                                    Q.regexp_eatUnicodePropertyValue = function(s) {
                                        var f = 0;
                                        for(s.lastStringValue = ""; Qa(f = s.current());)s.lastStringValue += ii(f), s.advance();
                                        return s.lastStringValue !== "";
                                    };
                                    function Qa(s) {
                                        return tn(s) || si(s);
                                    }
                                    Q.regexp_eatLoneUnicodePropertyNameOrValue = function(s) {
                                        return this.regexp_eatUnicodePropertyValue(s);
                                    }, Q.regexp_eatCharacterClass = function(s) {
                                        if (s.eat(91)) {
                                            if (s.eat(94), this.regexp_classRanges(s), s.eat(93)) return !0;
                                            s.raise("Unterminated character class");
                                        }
                                        return !1;
                                    }, Q.regexp_classRanges = function(s) {
                                        for(; this.regexp_eatClassAtom(s);){
                                            var f = s.lastIntValue;
                                            if (s.eat(45) && this.regexp_eatClassAtom(s)) {
                                                var S = s.lastIntValue;
                                                s.switchU && (f === -1 || S === -1) && s.raise("Invalid character class"), f !== -1 && S !== -1 && f > S && s.raise("Range out of order in character class");
                                            }
                                        }
                                    }, Q.regexp_eatClassAtom = function(s) {
                                        var f = s.pos;
                                        if (s.eat(92)) {
                                            if (this.regexp_eatClassEscape(s)) return !0;
                                            if (s.switchU) {
                                                var S = s.current();
                                                (S === 99 || nn(S)) && s.raise("Invalid class escape"), s.raise("Invalid escape");
                                            }
                                            s.pos = f;
                                        }
                                        var L = s.current();
                                        return L !== 93 ? (s.lastIntValue = L, s.advance(), !0) : !1;
                                    }, Q.regexp_eatClassEscape = function(s) {
                                        var f = s.pos;
                                        if (s.eat(98)) return s.lastIntValue = 8, !0;
                                        if (s.switchU && s.eat(45)) return s.lastIntValue = 45, !0;
                                        if (!s.switchU && s.eat(99)) {
                                            if (this.regexp_eatClassControlLetter(s)) return !0;
                                            s.pos = f;
                                        }
                                        return this.regexp_eatCharacterClassEscape(s) || this.regexp_eatCharacterEscape(s);
                                    }, Q.regexp_eatClassControlLetter = function(s) {
                                        var f = s.current();
                                        return si(f) || f === 95 ? (s.lastIntValue = f % 32, s.advance(), !0) : !1;
                                    }, Q.regexp_eatHexEscapeSequence = function(s) {
                                        var f = s.pos;
                                        if (s.eat(120)) {
                                            if (this.regexp_eatFixedHexDigits(s, 2)) return !0;
                                            s.switchU && s.raise("Invalid escape"), s.pos = f;
                                        }
                                        return !1;
                                    }, Q.regexp_eatDecimalDigits = function(s) {
                                        var f = s.pos, S = 0;
                                        for(s.lastIntValue = 0; si(S = s.current());)s.lastIntValue = 10 * s.lastIntValue + (S - 48), s.advance();
                                        return s.pos !== f;
                                    };
                                    function si(s) {
                                        return s >= 48 && s <= 57;
                                    }
                                    Q.regexp_eatHexDigits = function(s) {
                                        var f = s.pos, S = 0;
                                        for(s.lastIntValue = 0; en(S = s.current());)s.lastIntValue = 16 * s.lastIntValue + sn(S), s.advance();
                                        return s.pos !== f;
                                    };
                                    function en(s) {
                                        return s >= 48 && s <= 57 || s >= 65 && s <= 70 || s >= 97 && s <= 102;
                                    }
                                    function sn(s) {
                                        return s >= 65 && s <= 70 ? 10 + (s - 65) : s >= 97 && s <= 102 ? 10 + (s - 97) : s - 48;
                                    }
                                    Q.regexp_eatLegacyOctalEscapeSequence = function(s) {
                                        if (this.regexp_eatOctalDigit(s)) {
                                            var f = s.lastIntValue;
                                            if (this.regexp_eatOctalDigit(s)) {
                                                var S = s.lastIntValue;
                                                f <= 3 && this.regexp_eatOctalDigit(s) ? s.lastIntValue = f * 64 + S * 8 + s.lastIntValue : s.lastIntValue = f * 8 + S;
                                            } else s.lastIntValue = f;
                                            return !0;
                                        }
                                        return !1;
                                    }, Q.regexp_eatOctalDigit = function(s) {
                                        var f = s.current();
                                        return nn(f) ? (s.lastIntValue = f - 48, s.advance(), !0) : (s.lastIntValue = 0, !1);
                                    };
                                    function nn(s) {
                                        return s >= 48 && s <= 55;
                                    }
                                    Q.regexp_eatFixedHexDigits = function(s, f) {
                                        var S = s.pos;
                                        s.lastIntValue = 0;
                                        for(var L = 0; L < f; ++L){
                                            var D = s.current();
                                            if (!en(D)) return s.pos = S, !1;
                                            s.lastIntValue = 16 * s.lastIntValue + sn(D), s.advance();
                                        }
                                        return !0;
                                    };
                                    var ni = function(f) {
                                        this.type = f.type, this.value = f.value, this.start = f.start, this.end = f.end, f.options.locations && (this.loc = new mt(f, f.startLoc, f.endLoc)), f.options.ranges && (this.range = [
                                            f.start,
                                            f.end
                                        ]);
                                    }, St = Ct.prototype;
                                    St.next = function(s) {
                                        !s && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new ni(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
                                    }, St.getToken = function() {
                                        return this.next(), new ni(this);
                                    }, typeof Symbol < "u" && (St[Symbol.iterator] = function() {
                                        var s = this;
                                        return {
                                            next: function() {
                                                var f = s.getToken();
                                                return {
                                                    done: f.type === g.eof,
                                                    value: f
                                                };
                                            }
                                        };
                                    }), St.curContext = function() {
                                        return this.context[this.context.length - 1];
                                    }, St.nextToken = function() {
                                        var s = this.curContext();
                                        if ((!s || !s.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length) return this.finishToken(g.eof);
                                        if (s.override) return s.override(this);
                                        this.readToken(this.fullCharCodeAtPos());
                                    }, St.readToken = function(s) {
                                        return v(s, this.options.ecmaVersion >= 6) || s === 92 ? this.readWord() : this.getTokenFromCode(s);
                                    }, St.fullCharCodeAtPos = function() {
                                        var s = this.input.charCodeAt(this.pos);
                                        if (s <= 55295 || s >= 57344) return s;
                                        var f = this.input.charCodeAt(this.pos + 1);
                                        return (s << 10) + f - 56613888;
                                    }, St.skipBlockComment = function() {
                                        var s = this.options.onComment && this.curPosition(), f = this.pos, S = this.input.indexOf("*/", this.pos += 2);
                                        if (S === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = S + 2, this.options.locations) {
                                            A.lastIndex = f;
                                            for(var L; (L = A.exec(this.input)) && L.index < this.pos;)++this.curLine, this.lineStart = L.index + L[0].length;
                                        }
                                        this.options.onComment && this.options.onComment(!0, this.input.slice(f + 2, S), f, this.pos, s, this.curPosition());
                                    }, St.skipLineComment = function(s) {
                                        for(var f = this.pos, S = this.options.onComment && this.curPosition(), L = this.input.charCodeAt(this.pos += s); this.pos < this.input.length && !P(L);)L = this.input.charCodeAt(++this.pos);
                                        this.options.onComment && this.options.onComment(!1, this.input.slice(f + s, this.pos), f, this.pos, S, this.curPosition());
                                    }, St.skipSpace = function() {
                                        t: for(; this.pos < this.input.length;){
                                            var s = this.input.charCodeAt(this.pos);
                                            switch(s){
                                                case 32:
                                                case 160:
                                                    ++this.pos;
                                                    break;
                                                case 13:
                                                    this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
                                                case 10:
                                                case 8232:
                                                case 8233:
                                                    ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
                                                    break;
                                                case 47:
                                                    switch(this.input.charCodeAt(this.pos + 1)){
                                                        case 42:
                                                            this.skipBlockComment();
                                                            break;
                                                        case 47:
                                                            this.skipLineComment(2);
                                                            break;
                                                        default:
                                                            break t;
                                                    }
                                                    break;
                                                default:
                                                    if (s > 8 && s < 14 || s >= 5760 && O.test(String.fromCharCode(s))) ++this.pos;
                                                    else break t;
                                            }
                                        }
                                    }, St.finishToken = function(s, f) {
                                        this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
                                        var S = this.type;
                                        this.type = s, this.value = f, this.updateContext(S);
                                    }, St.readToken_dot = function() {
                                        var s = this.input.charCodeAt(this.pos + 1);
                                        if (s >= 48 && s <= 57) return this.readNumber(!0);
                                        var f = this.input.charCodeAt(this.pos + 2);
                                        return this.options.ecmaVersion >= 6 && s === 46 && f === 46 ? (this.pos += 3, this.finishToken(g.ellipsis)) : (++this.pos, this.finishToken(g.dot));
                                    }, St.readToken_slash = function() {
                                        var s = this.input.charCodeAt(this.pos + 1);
                                        return this.exprAllowed ? (++this.pos, this.readRegexp()) : s === 61 ? this.finishOp(g.assign, 2) : this.finishOp(g.slash, 1);
                                    }, St.readToken_mult_modulo_exp = function(s) {
                                        var f = this.input.charCodeAt(this.pos + 1), S = 1, L = s === 42 ? g.star : g.modulo;
                                        return this.options.ecmaVersion >= 7 && s === 42 && f === 42 && (++S, L = g.starstar, f = this.input.charCodeAt(this.pos + 2)), f === 61 ? this.finishOp(g.assign, S + 1) : this.finishOp(L, S);
                                    }, St.readToken_pipe_amp = function(s) {
                                        var f = this.input.charCodeAt(this.pos + 1);
                                        return f === s ? this.finishOp(s === 124 ? g.logicalOR : g.logicalAND, 2) : f === 61 ? this.finishOp(g.assign, 2) : this.finishOp(s === 124 ? g.bitwiseOR : g.bitwiseAND, 1);
                                    }, St.readToken_caret = function() {
                                        var s = this.input.charCodeAt(this.pos + 1);
                                        return s === 61 ? this.finishOp(g.assign, 2) : this.finishOp(g.bitwiseXOR, 1);
                                    }, St.readToken_plus_min = function(s) {
                                        var f = this.input.charCodeAt(this.pos + 1);
                                        return f === s ? f === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || I.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(g.incDec, 2) : f === 61 ? this.finishOp(g.assign, 2) : this.finishOp(g.plusMin, 1);
                                    }, St.readToken_lt_gt = function(s) {
                                        var f = this.input.charCodeAt(this.pos + 1), S = 1;
                                        return f === s ? (S = s === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + S) === 61 ? this.finishOp(g.assign, S + 1) : this.finishOp(g.bitShift, S)) : f === 33 && s === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (f === 61 && (S = 2), this.finishOp(g.relational, S));
                                    }, St.readToken_eq_excl = function(s) {
                                        var f = this.input.charCodeAt(this.pos + 1);
                                        return f === 61 ? this.finishOp(g.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : s === 61 && f === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(g.arrow)) : this.finishOp(s === 61 ? g.eq : g.prefix, 1);
                                    }, St.getTokenFromCode = function(s) {
                                        switch(s){
                                            case 46:
                                                return this.readToken_dot();
                                            case 40:
                                                return ++this.pos, this.finishToken(g.parenL);
                                            case 41:
                                                return ++this.pos, this.finishToken(g.parenR);
                                            case 59:
                                                return ++this.pos, this.finishToken(g.semi);
                                            case 44:
                                                return ++this.pos, this.finishToken(g.comma);
                                            case 91:
                                                return ++this.pos, this.finishToken(g.bracketL);
                                            case 93:
                                                return ++this.pos, this.finishToken(g.bracketR);
                                            case 123:
                                                return ++this.pos, this.finishToken(g.braceL);
                                            case 125:
                                                return ++this.pos, this.finishToken(g.braceR);
                                            case 58:
                                                return ++this.pos, this.finishToken(g.colon);
                                            case 63:
                                                return ++this.pos, this.finishToken(g.question);
                                            case 96:
                                                if (this.options.ecmaVersion < 6) break;
                                                return ++this.pos, this.finishToken(g.backQuote);
                                            case 48:
                                                var f = this.input.charCodeAt(this.pos + 1);
                                                if (f === 120 || f === 88) return this.readRadixNumber(16);
                                                if (this.options.ecmaVersion >= 6) {
                                                    if (f === 111 || f === 79) return this.readRadixNumber(8);
                                                    if (f === 98 || f === 66) return this.readRadixNumber(2);
                                                }
                                            case 49:
                                            case 50:
                                            case 51:
                                            case 52:
                                            case 53:
                                            case 54:
                                            case 55:
                                            case 56:
                                            case 57:
                                                return this.readNumber(!1);
                                            case 34:
                                            case 39:
                                                return this.readString(s);
                                            case 47:
                                                return this.readToken_slash();
                                            case 37:
                                            case 42:
                                                return this.readToken_mult_modulo_exp(s);
                                            case 124:
                                            case 38:
                                                return this.readToken_pipe_amp(s);
                                            case 94:
                                                return this.readToken_caret();
                                            case 43:
                                            case 45:
                                                return this.readToken_plus_min(s);
                                            case 60:
                                            case 62:
                                                return this.readToken_lt_gt(s);
                                            case 61:
                                            case 33:
                                                return this.readToken_eq_excl(s);
                                            case 126:
                                                return this.finishOp(g.prefix, 1);
                                        }
                                        this.raise(this.pos, "Unexpected character '" + ki(s) + "'");
                                    }, St.finishOp = function(s, f) {
                                        var S = this.input.slice(this.pos, this.pos + f);
                                        return this.pos += f, this.finishToken(s, S);
                                    }, St.readRegexp = function() {
                                        for(var s, f, S = this.pos;;){
                                            this.pos >= this.input.length && this.raise(S, "Unterminated regular expression");
                                            var L = this.input.charAt(this.pos);
                                            if (I.test(L) && this.raise(S, "Unterminated regular expression"), s) s = !1;
                                            else {
                                                if (L === "[") f = !0;
                                                else if (L === "]" && f) f = !1;
                                                else if (L === "/" && !f) break;
                                                s = L === "\\";
                                            }
                                            ++this.pos;
                                        }
                                        var D = this.input.slice(S, this.pos);
                                        ++this.pos;
                                        var F = this.pos, K = this.readWord1();
                                        this.containsEsc && this.unexpected(F);
                                        var W = this.regexpState || (this.regexpState = new re(this));
                                        W.reset(S, D, K), this.validateRegExpFlags(W), this.validateRegExpPattern(W);
                                        var nt = null;
                                        try {
                                            nt = new RegExp(D, K);
                                        } catch  {}
                                        return this.finishToken(g.regexp, {
                                            pattern: D,
                                            flags: K,
                                            value: nt
                                        });
                                    }, St.readInt = function(s, f) {
                                        for(var S = this.pos, L = 0, D = 0, F = f ?? 1 / 0; D < F; ++D){
                                            var K = this.input.charCodeAt(this.pos), W = void 0;
                                            if (K >= 97 ? W = K - 97 + 10 : K >= 65 ? W = K - 65 + 10 : K >= 48 && K <= 57 ? W = K - 48 : W = 1 / 0, W >= s) break;
                                            ++this.pos, L = L * s + W;
                                        }
                                        return this.pos === S || f != null && this.pos - S !== f ? null : L;
                                    }, St.readRadixNumber = function(s) {
                                        var f = this.pos;
                                        this.pos += 2;
                                        var S = this.readInt(s);
                                        return S == null && this.raise(this.start + 2, "Expected number in radix " + s), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (S = typeof BigInt < "u" ? BigInt(this.input.slice(f, this.pos)) : null, ++this.pos) : v(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(g.num, S);
                                    }, St.readNumber = function(s) {
                                        var f = this.pos;
                                        !s && this.readInt(10) === null && this.raise(f, "Invalid number");
                                        var S = this.pos - f >= 2 && this.input.charCodeAt(f) === 48;
                                        S && this.strict && this.raise(f, "Invalid number");
                                        var L = this.input.charCodeAt(this.pos);
                                        if (!S && !s && this.options.ecmaVersion >= 11 && L === 110) {
                                            var D = this.input.slice(f, this.pos), F = typeof BigInt < "u" ? BigInt(D) : null;
                                            return ++this.pos, v(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(g.num, F);
                                        }
                                        S && /[89]/.test(this.input.slice(f, this.pos)) && (S = !1), L === 46 && !S && (++this.pos, this.readInt(10), L = this.input.charCodeAt(this.pos)), (L === 69 || L === 101) && !S && (L = this.input.charCodeAt(++this.pos), (L === 43 || L === 45) && ++this.pos, this.readInt(10) === null && this.raise(f, "Invalid number")), v(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
                                        var K = this.input.slice(f, this.pos), W = S ? parseInt(K, 8) : parseFloat(K);
                                        return this.finishToken(g.num, W);
                                    }, St.readCodePoint = function() {
                                        var s = this.input.charCodeAt(this.pos), f;
                                        if (s === 123) {
                                            this.options.ecmaVersion < 6 && this.unexpected();
                                            var S = ++this.pos;
                                            f = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, f > 1114111 && this.invalidStringToken(S, "Code point out of bounds");
                                        } else f = this.readHexChar(4);
                                        return f;
                                    };
                                    function ki(s) {
                                        return s <= 65535 ? String.fromCharCode(s) : (s -= 65536, String.fromCharCode((s >> 10) + 55296, (s & 1023) + 56320));
                                    }
                                    St.readString = function(s) {
                                        for(var f = "", S = ++this.pos;;){
                                            this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
                                            var L = this.input.charCodeAt(this.pos);
                                            if (L === s) break;
                                            L === 92 ? (f += this.input.slice(S, this.pos), f += this.readEscapedChar(!1), S = this.pos) : (P(L, this.options.ecmaVersion >= 10) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
                                        }
                                        return f += this.input.slice(S, this.pos++), this.finishToken(g.string, f);
                                    };
                                    var rn = {};
                                    St.tryReadTemplateToken = function() {
                                        this.inTemplateElement = !0;
                                        try {
                                            this.readTmplToken();
                                        } catch (s) {
                                            if (s === rn) this.readInvalidTemplateToken();
                                            else throw s;
                                        }
                                        this.inTemplateElement = !1;
                                    }, St.invalidStringToken = function(s, f) {
                                        if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw rn;
                                        this.raise(s, f);
                                    }, St.readTmplToken = function() {
                                        for(var s = "", f = this.pos;;){
                                            this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
                                            var S = this.input.charCodeAt(this.pos);
                                            if (S === 96 || S === 36 && this.input.charCodeAt(this.pos + 1) === 123) return this.pos === this.start && (this.type === g.template || this.type === g.invalidTemplate) ? S === 36 ? (this.pos += 2, this.finishToken(g.dollarBraceL)) : (++this.pos, this.finishToken(g.backQuote)) : (s += this.input.slice(f, this.pos), this.finishToken(g.template, s));
                                            if (S === 92) s += this.input.slice(f, this.pos), s += this.readEscapedChar(!0), f = this.pos;
                                            else if (P(S)) {
                                                switch(s += this.input.slice(f, this.pos), ++this.pos, S){
                                                    case 13:
                                                        this.input.charCodeAt(this.pos) === 10 && ++this.pos;
                                                    case 10:
                                                        s += `
`;
                                                        break;
                                                    default:
                                                        s += String.fromCharCode(S);
                                                        break;
                                                }
                                                this.options.locations && (++this.curLine, this.lineStart = this.pos), f = this.pos;
                                            } else ++this.pos;
                                        }
                                    }, St.readInvalidTemplateToken = function() {
                                        for(; this.pos < this.input.length; this.pos++)switch(this.input[this.pos]){
                                            case "\\":
                                                ++this.pos;
                                                break;
                                            case "$":
                                                if (this.input[this.pos + 1] !== "{") break;
                                            case "`":
                                                return this.finishToken(g.invalidTemplate, this.input.slice(this.start, this.pos));
                                        }
                                        this.raise(this.start, "Unterminated template");
                                    }, St.readEscapedChar = function(s) {
                                        var f = this.input.charCodeAt(++this.pos);
                                        switch(++this.pos, f){
                                            case 110:
                                                return `
`;
                                            case 114:
                                                return "\r";
                                            case 120:
                                                return String.fromCharCode(this.readHexChar(2));
                                            case 117:
                                                return ki(this.readCodePoint());
                                            case 116:
                                                return "	";
                                            case 98:
                                                return "\b";
                                            case 118:
                                                return "\v";
                                            case 102:
                                                return "\f";
                                            case 13:
                                                this.input.charCodeAt(this.pos) === 10 && ++this.pos;
                                            case 10:
                                                return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
                                            case 56:
                                            case 57:
                                                if (s) {
                                                    var S = this.pos - 1;
                                                    return this.invalidStringToken(S, "Invalid escape sequence in template string"), null;
                                                }
                                            default:
                                                if (f >= 48 && f <= 55) {
                                                    var L = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], D = parseInt(L, 8);
                                                    return D > 255 && (L = L.slice(0, -1), D = parseInt(L, 8)), this.pos += L.length - 1, f = this.input.charCodeAt(this.pos), (L !== "0" || f === 56 || f === 57) && (this.strict || s) && this.invalidStringToken(this.pos - 1 - L.length, s ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(D);
                                                }
                                                return P(f) ? "" : String.fromCharCode(f);
                                        }
                                    }, St.readHexChar = function(s) {
                                        var f = this.pos, S = this.readInt(16, s);
                                        return S === null && this.invalidStringToken(f, "Bad character escape sequence"), S;
                                    }, St.readWord1 = function() {
                                        this.containsEsc = !1;
                                        for(var s = "", f = !0, S = this.pos, L = this.options.ecmaVersion >= 6; this.pos < this.input.length;){
                                            var D = this.fullCharCodeAtPos();
                                            if (y(D, L)) this.pos += D <= 65535 ? 1 : 2;
                                            else if (D === 92) {
                                                this.containsEsc = !0, s += this.input.slice(S, this.pos);
                                                var F = this.pos;
                                                this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
                                                var K = this.readCodePoint();
                                                (f ? v : y)(K, L) || this.invalidStringToken(F, "Invalid Unicode escape"), s += ki(K), S = this.pos;
                                            } else break;
                                            f = !1;
                                        }
                                        return s + this.input.slice(S, this.pos);
                                    }, St.readWord = function() {
                                        var s = this.readWord1(), f = g.name;
                                        return this.keywords.test(s) && (f = M[s]), this.finishToken(f, s);
                                    };
                                    var an = "7.1.0";
                                    Ct.acorn = {
                                        Parser: Ct,
                                        version: an,
                                        defaultOptions: et,
                                        Position: rt,
                                        SourceLocation: mt,
                                        getLineInfo: tt,
                                        Node: Qe,
                                        TokenType: T,
                                        tokTypes: g,
                                        keywordTypes: M,
                                        TokContext: Yt,
                                        tokContexts: Ft,
                                        isIdentifierChar: y,
                                        isIdentifierStart: v,
                                        Token: ni,
                                        isNewLine: P,
                                        lineBreak: I,
                                        lineBreakG: A,
                                        nonASCIIwhitespace: O
                                    };
                                    function to(s, f) {
                                        return Ct.parse(s, f);
                                    }
                                    function eo(s, f, S) {
                                        return Ct.parseExpressionAt(s, f, S);
                                    }
                                    function io(s, f) {
                                        return Ct.tokenizer(s, f);
                                    }
                                    u.Node = Qe, u.Parser = Ct, u.Position = rt, u.SourceLocation = mt, u.TokContext = Yt, u.Token = ni, u.TokenType = T, u.defaultOptions = et, u.getLineInfo = tt, u.isIdentifierChar = y, u.isIdentifierStart = v, u.isNewLine = P, u.keywordTypes = M, u.lineBreak = I, u.lineBreakG = A, u.nonASCIIwhitespace = O, u.parse = to, u.parseExpressionAt = eo, u.tokContexts = Ft, u.tokTypes = g, u.tokenizer = io, u.version = an, Object.defineProperty(u, "__esModule", {
                                        value: !0
                                    });
                                });
                            },
                            {}
                        ],
                        2: [
                            function(e, i, h) {},
                            {}
                        ],
                        3: [
                            function(e, i, h) {
                                function u(o, n = {}) {
                                    const { contextName: r = "gl", throwGetError: m, useTrackablePrimitives: b, readPixelsFile: E, recording: w = [], variables: v = {}, onReadPixels: y, onUnrecognizedArgumentLookup: T } = n, _ = new Proxy(o, {
                                        get: I
                                    }), k = [], C = {};
                                    let M = 0, x = "", g;
                                    return _;
                                    function I(tt, et) {
                                        switch(et){
                                            case "addComment":
                                                return q;
                                            case "checkThrowError":
                                                return B;
                                            case "getReadPixelsVariableName":
                                                return g;
                                            case "insertVariable":
                                                return O;
                                            case "reset":
                                                return P;
                                            case "setIndent":
                                                return G;
                                            case "toString":
                                                return A;
                                            case "getContextVariableName":
                                                return mt;
                                        }
                                        return typeof o[et] == "function" ? function() {
                                            switch(et){
                                                case "getError":
                                                    return m ? w.push(`${x}if (${r}.getError() !== ${r}.NONE) throw new Error('error');`) : w.push(`${x}${r}.getError();`), o.getError();
                                                case "getExtension":
                                                    {
                                                        const _t = `${r}Variables${k.length}`;
                                                        w.push(`${x}const ${_t} = ${r}.getExtension('${arguments[0]}');`);
                                                        const Dt = o.getExtension(arguments[0]);
                                                        if (Dt && typeof Dt == "object") {
                                                            const Ut = p(Dt, {
                                                                getEntity: R,
                                                                useTrackablePrimitives: b,
                                                                recording: w,
                                                                contextName: _t,
                                                                contextVariables: k,
                                                                variables: v,
                                                                indent: x,
                                                                onUnrecognizedArgumentLookup: T
                                                            });
                                                            return k.push(Ut), Ut;
                                                        } else k.push(null);
                                                        return Dt;
                                                    }
                                                case "readPixels":
                                                    const yt = k.indexOf(arguments[6]);
                                                    let Pt;
                                                    if (yt === -1) {
                                                        const _t = rt(arguments[6]);
                                                        _t ? (Pt = _t, w.push(`${x}${_t}`)) : (Pt = `${r}Variable${k.length}`, k.push(arguments[6]), w.push(`${x}const ${Pt} = new ${arguments[6].constructor.name}(${arguments[6].length});`));
                                                    } else Pt = `${r}Variable${yt}`;
                                                    g = Pt;
                                                    const pt = [
                                                        arguments[0],
                                                        arguments[1],
                                                        arguments[2],
                                                        arguments[3],
                                                        R(arguments[4]),
                                                        R(arguments[5]),
                                                        Pt
                                                    ];
                                                    return w.push(`${x}${r}.readPixels(${pt.join(", ")});`), E && it(arguments[2], arguments[3]), y && y(Pt, pt), o.readPixels.apply(o, arguments);
                                                case "drawBuffers":
                                                    return w.push(`${x}${r}.drawBuffers([${d(arguments[0], {
                                                        contextName: r,
                                                        contextVariables: k,
                                                        getEntity: R,
                                                        addVariable: U,
                                                        variables: v,
                                                        onUnrecognizedArgumentLookup: T
                                                    })}]);`), o.drawBuffers(arguments[0]);
                                            }
                                            let J = o[et].apply(o, arguments);
                                            switch(typeof J){
                                                case "undefined":
                                                    w.push(`${x}${st(et, arguments)};`);
                                                    return;
                                                case "number":
                                                case "boolean":
                                                    if (b && k.indexOf(a(J)) === -1) {
                                                        w.push(`${x}const ${r}Variable${k.length} = ${st(et, arguments)};`), k.push(J = a(J));
                                                        break;
                                                    }
                                                default:
                                                    J === null ? w.push(`${st(et, arguments)};`) : w.push(`${x}const ${r}Variable${k.length} = ${st(et, arguments)};`), k.push(J);
                                            }
                                            return J;
                                        } : (C[o[et]] = et, o[et]);
                                    }
                                    function A() {
                                        return w.join(`
`);
                                    }
                                    function P() {
                                        for(; w.length > 0;)w.pop();
                                    }
                                    function O(tt, et) {
                                        v[tt] = et;
                                    }
                                    function R(tt) {
                                        const et = C[tt];
                                        return et ? r + "." + et : tt;
                                    }
                                    function G(tt) {
                                        x = " ".repeat(tt);
                                    }
                                    function U(tt, et) {
                                        const J = `${r}Variable${k.length}`;
                                        return w.push(`${x}const ${J} = ${et};`), k.push(tt), J;
                                    }
                                    function it(tt, et) {
                                        const J = `${r}Variable${k.length}`, yt = `imageDatum${M}`;
                                        w.push(`${x}let ${yt} = ["P3\\n# ${E}.ppm\\n", ${tt}, ' ', ${et}, "\\n255\\n"].join("");`), w.push(`${x}for (let i = 0; i < ${yt}.length; i += 4) {`), w.push(`${x}  ${yt} += ${J}[i] + ' ' + ${J}[i + 1] + ' ' + ${J}[i + 2] + ' ';`), w.push(`${x}}`), w.push(`${x}if (typeof require !== "undefined") {`), w.push(`${x}  require('fs').writeFileSync('./${E}.ppm', ${yt});`), w.push(`${x}}`), M++;
                                    }
                                    function q(tt) {
                                        w.push(`${x}// ${tt}`);
                                    }
                                    function B() {
                                        w.push(`${x}(() => {
${x}const error = ${r}.getError();
${x}if (error !== ${r}.NONE) {
${x}  const names = Object.getOwnPropertyNames(gl);
${x}  for (let i = 0; i < names.length; i++) {
${x}    const name = names[i];
${x}    if (${r}[name] === error) {
${x}      throw new Error('${r} threw ' + name);
${x}    }
${x}  }
${x}}
${x}})();`);
                                    }
                                    function st(tt, et) {
                                        return `${r}.${tt}(${d(et, {
                                            contextName: r,
                                            contextVariables: k,
                                            getEntity: R,
                                            addVariable: U,
                                            variables: v,
                                            onUnrecognizedArgumentLookup: T
                                        })})`;
                                    }
                                    function rt(tt) {
                                        if (v) {
                                            for(const et in v)if (v[et] === tt) return et;
                                        }
                                        return null;
                                    }
                                    function mt(tt) {
                                        const et = k.indexOf(tt);
                                        return et !== -1 ? `${r}Variable${et}` : null;
                                    }
                                }
                                function p(o, n) {
                                    const r = new Proxy(o, {
                                        get: C
                                    }), m = {}, { contextName: b, contextVariables: E, getEntity: w, useTrackablePrimitives: v, recording: y, variables: T, indent: _, onUnrecognizedArgumentLookup: k } = n;
                                    return r;
                                    function C(I, A) {
                                        return typeof I[A] == "function" ? function() {
                                            switch(A){
                                                case "drawBuffersWEBGL":
                                                    return y.push(`${_}${b}.drawBuffersWEBGL([${d(arguments[0], {
                                                        contextName: b,
                                                        contextVariables: E,
                                                        getEntity: M,
                                                        addVariable: g,
                                                        variables: T,
                                                        onUnrecognizedArgumentLookup: k
                                                    })}]);`), o.drawBuffersWEBGL(arguments[0]);
                                            }
                                            let P = o[A].apply(o, arguments);
                                            switch(typeof P){
                                                case "undefined":
                                                    y.push(`${_}${x(A, arguments)};`);
                                                    return;
                                                case "number":
                                                case "boolean":
                                                    v && E.indexOf(a(P)) === -1 ? (y.push(`${_}const ${b}Variable${E.length} = ${x(A, arguments)};`), E.push(P = a(P))) : (y.push(`${_}const ${b}Variable${E.length} = ${x(A, arguments)};`), E.push(P));
                                                    break;
                                                default:
                                                    P === null ? y.push(`${x(A, arguments)};`) : y.push(`${_}const ${b}Variable${E.length} = ${x(A, arguments)};`), E.push(P);
                                            }
                                            return P;
                                        } : (m[o[A]] = A, o[A]);
                                    }
                                    function M(I) {
                                        return m.hasOwnProperty(I) ? `${b}.${m[I]}` : w(I);
                                    }
                                    function x(I, A) {
                                        return `${b}.${I}(${d(A, {
                                            contextName: b,
                                            contextVariables: E,
                                            getEntity: M,
                                            addVariable: g,
                                            variables: T,
                                            onUnrecognizedArgumentLookup: k
                                        })})`;
                                    }
                                    function g(I, A) {
                                        const P = `${b}Variable${E.length}`;
                                        return E.push(I), y.push(`${_}const ${P} = ${A};`), P;
                                    }
                                }
                                function d(o, n) {
                                    const { variables: r, onUnrecognizedArgumentLookup: m } = n;
                                    return Array.from(o).map((E)=>{
                                        const w = b(E);
                                        return w || l(E, n);
                                    }).join(", ");
                                    function b(E) {
                                        if (r) {
                                            for(const w in r)if (r.hasOwnProperty(w) && r[w] === E) return w;
                                        }
                                        return m ? m(E) : null;
                                    }
                                }
                                function l(o, n) {
                                    const { contextName: r, contextVariables: m, getEntity: b, addVariable: E, onUnrecognizedArgumentLookup: w } = n;
                                    if (typeof o > "u") return "undefined";
                                    if (o === null) return "null";
                                    const v = m.indexOf(o);
                                    if (v > -1) return `${r}Variable${v}`;
                                    switch(o.constructor.name){
                                        case "String":
                                            const y = /\n/.test(o), T = /'/.test(o), _ = /"/.test(o);
                                            return y ? "`" + o + "`" : T && !_ ? '"' + o + '"' : "'" + o + "'";
                                        case "Number":
                                            return b(o);
                                        case "Boolean":
                                            return b(o);
                                        case "Array":
                                            return E(o, `new ${o.constructor.name}([${Array.from(o).join(",")}])`);
                                        case "Float32Array":
                                        case "Uint8Array":
                                        case "Uint16Array":
                                        case "Int32Array":
                                            return E(o, `new ${o.constructor.name}(${JSON.stringify(Array.from(o))})`);
                                        default:
                                            if (w) {
                                                const k = w(o);
                                                if (k) return k;
                                            }
                                            throw new Error(`unrecognized argument type ${o.constructor.name}`);
                                    }
                                }
                                function a(o) {
                                    return new o.constructor(o);
                                }
                                typeof i < "u" && (i.exports = {
                                    glWiretap: u,
                                    glExtensionWiretap: p
                                }), typeof window < "u" && (u.glExtensionWiretap = p, window.glWiretap = u);
                            },
                            {}
                        ],
                        4: [
                            function(e, i, h) {
                                function u(E) {
                                    const w = new Array(E.length);
                                    for(let v = 0; v < E.length; v++){
                                        const y = E[v];
                                        y.toArray ? w[v] = y.toArray() : w[v] = y;
                                    }
                                    return w;
                                }
                                function p() {
                                    const E = u(arguments), w = new Float32Array(this.output.x);
                                    for(let v = 0; v < this.output.x; v++)this.thread.x = v, this.thread.y = 0, this.thread.z = 0, w[v] = this._fn.apply(this, E);
                                    return w;
                                }
                                function d() {
                                    const E = u(arguments), w = new Array(this.output.y);
                                    for(let v = 0; v < this.output.y; v++){
                                        const y = new Float32Array(this.output.x);
                                        for(let T = 0; T < this.output.x; T++)this.thread.x = T, this.thread.y = v, this.thread.z = 0, y[T] = this._fn.apply(this, E);
                                        w[v] = y;
                                    }
                                    return w;
                                }
                                function l() {
                                    const E = u(arguments);
                                    for(let w = 0; w < this.output.y; w++)for(let v = 0; v < this.output.x; v++)this.thread.x = v, this.thread.y = w, this.thread.z = 0, this._fn.apply(this, E);
                                }
                                function a() {
                                    const E = u(arguments), w = new Array(this.output.z);
                                    for(let v = 0; v < this.output.z; v++){
                                        const y = new Array(this.output.y);
                                        for(let T = 0; T < this.output.y; T++){
                                            const _ = new Float32Array(this.output.x);
                                            for(let k = 0; k < this.output.x; k++)this.thread.x = k, this.thread.y = T, this.thread.z = v, _[k] = this._fn.apply(this, E);
                                            y[T] = _;
                                        }
                                        w[v] = y;
                                    }
                                    return w;
                                }
                                function o(E) {
                                    E.setOutput = (y)=>{
                                        E.output = r(y), E.graphical && n(E);
                                    }, E.toJSON = ()=>{
                                        throw new Error("Not usable with gpuMock");
                                    }, E.setConstants = (y)=>(E.constants = y, E), E.setGraphical = (y)=>(E.graphical = y, E), E.setCanvas = (y)=>(E.canvas = y, E), E.setContext = (y)=>(E.context = y, E), E.destroy = ()=>{}, E.validateSettings = ()=>{}, E.graphical && E.output && n(E), E.exec = function() {
                                        return new Promise((y, T)=>{
                                            try {
                                                y(E.apply(E, arguments));
                                            } catch (_) {
                                                T(_);
                                            }
                                        });
                                    }, E.getPixels = (y)=>{
                                        const { x: T, y: _ } = E.output;
                                        return y ? b(E._imageData.data, T, _) : E._imageData.data.slice(0);
                                    }, E.color = function(y, T, _, k) {
                                        typeof k > "u" && (k = 1), y = Math.floor(y * 255), T = Math.floor(T * 255), _ = Math.floor(_ * 255), k = Math.floor(k * 255);
                                        const C = E.output.x, M = E.output.y, x = E.thread.x, g = M - E.thread.y - 1, I = x + g * C;
                                        E._colorData[I * 4 + 0] = y, E._colorData[I * 4 + 1] = T, E._colorData[I * 4 + 2] = _, E._colorData[I * 4 + 3] = k;
                                    };
                                    const w = ()=>E, v = [
                                        "setWarnVarUsage",
                                        "setArgumentTypes",
                                        "setTactic",
                                        "setOptimizeFloatMemory",
                                        "setDebug",
                                        "setLoopMaxIterations",
                                        "setConstantTypes",
                                        "setFunctions",
                                        "setNativeFunctions",
                                        "setInjectedNative",
                                        "setPipeline",
                                        "setPrecision",
                                        "setOutputToTexture",
                                        "setImmutable",
                                        "setStrictIntegers",
                                        "setDynamicOutput",
                                        "setHardcodeConstants",
                                        "setDynamicArguments",
                                        "setUseLegacyEncoder",
                                        "setWarnVarUsage",
                                        "addSubKernel"
                                    ];
                                    for(let y = 0; y < v.length; y++)E[v[y]] = w;
                                    return E;
                                }
                                function n(E) {
                                    const { x: w, y: v } = E.output;
                                    if (E.context && E.context.createImageData) {
                                        const y = new Uint8ClampedArray(w * v * 4);
                                        E._imageData = E.context.createImageData(w, v), E._colorData = y;
                                    } else {
                                        const y = new Uint8ClampedArray(w * v * 4);
                                        E._imageData = {
                                            data: y
                                        }, E._colorData = y;
                                    }
                                }
                                function r(E) {
                                    let w = null;
                                    if (E.length) if (E.length === 3) {
                                        const [v, y, T] = E;
                                        w = {
                                            x: v,
                                            y,
                                            z: T
                                        };
                                    } else if (E.length === 2) {
                                        const [v, y] = E;
                                        w = {
                                            x: v,
                                            y
                                        };
                                    } else {
                                        const [v] = E;
                                        w = {
                                            x: v
                                        };
                                    }
                                    else w = E;
                                    return w;
                                }
                                function m(E, w = {}) {
                                    const v = w.output ? r(w.output) : null;
                                    function y() {
                                        return y.output.z ? a.apply(y, arguments) : y.output.y ? y.graphical ? l.apply(y, arguments) : d.apply(y, arguments) : p.apply(y, arguments);
                                    }
                                    return y._fn = E, y.constants = w.constants || null, y.context = w.context || null, y.canvas = w.canvas || null, y.graphical = w.graphical || !1, y._imageData = null, y._colorData = null, y.output = v, y.thread = {
                                        x: 0,
                                        y: 0,
                                        z: 0
                                    }, o(y);
                                }
                                function b(E, w, v) {
                                    const y = v / 2 | 0, T = w * 4, _ = new Uint8ClampedArray(w * 4), k = E.slice(0);
                                    for(let C = 0; C < y; ++C){
                                        const M = C * T, x = (v - C - 1) * T;
                                        _.set(k.subarray(M, M + T)), k.copyWithin(M, x, x + T), k.set(_, x);
                                    }
                                    return k;
                                }
                                i.exports = {
                                    gpuMock: m
                                };
                            },
                            {}
                        ],
                        5: [
                            function(e, i, h) {
                                const { utils: u } = e("./utils");
                                function p(d, l) {
                                    const a = l.toString();
                                    return new Function(`return function ${d} (${u.getArgumentNamesFromString(a).join(", ")}) {
  ${u.getFunctionBodyFromString(a)}
}`)();
                                }
                                i.exports = {
                                    alias: p
                                };
                            },
                            {
                                "./utils": 114
                            }
                        ],
                        6: [
                            function(e, i, h) {
                                const { FunctionNode: u } = e("../function-node");
                                class p extends u {
                                    astFunction(l, a) {
                                        if (!this.isRootKernel) {
                                            a.push("function"), a.push(" "), a.push(this.name), a.push("(");
                                            for(let o = 0; o < this.argumentNames.length; ++o){
                                                const n = this.argumentNames[o];
                                                o > 0 && a.push(", "), a.push("user_"), a.push(n);
                                            }
                                            a.push(`) {
`);
                                        }
                                        for(let o = 0; o < l.body.body.length; ++o)this.astGeneric(l.body.body[o], a), a.push(`
`);
                                        return this.isRootKernel || a.push(`}
`), a;
                                    }
                                    astReturnStatement(l, a) {
                                        const o = this.returnType || this.getType(l.argument);
                                        return this.returnType || (this.returnType = o), this.isRootKernel ? (a.push(this.leadingReturnStatement), this.astGeneric(l.argument, a), a.push(`;
`), a.push(this.followingReturnStatement), a.push(`continue;
`)) : this.isSubKernel ? (a.push(`subKernelResult_${this.name} = `), this.astGeneric(l.argument, a), a.push(";"), a.push(`return subKernelResult_${this.name};`)) : (a.push("return "), this.astGeneric(l.argument, a), a.push(";")), a;
                                    }
                                    astLiteral(l, a) {
                                        if (isNaN(l.value)) throw this.astErrorOutput("Non-numeric literal not supported : " + l.value, l);
                                        return a.push(l.value), a;
                                    }
                                    astBinaryExpression(l, a) {
                                        return a.push("("), this.astGeneric(l.left, a), a.push(l.operator), this.astGeneric(l.right, a), a.push(")"), a;
                                    }
                                    astIdentifierExpression(l, a) {
                                        if (l.type !== "Identifier") throw this.astErrorOutput("IdentifierExpression - not an Identifier", l);
                                        switch(l.name){
                                            case "Infinity":
                                                a.push("Infinity");
                                                break;
                                            default:
                                                this.constants && this.constants.hasOwnProperty(l.name) ? a.push("constants_" + l.name) : a.push("user_" + l.name);
                                        }
                                        return a;
                                    }
                                    astForStatement(l, a) {
                                        if (l.type !== "ForStatement") throw this.astErrorOutput("Invalid for statement", l);
                                        const o = [], n = [], r = [], m = [];
                                        let b = null;
                                        if (l.init) {
                                            this.pushState("in-for-loop-init"), this.astGeneric(l.init, o);
                                            for(let E = 0; E < o.length; E++)o[E].includes && o[E].includes(",") && (b = !1);
                                            this.popState("in-for-loop-init");
                                        } else b = !1;
                                        if (l.test ? this.astGeneric(l.test, n) : b = !1, l.update ? this.astGeneric(l.update, r) : b = !1, l.body && (this.pushState("loop-body"), this.astGeneric(l.body, m), this.popState("loop-body")), b === null && (b = this.isSafe(l.init) && this.isSafe(l.test)), b) a.push(`for (${o.join("")};${n.join("")};${r.join("")}){
`), a.push(m.join("")), a.push(`}
`);
                                        else {
                                            const E = this.getInternalVariableName("safeI");
                                            o.length > 0 && a.push(o.join(""), `;
`), a.push(`for (let ${E}=0;${E}<LOOP_MAX;${E}++){
`), n.length > 0 && a.push(`if (!${n.join("")}) break;
`), a.push(m.join("")), a.push(`
${r.join("")};`), a.push(`}
`);
                                        }
                                        return a;
                                    }
                                    astWhileStatement(l, a) {
                                        if (l.type !== "WhileStatement") throw this.astErrorOutput("Invalid while statement", l);
                                        return a.push("for (let i = 0; i < LOOP_MAX; i++) {"), a.push("if ("), this.astGeneric(l.test, a), a.push(`) {
`), this.astGeneric(l.body, a), a.push(`} else {
`), a.push(`break;
`), a.push(`}
`), a.push(`}
`), a;
                                    }
                                    astDoWhileStatement(l, a) {
                                        if (l.type !== "DoWhileStatement") throw this.astErrorOutput("Invalid while statement", l);
                                        return a.push("for (let i = 0; i < LOOP_MAX; i++) {"), this.astGeneric(l.body, a), a.push("if (!"), this.astGeneric(l.test, a), a.push(`) {
`), a.push(`break;
`), a.push(`}
`), a.push(`}
`), a;
                                    }
                                    astAssignmentExpression(l, a) {
                                        const o = this.getDeclaration(l.left);
                                        if (o && !o.assignable) throw this.astErrorOutput(`Variable ${l.left.name} is not assignable here`, l);
                                        return this.astGeneric(l.left, a), a.push(l.operator), this.astGeneric(l.right, a), a;
                                    }
                                    astBlockStatement(l, a) {
                                        if (this.isState("loop-body")) {
                                            this.pushState("block-body");
                                            for(let o = 0; o < l.body.length; o++)this.astGeneric(l.body[o], a);
                                            this.popState("block-body");
                                        } else {
                                            a.push(`{
`);
                                            for(let o = 0; o < l.body.length; o++)this.astGeneric(l.body[o], a);
                                            a.push(`}
`);
                                        }
                                        return a;
                                    }
                                    astVariableDeclaration(l, a) {
                                        a.push(`${l.kind} `);
                                        const { declarations: o } = l;
                                        for(let n = 0; n < o.length; n++){
                                            n > 0 && a.push(",");
                                            const r = o[n], m = this.getDeclaration(r.id);
                                            m.valueType || (m.valueType = this.getType(r.init)), this.astGeneric(r, a);
                                        }
                                        return this.isState("in-for-loop-init") || a.push(";"), a;
                                    }
                                    astIfStatement(l, a) {
                                        return a.push("if ("), this.astGeneric(l.test, a), a.push(")"), l.consequent.type === "BlockStatement" ? this.astGeneric(l.consequent, a) : (a.push(` {
`), this.astGeneric(l.consequent, a), a.push(`
}
`)), l.alternate && (a.push("else "), l.alternate.type === "BlockStatement" || l.alternate.type === "IfStatement" ? this.astGeneric(l.alternate, a) : (a.push(` {
`), this.astGeneric(l.alternate, a), a.push(`
}
`))), a;
                                    }
                                    astSwitchStatement(l, a) {
                                        const { discriminant: o, cases: n } = l;
                                        a.push("switch ("), this.astGeneric(o, a), a.push(`) {
`);
                                        for(let r = 0; r < n.length; r++){
                                            if (n[r].test === null) {
                                                a.push(`default:
`), this.astGeneric(n[r].consequent, a), n[r].consequent && n[r].consequent.length > 0 && a.push(`break;
`);
                                                continue;
                                            }
                                            a.push("case "), this.astGeneric(n[r].test, a), a.push(`:
`), n[r].consequent && n[r].consequent.length > 0 && (this.astGeneric(n[r].consequent, a), a.push(`break;
`));
                                        }
                                        a.push(`
}`);
                                    }
                                    astThisExpression(l, a) {
                                        return a.push("_this"), a;
                                    }
                                    astMemberExpression(l, a) {
                                        const { signature: o, type: n, property: r, xProperty: m, yProperty: b, zProperty: E, name: w, origin: v } = this.getMemberExpressionDetails(l);
                                        switch(o){
                                            case "this.thread.value":
                                                return a.push(`_this.thread.${w}`), a;
                                            case "this.output.value":
                                                switch(w){
                                                    case "x":
                                                        a.push("outputX");
                                                        break;
                                                    case "y":
                                                        a.push("outputY");
                                                        break;
                                                    case "z":
                                                        a.push("outputZ");
                                                        break;
                                                    default:
                                                        throw this.astErrorOutput("Unexpected expression", l);
                                                }
                                                return a;
                                            case "value":
                                                throw this.astErrorOutput("Unexpected expression", l);
                                            case "value[]":
                                            case "value[][]":
                                            case "value[][][]":
                                            case "value.value":
                                                if (v === "Math") return a.push(Math[w]), a;
                                                switch(r){
                                                    case "r":
                                                        return a.push(`user_${w}[0]`), a;
                                                    case "g":
                                                        return a.push(`user_${w}[1]`), a;
                                                    case "b":
                                                        return a.push(`user_${w}[2]`), a;
                                                    case "a":
                                                        return a.push(`user_${w}[3]`), a;
                                                }
                                                break;
                                            case "this.constants.value":
                                            case "this.constants.value[]":
                                            case "this.constants.value[][]":
                                            case "this.constants.value[][][]":
                                                break;
                                            case "fn()[]":
                                                return this.astGeneric(l.object, a), a.push("["), this.astGeneric(l.property, a), a.push("]"), a;
                                            case "fn()[][]":
                                                return this.astGeneric(l.object.object, a), a.push("["), this.astGeneric(l.object.property, a), a.push("]"), a.push("["), this.astGeneric(l.property, a), a.push("]"), a;
                                            default:
                                                throw this.astErrorOutput("Unexpected expression", l);
                                        }
                                        if (!l.computed) switch(n){
                                            case "Number":
                                            case "Integer":
                                            case "Float":
                                            case "Boolean":
                                                return a.push(`${v}_${w}`), a;
                                        }
                                        const y = `${v}_${w}`;
                                        switch(n){
                                            case "Array(2)":
                                            case "Array(3)":
                                            case "Array(4)":
                                            case "Matrix(2)":
                                            case "Matrix(3)":
                                            case "Matrix(4)":
                                            case "HTMLImageArray":
                                            case "ArrayTexture(1)":
                                            case "ArrayTexture(2)":
                                            case "ArrayTexture(3)":
                                            case "ArrayTexture(4)":
                                            case "HTMLImage":
                                            default:
                                                let T, _;
                                                if (v === "constants") {
                                                    const k = this.constants[w];
                                                    _ = this.constantTypes[w] === "Input", T = _ ? k.size : null;
                                                } else _ = this.isInput(w), T = _ ? this.argumentSizes[this.argumentNames.indexOf(w)] : null;
                                                a.push(`${y}`), E && b ? _ ? (a.push("[("), this.astGeneric(E, a), a.push(`*${this.dynamicArguments ? "(outputY * outputX)" : T[1] * T[0]})+(`), this.astGeneric(b, a), a.push(`*${this.dynamicArguments ? "outputX" : T[0]})+`), this.astGeneric(m, a), a.push("]")) : (a.push("["), this.astGeneric(E, a), a.push("]"), a.push("["), this.astGeneric(b, a), a.push("]"), a.push("["), this.astGeneric(m, a), a.push("]")) : b ? _ ? (a.push("[("), this.astGeneric(b, a), a.push(`*${this.dynamicArguments ? "outputX" : T[0]})+`), this.astGeneric(m, a), a.push("]")) : (a.push("["), this.astGeneric(b, a), a.push("]"), a.push("["), this.astGeneric(m, a), a.push("]")) : typeof m < "u" && (a.push("["), this.astGeneric(m, a), a.push("]"));
                                        }
                                        return a;
                                    }
                                    astCallExpression(l, a) {
                                        if (l.type !== "CallExpression") throw this.astErrorOutput("Unknown CallExpression", l);
                                        let o = this.astMemberExpressionUnroll(l.callee);
                                        this.calledFunctions.indexOf(o) < 0 && this.calledFunctions.push(o), this.isAstMathFunction(l), this.onFunctionCall && this.onFunctionCall(this.name, o, l.arguments), a.push(o), a.push("(");
                                        const n = this.lookupFunctionArgumentTypes(o) || [];
                                        for(let r = 0; r < l.arguments.length; ++r){
                                            const m = l.arguments[r];
                                            let b = this.getType(m);
                                            n[r] || this.triggerImplyArgumentType(o, r, b, this), r > 0 && a.push(", "), this.astGeneric(m, a);
                                        }
                                        return a.push(")"), a;
                                    }
                                    astArrayExpression(l, a) {
                                        const o = this.getType(l), n = l.elements.length, r = [];
                                        for(let m = 0; m < n; ++m){
                                            const b = [];
                                            this.astGeneric(l.elements[m], b), r.push(b.join(""));
                                        }
                                        switch(o){
                                            case "Matrix(2)":
                                            case "Matrix(3)":
                                            case "Matrix(4)":
                                                a.push(`[${r.join(", ")}]`);
                                                break;
                                            default:
                                                a.push(`new Float32Array([${r.join(", ")}])`);
                                        }
                                        return a;
                                    }
                                    astDebuggerStatement(l, a) {
                                        return a.push("debugger;"), a;
                                    }
                                }
                                i.exports = {
                                    CPUFunctionNode: p
                                };
                            },
                            {
                                "../function-node": 10
                            }
                        ],
                        7: [
                            function(e, i, h) {
                                const { utils: u } = e("../../utils");
                                function p(l, a) {
                                    const o = [];
                                    for(const n in a){
                                        if (!a.hasOwnProperty(n)) continue;
                                        const r = a[n], m = l[n];
                                        switch(r){
                                            case "Number":
                                            case "Integer":
                                            case "Float":
                                            case "Boolean":
                                                o.push(`${n}:${m}`);
                                                break;
                                            case "Array(2)":
                                            case "Array(3)":
                                            case "Array(4)":
                                            case "Matrix(2)":
                                            case "Matrix(3)":
                                            case "Matrix(4)":
                                                o.push(`${n}:new ${m.constructor.name}(${JSON.stringify(Array.from(m))})`);
                                                break;
                                        }
                                    }
                                    return `{ ${o.join()} }`;
                                }
                                function d(l, a) {
                                    const o = [], n = [], r = [], m = !/^function/.test(l.color.toString());
                                    if (o.push("  const { context, canvas, constants: incomingConstants } = settings;", `  const output = new Int32Array(${JSON.stringify(Array.from(l.output))});`, `  const _constantTypes = ${JSON.stringify(l.constantTypes)};`, `  const _constants = ${p(l.constants, l.constantTypes)};`), n.push("    constants: _constants,", "    context,", "    output,", "    thread: {x: 0, y: 0, z: 0},"), l.graphical) {
                                        o.push(`  const _imageData = context.createImageData(${l.output[0]}, ${l.output[1]});`), o.push(`  const _colorData = new Uint8ClampedArray(${l.output[0]} * ${l.output[1]} * 4);`);
                                        const w = u.flattenFunctionToString((m ? "function " : "") + l.color.toString(), {
                                            thisLookup: (y)=>{
                                                switch(y){
                                                    case "_colorData":
                                                        return "_colorData";
                                                    case "_imageData":
                                                        return "_imageData";
                                                    case "output":
                                                        return "output";
                                                    case "thread":
                                                        return "this.thread";
                                                }
                                                return JSON.stringify(l[y]);
                                            },
                                            findDependency: (y, T)=>null
                                        }), v = u.flattenFunctionToString((m ? "function " : "") + l.getPixels.toString(), {
                                            thisLookup: (y)=>{
                                                switch(y){
                                                    case "_colorData":
                                                        return "_colorData";
                                                    case "_imageData":
                                                        return "_imageData";
                                                    case "output":
                                                        return "output";
                                                    case "thread":
                                                        return "this.thread";
                                                }
                                                return JSON.stringify(l[y]);
                                            },
                                            findDependency: ()=>null
                                        });
                                        n.push("    _imageData,", "    _colorData,", `    color: ${w},`), r.push(`  kernel.getPixels = ${v};`);
                                    }
                                    const b = [], E = Object.keys(l.constantTypes);
                                    for(let w = 0; w < E.length; w++)b.push(l.constantTypes[E]);
                                    if (l.argumentTypes.indexOf("HTMLImageArray") !== -1 || b.indexOf("HTMLImageArray") !== -1) {
                                        const w = u.flattenFunctionToString((m ? "function " : "") + l._imageTo3DArray.toString(), {
                                            doNotDefine: [
                                                "canvas"
                                            ],
                                            findDependency: (v, y)=>v === "this" ? (m ? "function " : "") + l[y].toString() : null,
                                            thisLookup: (v)=>{
                                                switch(v){
                                                    case "canvas":
                                                        return;
                                                    case "context":
                                                        return "context";
                                                }
                                            }
                                        });
                                        r.push(w), n.push("    _mediaTo2DArray,"), n.push("    _imageTo3DArray,");
                                    } else if (l.argumentTypes.indexOf("HTMLImage") !== -1 || b.indexOf("HTMLImage") !== -1) {
                                        const w = u.flattenFunctionToString((m ? "function " : "") + l._mediaTo2DArray.toString(), {
                                            findDependency: (v, y)=>null,
                                            thisLookup: (v)=>{
                                                switch(v){
                                                    case "canvas":
                                                        return "settings.canvas";
                                                    case "context":
                                                        return "settings.context";
                                                }
                                                throw new Error("unhandled thisLookup");
                                            }
                                        });
                                        r.push(w), n.push("    _mediaTo2DArray,");
                                    }
                                    return `function(settings) {
${o.join(`
`)}
  for (const p in _constantTypes) {
    if (!_constantTypes.hasOwnProperty(p)) continue;
    const type = _constantTypes[p];
    switch (type) {
      case 'Number':
      case 'Integer':
      case 'Float':
      case 'Boolean':
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        if (incomingConstants.hasOwnProperty(p)) {
          console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');
        }
        continue;
    }
    if (!incomingConstants.hasOwnProperty(p)) {
      throw new Error('constant ' + p + ' not found');
    }
    _constants[p] = incomingConstants[p];
  }
  const kernel = (function() {
${l._kernelString}
  })
    .apply({ ${n.join(`
`)} });
  ${r.join(`
`)}
  return kernel;
}`;
                                }
                                i.exports = {
                                    cpuKernelString: d
                                };
                            },
                            {
                                "../../utils": 114
                            }
                        ],
                        8: [
                            function(e, i, h) {
                                const { Kernel: u } = e("../kernel"), { FunctionBuilder: p } = e("../function-builder"), { CPUFunctionNode: d } = e("./function-node"), { utils: l } = e("../../utils"), { cpuKernelString: a } = e("./kernel-string");
                                class o extends u {
                                    static getFeatures() {
                                        return this.features;
                                    }
                                    static get features() {
                                        return Object.freeze({
                                            kernelMap: !0,
                                            isIntegerDivisionAccurate: !0
                                        });
                                    }
                                    static get isSupported() {
                                        return !0;
                                    }
                                    static isContextMatch(r) {
                                        return !1;
                                    }
                                    static get mode() {
                                        return "cpu";
                                    }
                                    static nativeFunctionArguments() {
                                        return null;
                                    }
                                    static nativeFunctionReturnType() {
                                        throw new Error(`Looking up native function return type not supported on ${this.name}`);
                                    }
                                    static combineKernels(r) {
                                        return r;
                                    }
                                    static getSignature(r, m) {
                                        return "cpu" + (m.length > 0 ? ":" + m.join(",") : "");
                                    }
                                    constructor(r, m){
                                        super(r, m), this.mergeSettings(r.settings || m), this._imageData = null, this._colorData = null, this._kernelString = null, this._prependedString = [], this.thread = {
                                            x: 0,
                                            y: 0,
                                            z: 0
                                        }, this.translatedSources = null;
                                    }
                                    initCanvas() {
                                        if (typeof document < "u") return document.createElement("canvas");
                                        if (typeof OffscreenCanvas < "u") return new OffscreenCanvas(0, 0);
                                    }
                                    initContext() {
                                        return this.canvas ? this.canvas.getContext("2d") : null;
                                    }
                                    initPlugins(r) {
                                        return [];
                                    }
                                    validateSettings(r) {
                                        if (!this.output || this.output.length === 0) {
                                            if (r.length !== 1) throw new Error("Auto output only supported for kernels with only one input");
                                            const m = l.getVariableType(r[0], this.strictIntegers);
                                            if (m === "Array") this.output = l.getDimensions(m);
                                            else if (m === "NumberTexture" || m === "ArrayTexture(4)") this.output = r[0].output;
                                            else throw new Error("Auto output not supported for input type: " + m);
                                        }
                                        if (this.graphical && this.output.length !== 2) throw new Error("Output must have 2 dimensions on graphical mode");
                                        this.checkOutput();
                                    }
                                    translateSource() {
                                        if (this.leadingReturnStatement = this.output.length > 1 ? "resultX[x] = " : "result[x] = ", this.subKernels) {
                                            const m = [];
                                            for(let b = 0; b < this.subKernels.length; b++){
                                                const { name: E } = this.subKernels[b];
                                                m.push(this.output.length > 1 ? `resultX_${E}[x] = subKernelResult_${E};
` : `result_${E}[x] = subKernelResult_${E};
`);
                                            }
                                            this.followingReturnStatement = m.join("");
                                        }
                                        const r = p.fromKernel(this, d);
                                        this.translatedSources = r.getPrototypes("kernel"), !this.graphical && !this.returnType && (this.returnType = r.getKernelResultType());
                                    }
                                    build() {
                                        if (this.built) return;
                                        if (this.setupConstants(), this.setupArguments(arguments), this.validateSettings(arguments), this.translateSource(), this.graphical) {
                                            const { canvas: m, output: b } = this;
                                            if (!m) throw new Error("no canvas available for using graphical output");
                                            const E = b[0], w = b[1] || 1;
                                            m.width = E, m.height = w, this._imageData = this.context.createImageData(E, w), this._colorData = new Uint8ClampedArray(E * w * 4);
                                        }
                                        const r = this.getKernelString();
                                        this.kernelString = r, this.debug && (console.log("Function output:"), console.log(r));
                                        try {
                                            this.run = new Function([], r).bind(this)();
                                        } catch (m) {
                                            console.error("An error occurred compiling the javascript: ", m);
                                        }
                                        this.buildSignature(arguments), this.built = !0;
                                    }
                                    color(r, m, b, E) {
                                        typeof E > "u" && (E = 1), r = Math.floor(r * 255), m = Math.floor(m * 255), b = Math.floor(b * 255), E = Math.floor(E * 255);
                                        const w = this.output[0], v = this.output[1], y = this.thread.x, T = v - this.thread.y - 1, _ = y + T * w;
                                        this._colorData[_ * 4 + 0] = r, this._colorData[_ * 4 + 1] = m, this._colorData[_ * 4 + 2] = b, this._colorData[_ * 4 + 3] = E;
                                    }
                                    getKernelString() {
                                        if (this._kernelString !== null) return this._kernelString;
                                        let r = null, { translatedSources: m } = this;
                                        return m.length > 1 ? m = m.filter((b)=>/^function/.test(b) ? b : (r = b, !1)) : r = m.shift(), this._kernelString = `  const LOOP_MAX = ${this._getLoopMaxString()};
  ${this.injectedNative || ""}
  const _this = this;
  ${this._resultKernelHeader()}
  ${this._processConstants()}
  return (${this.argumentNames.map((b)=>"user_" + b).join(", ")}) => {
    ${this._prependedString.join("")}
    ${this._earlyThrows()}
    ${this._processArguments()}
    ${this.graphical ? this._graphicalKernelBody(r) : this._resultKernelBody(r)}
    ${m.length > 0 ? m.join(`
`) : ""}
  };`;
                                    }
                                    toString() {
                                        return a(this);
                                    }
                                    _getLoopMaxString() {
                                        return this.loopMaxIterations ? ` ${parseInt(this.loopMaxIterations)};` : " 1000;";
                                    }
                                    _processConstants() {
                                        if (!this.constants) return "";
                                        const r = [];
                                        for(let m in this.constants)switch(this.constantTypes[m]){
                                            case "HTMLCanvas":
                                            case "OffscreenCanvas":
                                            case "HTMLImage":
                                            case "ImageBitmap":
                                            case "ImageData":
                                            case "HTMLVideo":
                                                r.push(`    const constants_${m} = this._mediaTo2DArray(this.constants.${m});
`);
                                                break;
                                            case "HTMLImageArray":
                                                r.push(`    const constants_${m} = this._imageTo3DArray(this.constants.${m});
`);
                                                break;
                                            case "Input":
                                                r.push(`    const constants_${m} = this.constants.${m}.value;
`);
                                                break;
                                            default:
                                                r.push(`    const constants_${m} = this.constants.${m};
`);
                                        }
                                        return r.join("");
                                    }
                                    _earlyThrows() {
                                        if (this.graphical || this.immutable || !this.pipeline) return "";
                                        const r = [];
                                        for(let b = 0; b < this.argumentTypes.length; b++)this.argumentTypes[b] === "Array" && r.push(this.argumentNames[b]);
                                        if (r.length === 0) return "";
                                        const m = [];
                                        for(let b = 0; b < r.length; b++){
                                            const E = r[b], w = this._mapSubKernels((v)=>`user_${E} === result_${v.name}`).join(" || ");
                                            m.push(`user_${E} === result${w ? ` || ${w}` : ""}`);
                                        }
                                        return `if (${m.join(" || ")}) throw new Error('Source and destination arrays are the same.  Use immutable = true');`;
                                    }
                                    _processArguments() {
                                        const r = [];
                                        for(let m = 0; m < this.argumentTypes.length; m++){
                                            const b = `user_${this.argumentNames[m]}`;
                                            switch(this.argumentTypes[m]){
                                                case "HTMLCanvas":
                                                case "OffscreenCanvas":
                                                case "HTMLImage":
                                                case "ImageBitmap":
                                                case "ImageData":
                                                case "HTMLVideo":
                                                    r.push(`    ${b} = this._mediaTo2DArray(${b});
`);
                                                    break;
                                                case "HTMLImageArray":
                                                    r.push(`    ${b} = this._imageTo3DArray(${b});
`);
                                                    break;
                                                case "Input":
                                                    r.push(`    ${b} = ${b}.value;
`);
                                                    break;
                                                case "ArrayTexture(1)":
                                                case "ArrayTexture(2)":
                                                case "ArrayTexture(3)":
                                                case "ArrayTexture(4)":
                                                case "NumberTexture":
                                                case "MemoryOptimizedNumberTexture":
                                                    r.push(`
    if (${b}.toArray) {
      if (!_this.textureCache) {
        _this.textureCache = [];
        _this.arrayCache = [];
      }
      const textureIndex = _this.textureCache.indexOf(${b});
      if (textureIndex !== -1) {
        ${b} = _this.arrayCache[textureIndex];
      } else {
        _this.textureCache.push(${b});
        ${b} = ${b}.toArray();
        _this.arrayCache.push(${b});
      }
    }`);
                                                    break;
                                            }
                                        }
                                        return r.join("");
                                    }
                                    _mediaTo2DArray(r) {
                                        const m = this.canvas, b = r.width > 0 ? r.width : r.videoWidth, E = r.height > 0 ? r.height : r.videoHeight;
                                        m.width < b && (m.width = b), m.height < E && (m.height = E);
                                        const w = this.context;
                                        let v;
                                        r.constructor === ImageData ? v = r.data : (w.drawImage(r, 0, 0, b, E), v = w.getImageData(0, 0, b, E).data);
                                        const y = new Array(E);
                                        let T = 0;
                                        for(let _ = E - 1; _ >= 0; _--){
                                            const k = y[_] = new Array(b);
                                            for(let C = 0; C < b; C++){
                                                const M = new Float32Array(4);
                                                M[0] = v[T++] / 255, M[1] = v[T++] / 255, M[2] = v[T++] / 255, M[3] = v[T++] / 255, k[C] = M;
                                            }
                                        }
                                        return y;
                                    }
                                    getPixels(r) {
                                        const [m, b] = this.output;
                                        return r ? l.flipPixels(this._imageData.data, m, b) : this._imageData.data.slice(0);
                                    }
                                    _imageTo3DArray(r) {
                                        const m = new Array(r.length);
                                        for(let b = 0; b < r.length; b++)m[b] = this._mediaTo2DArray(r[b]);
                                        return m;
                                    }
                                    _resultKernelHeader() {
                                        if (this.graphical || this.immutable || !this.pipeline) return "";
                                        switch(this.output.length){
                                            case 1:
                                                return this._mutableKernel1DResults();
                                            case 2:
                                                return this._mutableKernel2DResults();
                                            case 3:
                                                return this._mutableKernel3DResults();
                                        }
                                    }
                                    _resultKernelBody(r) {
                                        switch(this.output.length){
                                            case 1:
                                                return (!this.immutable && this.pipeline ? this._resultMutableKernel1DLoop(r) : this._resultImmutableKernel1DLoop(r)) + this._kernelOutput();
                                            case 2:
                                                return (!this.immutable && this.pipeline ? this._resultMutableKernel2DLoop(r) : this._resultImmutableKernel2DLoop(r)) + this._kernelOutput();
                                            case 3:
                                                return (!this.immutable && this.pipeline ? this._resultMutableKernel3DLoop(r) : this._resultImmutableKernel3DLoop(r)) + this._kernelOutput();
                                            default:
                                                throw new Error("unsupported size kernel");
                                        }
                                    }
                                    _graphicalKernelBody(r) {
                                        switch(this.output.length){
                                            case 2:
                                                return this._graphicalKernel2DLoop(r) + this._graphicalOutput();
                                            default:
                                                throw new Error("unsupported size kernel");
                                        }
                                    }
                                    _graphicalOutput() {
                                        return `
    this._imageData.data.set(this._colorData);
    this.context.putImageData(this._imageData, 0, 0);
    return;`;
                                    }
                                    _getKernelResultTypeConstructorString() {
                                        switch(this.returnType){
                                            case "LiteralInteger":
                                            case "Number":
                                            case "Integer":
                                            case "Float":
                                                return "Float32Array";
                                            case "Array(2)":
                                            case "Array(3)":
                                            case "Array(4)":
                                                return "Array";
                                            default:
                                                if (this.graphical) return "Float32Array";
                                                throw new Error(`unhandled returnType ${this.returnType}`);
                                        }
                                    }
                                    _resultImmutableKernel1DLoop(r) {
                                        const m = this._getKernelResultTypeConstructorString();
                                        return `  const outputX = _this.output[0];
    const result = new ${m}(outputX);
    ${this._mapSubKernels((b)=>`const result_${b.name} = new ${m}(outputX);
`).join("    ")}
    ${this._mapSubKernels((b)=>`let subKernelResult_${b.name};
`).join("    ")}
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${r}
    }`;
                                    }
                                    _mutableKernel1DResults() {
                                        const r = this._getKernelResultTypeConstructorString();
                                        return `  const outputX = _this.output[0];
    const result = new ${r}(outputX);
    ${this._mapSubKernels((m)=>`const result_${m.name} = new ${r}(outputX);
`).join("    ")}
    ${this._mapSubKernels((m)=>`let subKernelResult_${m.name};
`).join("    ")}`;
                                    }
                                    _resultMutableKernel1DLoop(r) {
                                        return `  const outputX = _this.output[0];
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${r}
    }`;
                                    }
                                    _resultImmutableKernel2DLoop(r) {
                                        const m = this._getKernelResultTypeConstructorString();
                                        return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${this._mapSubKernels((b)=>`const result_${b.name} = new Array(outputY);
`).join("    ")}
    ${this._mapSubKernels((b)=>`let subKernelResult_${b.name};
`).join("    ")}
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y] = new ${m}(outputX);
      ${this._mapSubKernels((b)=>`const resultX_${b.name} = result_${b.name}[y] = new ${m}(outputX);
`).join("")}
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${r}
      }
    }`;
                                    }
                                    _mutableKernel2DResults() {
                                        const r = this._getKernelResultTypeConstructorString();
                                        return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${this._mapSubKernels((m)=>`const result_${m.name} = new Array(outputY);
`).join("    ")}
    ${this._mapSubKernels((m)=>`let subKernelResult_${m.name};
`).join("    ")}
    for (let y = 0; y < outputY; y++) {
      const resultX = result[y] = new ${r}(outputX);
      ${this._mapSubKernels((m)=>`const resultX_${m.name} = result_${m.name}[y] = new ${r}(outputX);
`).join("")}
    }`;
                                    }
                                    _resultMutableKernel2DLoop(r) {
                                        const m = this._getKernelResultTypeConstructorString();
                                        return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y];
      ${this._mapSubKernels((b)=>`const resultX_${b.name} = result_${b.name}[y] = new ${m}(outputX);
`).join("")}
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${r}
      }
    }`;
                                    }
                                    _graphicalKernel2DLoop(r) {
                                        return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${r}
      }
    }`;
                                    }
                                    _resultImmutableKernel3DLoop(r) {
                                        const m = this._getKernelResultTypeConstructorString();
                                        return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${this._mapSubKernels((b)=>`const result_${b.name} = new Array(outputZ);
`).join("    ")}
    ${this._mapSubKernels((b)=>`let subKernelResult_${b.name};
`).join("    ")}
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z] = new Array(outputY);
      ${this._mapSubKernels((b)=>`const resultY_${b.name} = result_${b.name}[z] = new Array(outputY);
`).join("      ")}
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y] = new ${m}(outputX);
        ${this._mapSubKernels((b)=>`const resultX_${b.name} = resultY_${b.name}[y] = new ${m}(outputX);
`).join("        ")}
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${r}
        }
      }
    }`;
                                    }
                                    _mutableKernel3DResults() {
                                        const r = this._getKernelResultTypeConstructorString();
                                        return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${this._mapSubKernels((m)=>`const result_${m.name} = new Array(outputZ);
`).join("    ")}
    ${this._mapSubKernels((m)=>`let subKernelResult_${m.name};
`).join("    ")}
    for (let z = 0; z < outputZ; z++) {
      const resultY = result[z] = new Array(outputY);
      ${this._mapSubKernels((m)=>`const resultY_${m.name} = result_${m.name}[z] = new Array(outputY);
`).join("      ")}
      for (let y = 0; y < outputY; y++) {
        const resultX = resultY[y] = new ${r}(outputX);
        ${this._mapSubKernels((m)=>`const resultX_${m.name} = resultY_${m.name}[y] = new ${r}(outputX);
`).join("        ")}
      }
    }`;
                                    }
                                    _resultMutableKernel3DLoop(r) {
                                        return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z];
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y];
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${r}
        }
      }
    }`;
                                    }
                                    _kernelOutput() {
                                        return this.subKernels ? `
    return {
      result: result,
      ${this.subKernels.map((r)=>`${r.property}: result_${r.name}`).join(`,
      `)}
    };` : `
    return result;`;
                                    }
                                    _mapSubKernels(r) {
                                        return this.subKernels === null ? [
                                            ""
                                        ] : this.subKernels.map(r);
                                    }
                                    destroy(r) {
                                        r && delete this.canvas;
                                    }
                                    static destroyContext(r) {}
                                    toJSON() {
                                        const r = super.toJSON();
                                        return r.functionNodes = p.fromKernel(this, d).toJSON(), r;
                                    }
                                    setOutput(r) {
                                        super.setOutput(r);
                                        const [m, b] = this.output;
                                        this.graphical && (this._imageData = this.context.createImageData(m, b), this._colorData = new Uint8ClampedArray(m * b * 4));
                                    }
                                    prependString(r) {
                                        if (this._kernelString) throw new Error("Kernel already built");
                                        this._prependedString.push(r);
                                    }
                                    hasPrependString(r) {
                                        return this._prependedString.indexOf(r) > -1;
                                    }
                                }
                                i.exports = {
                                    CPUKernel: o
                                };
                            },
                            {
                                "../../utils": 114,
                                "../function-builder": 9,
                                "../kernel": 36,
                                "./function-node": 6,
                                "./kernel-string": 7
                            }
                        ],
                        9: [
                            function(e, i, h) {
                                class u {
                                    static fromKernel(d, l, a) {
                                        const { kernelArguments: o, kernelConstants: n, argumentNames: r, argumentSizes: m, argumentBitRatios: b, constants: E, constantBitRatios: w, debug: v, loopMaxIterations: y, nativeFunctions: T, output: _, optimizeFloatMemory: k, precision: C, plugins: M, source: x, subKernels: g, functions: I, leadingReturnStatement: A, followingReturnStatement: P, dynamicArguments: O, dynamicOutput: R } = d, G = new Array(o.length), U = {};
                                        for(let at = 0; at < o.length; at++)G[at] = o[at].type;
                                        for(let at = 0; at < n.length; at++){
                                            const Lt = n[at];
                                            U[Lt.name] = Lt.type;
                                        }
                                        const it = (at, Lt)=>Gt.needsArgumentType(at, Lt), q = (at, Lt, Nt)=>{
                                            Gt.assignArgumentType(at, Lt, Nt);
                                        }, B = (at, Lt, Nt)=>Gt.lookupReturnType(at, Lt, Nt), st = (at)=>Gt.lookupFunctionArgumentTypes(at), rt = (at, Lt)=>Gt.lookupFunctionArgumentName(at, Lt), mt = (at, Lt)=>Gt.lookupFunctionArgumentBitRatio(at, Lt), tt = (at, Lt, Nt, Ht)=>{
                                            Gt.assignArgumentType(at, Lt, Nt, Ht);
                                        }, et = (at, Lt, Nt, Ht)=>{
                                            Gt.assignArgumentBitRatio(at, Lt, Nt, Ht);
                                        }, J = (at, Lt, Nt)=>{
                                            Gt.trackFunctionCall(at, Lt, Nt);
                                        }, yt = (at, Lt)=>{
                                            const Nt = [];
                                            for(let ie = 0; ie < at.params.length; ie++)Nt.push(at.params[ie].name);
                                            const Ht = new l(Lt, Object.assign({}, Pt, {
                                                returnType: null,
                                                ast: at,
                                                name: at.id.name,
                                                argumentNames: Nt,
                                                lookupReturnType: B,
                                                lookupFunctionArgumentTypes: st,
                                                lookupFunctionArgumentName: rt,
                                                lookupFunctionArgumentBitRatio: mt,
                                                needsArgumentType: it,
                                                assignArgumentType: q,
                                                triggerImplyArgumentType: tt,
                                                triggerImplyArgumentBitRatio: et,
                                                onFunctionCall: J
                                            }));
                                            Ht.traceFunctionAST(at), Gt.addFunctionNode(Ht);
                                        }, Pt = Object.assign({
                                            isRootKernel: !1,
                                            onNestedFunction: yt,
                                            lookupReturnType: B,
                                            lookupFunctionArgumentTypes: st,
                                            lookupFunctionArgumentName: rt,
                                            lookupFunctionArgumentBitRatio: mt,
                                            needsArgumentType: it,
                                            assignArgumentType: q,
                                            triggerImplyArgumentType: tt,
                                            triggerImplyArgumentBitRatio: et,
                                            onFunctionCall: J,
                                            optimizeFloatMemory: k,
                                            precision: C,
                                            constants: E,
                                            constantTypes: U,
                                            constantBitRatios: w,
                                            debug: v,
                                            loopMaxIterations: y,
                                            output: _,
                                            plugins: M,
                                            dynamicArguments: O,
                                            dynamicOutput: R
                                        }, a || {}), pt = Object.assign({}, Pt, {
                                            isRootKernel: !0,
                                            name: "kernel",
                                            argumentNames: r,
                                            argumentTypes: G,
                                            argumentSizes: m,
                                            argumentBitRatios: b,
                                            leadingReturnStatement: A,
                                            followingReturnStatement: P
                                        });
                                        if (typeof x == "object" && x.functionNodes) return new u().fromJSON(x.functionNodes, l);
                                        const _t = new l(x, pt);
                                        let Dt = null;
                                        I && (Dt = I.map((at)=>new l(at.source, {
                                                returnType: at.returnType,
                                                argumentTypes: at.argumentTypes,
                                                output: _,
                                                plugins: M,
                                                constants: E,
                                                constantTypes: U,
                                                constantBitRatios: w,
                                                optimizeFloatMemory: k,
                                                precision: C,
                                                lookupReturnType: B,
                                                lookupFunctionArgumentTypes: st,
                                                lookupFunctionArgumentName: rt,
                                                lookupFunctionArgumentBitRatio: mt,
                                                needsArgumentType: it,
                                                assignArgumentType: q,
                                                triggerImplyArgumentType: tt,
                                                triggerImplyArgumentBitRatio: et,
                                                onFunctionCall: J,
                                                onNestedFunction: yt
                                            })));
                                        let Ut = null;
                                        g && (Ut = g.map((at)=>{
                                            const { name: Lt, source: Nt } = at;
                                            return new l(Nt, Object.assign({}, Pt, {
                                                name: Lt,
                                                isSubKernel: !0,
                                                isRootKernel: !1
                                            }));
                                        }));
                                        const Gt = new u({
                                            kernel: d,
                                            rootNode: _t,
                                            functionNodes: Dt,
                                            nativeFunctions: T,
                                            subKernelNodes: Ut
                                        });
                                        return Gt;
                                    }
                                    constructor(d){
                                        if (d = d || {}, this.kernel = d.kernel, this.rootNode = d.rootNode, this.functionNodes = d.functionNodes || [], this.subKernelNodes = d.subKernelNodes || [], this.nativeFunctions = d.nativeFunctions || [], this.functionMap = {}, this.nativeFunctionNames = [], this.lookupChain = [], this.functionNodeDependencies = {}, this.functionCalls = {}, this.rootNode && (this.functionMap.kernel = this.rootNode), this.functionNodes) for(let l = 0; l < this.functionNodes.length; l++)this.functionMap[this.functionNodes[l].name] = this.functionNodes[l];
                                        if (this.subKernelNodes) for(let l = 0; l < this.subKernelNodes.length; l++)this.functionMap[this.subKernelNodes[l].name] = this.subKernelNodes[l];
                                        if (this.nativeFunctions) for(let l = 0; l < this.nativeFunctions.length; l++){
                                            const a = this.nativeFunctions[l];
                                            this.nativeFunctionNames.push(a.name);
                                        }
                                    }
                                    addFunctionNode(d) {
                                        if (!d.name) throw new Error("functionNode.name needs set");
                                        this.functionMap[d.name] = d, d.isRootKernel && (this.rootNode = d);
                                    }
                                    traceFunctionCalls(d, l) {
                                        if (d = d || "kernel", l = l || [], this.nativeFunctionNames.indexOf(d) > -1) {
                                            const o = l.indexOf(d);
                                            if (o === -1) l.push(d);
                                            else {
                                                const n = l.splice(o, 1)[0];
                                                l.push(n);
                                            }
                                            return l;
                                        }
                                        const a = this.functionMap[d];
                                        if (a) {
                                            const o = l.indexOf(d);
                                            if (o === -1) {
                                                l.push(d), a.toString();
                                                for(let n = 0; n < a.calledFunctions.length; ++n)this.traceFunctionCalls(a.calledFunctions[n], l);
                                            } else {
                                                const n = l.splice(o, 1)[0];
                                                l.push(n);
                                            }
                                        }
                                        return l;
                                    }
                                    getPrototypeString(d) {
                                        return this.getPrototypes(d).join(`
`);
                                    }
                                    getPrototypes(d) {
                                        return this.rootNode && this.rootNode.toString(), d ? this.getPrototypesFromFunctionNames(this.traceFunctionCalls(d, []).reverse()) : this.getPrototypesFromFunctionNames(Object.keys(this.functionMap));
                                    }
                                    getStringFromFunctionNames(d) {
                                        const l = [];
                                        for(let a = 0; a < d.length; ++a)this.functionMap[d[a]] && l.push(this.functionMap[d[a]].toString());
                                        return l.join(`
`);
                                    }
                                    getPrototypesFromFunctionNames(d) {
                                        const l = [];
                                        for(let a = 0; a < d.length; ++a){
                                            const o = d[a], n = this.nativeFunctionNames.indexOf(o);
                                            if (n > -1) {
                                                l.push(this.nativeFunctions[n].source);
                                                continue;
                                            }
                                            const r = this.functionMap[o];
                                            r && l.push(r.toString());
                                        }
                                        return l;
                                    }
                                    toJSON() {
                                        return this.traceFunctionCalls(this.rootNode.name).reverse().map((d)=>{
                                            const l = this.nativeFunctions.indexOf(d);
                                            if (l > -1) return {
                                                name: d,
                                                source: this.nativeFunctions[l].source
                                            };
                                            if (this.functionMap[d]) return this.functionMap[d].toJSON();
                                            throw new Error(`function ${d} not found`);
                                        });
                                    }
                                    fromJSON(d, l) {
                                        this.functionMap = {};
                                        for(let a = 0; a < d.length; a++){
                                            const o = d[a];
                                            this.functionMap[o.settings.name] = new l(o.ast, o.settings);
                                        }
                                        return this;
                                    }
                                    getString(d) {
                                        return d ? this.getStringFromFunctionNames(this.traceFunctionCalls(d).reverse()) : this.getStringFromFunctionNames(Object.keys(this.functionMap));
                                    }
                                    lookupReturnType(d, l, a) {
                                        if (l.type !== "CallExpression") throw new Error(`expected ast type of "CallExpression", but is ${l.type}`);
                                        if (this._isNativeFunction(d)) return this._lookupNativeFunctionReturnType(d);
                                        if (this._isFunction(d)) {
                                            const o = this._getFunction(d);
                                            if (o.returnType) return o.returnType;
                                            {
                                                for(let r = 0; r < this.lookupChain.length; r++)if (this.lookupChain[r].ast === l) {
                                                    if (o.argumentTypes.length === 0 && l.arguments.length > 0) {
                                                        const m = l.arguments;
                                                        for(let b = 0; b < m.length; b++)this.lookupChain.push({
                                                            name: a.name,
                                                            ast: m[r],
                                                            requestingNode: a
                                                        }), o.argumentTypes[b] = a.getType(m[b]), this.lookupChain.pop();
                                                        return o.returnType = o.getType(o.getJsAST());
                                                    }
                                                    throw new Error("circlical logic detected!");
                                                }
                                                this.lookupChain.push({
                                                    name: a.name,
                                                    ast: l,
                                                    requestingNode: a
                                                });
                                                const n = o.getType(o.getJsAST());
                                                return this.lookupChain.pop(), o.returnType = n;
                                            }
                                        }
                                        return null;
                                    }
                                    _getFunction(d) {
                                        return this._isFunction(d), this.functionMap[d];
                                    }
                                    _isFunction(d) {
                                        return !!this.functionMap[d];
                                    }
                                    _getNativeFunction(d) {
                                        for(let l = 0; l < this.nativeFunctions.length; l++)if (this.nativeFunctions[l].name === d) return this.nativeFunctions[l];
                                        return null;
                                    }
                                    _isNativeFunction(d) {
                                        return !!this._getNativeFunction(d);
                                    }
                                    _lookupNativeFunctionReturnType(d) {
                                        let l = this._getNativeFunction(d);
                                        if (l) return l.returnType;
                                        throw new Error(`Native function ${d} not found`);
                                    }
                                    lookupFunctionArgumentTypes(d) {
                                        return this._isNativeFunction(d) ? this._getNativeFunction(d).argumentTypes : this._isFunction(d) ? this._getFunction(d).argumentTypes : null;
                                    }
                                    lookupFunctionArgumentName(d, l) {
                                        return this._getFunction(d).argumentNames[l];
                                    }
                                    lookupFunctionArgumentBitRatio(d, l) {
                                        if (!this._isFunction(d)) throw new Error("function not found");
                                        if (this.rootNode.name === d) {
                                            const r = this.rootNode.argumentNames.indexOf(l);
                                            if (r !== -1) return this.rootNode.argumentBitRatios[r];
                                        }
                                        const a = this._getFunction(d), o = a.argumentNames.indexOf(l);
                                        if (o === -1) throw new Error("argument not found");
                                        const n = a.argumentBitRatios[o];
                                        if (typeof n != "number") throw new Error("argument bit ratio not found");
                                        return n;
                                    }
                                    needsArgumentType(d, l) {
                                        return this._isFunction(d) ? !this._getFunction(d).argumentTypes[l] : !1;
                                    }
                                    assignArgumentType(d, l, a, o) {
                                        if (!this._isFunction(d)) return;
                                        const n = this._getFunction(d);
                                        n.argumentTypes[l] || (n.argumentTypes[l] = a);
                                    }
                                    assignArgumentBitRatio(d, l, a, o) {
                                        const n = this._getFunction(d);
                                        if (this._isNativeFunction(a)) return null;
                                        const r = this._getFunction(a), m = n.argumentNames.indexOf(l);
                                        if (m === -1) throw new Error(`Argument ${l} not found in arguments from function ${d}`);
                                        const b = n.argumentBitRatios[m];
                                        if (typeof b != "number") throw new Error(`Bit ratio for argument ${l} not found in function ${d}`);
                                        r.argumentBitRatios || (r.argumentBitRatios = new Array(r.argumentNames.length));
                                        const E = r.argumentBitRatios[m];
                                        if (typeof E == "number") {
                                            if (E !== b) throw new Error(`Incompatible bit ratio found at function ${d} at argument ${l}`);
                                            return E;
                                        }
                                        return r.argumentBitRatios[m] = b, b;
                                    }
                                    trackFunctionCall(d, l, a) {
                                        this.functionNodeDependencies[d] || (this.functionNodeDependencies[d] = new Set, this.functionCalls[d] = []), this.functionNodeDependencies[d].add(l), this.functionCalls[d].push(a);
                                    }
                                    getKernelResultType() {
                                        return this.rootNode.returnType || this.rootNode.getType(this.rootNode.ast);
                                    }
                                    getSubKernelResultType(d) {
                                        const l = this.subKernelNodes[d];
                                        let a = !1;
                                        for(let o = 0; o < this.rootNode.functionCalls.length; o++)this.rootNode.functionCalls[o].ast.callee.name === l.name && (a = !0);
                                        if (!a) throw new Error(`SubKernel ${l.name} never called by kernel`);
                                        return l.returnType || l.getType(l.getJsAST());
                                    }
                                    getReturnTypes() {
                                        const d = {
                                            [this.rootNode.name]: this.rootNode.getType(this.rootNode.ast)
                                        }, l = this.traceFunctionCalls(this.rootNode.name);
                                        for(let a = 0; a < l.length; a++){
                                            const o = l[a], n = this.functionMap[o];
                                            d[o] = n.getType(n.ast);
                                        }
                                        return d;
                                    }
                                }
                                i.exports = {
                                    FunctionBuilder: u
                                };
                            },
                            {}
                        ],
                        10: [
                            function(e, i, h) {
                                const u = e("acorn"), { utils: p } = e("../utils"), { FunctionTracer: d } = e("./function-tracer");
                                class l {
                                    constructor(n, r){
                                        if (!n && !r.ast) throw new Error("source parameter is missing");
                                        if (r = r || {}, this.source = n, this.ast = null, this.name = typeof n == "string" ? r.isRootKernel ? "kernel" : r.name || p.getFunctionNameFromString(n) : null, this.calledFunctions = [], this.constants = {}, this.constantTypes = {}, this.constantBitRatios = {}, this.isRootKernel = !1, this.isSubKernel = !1, this.debug = null, this.functions = null, this.identifiers = null, this.contexts = null, this.functionCalls = null, this.states = [], this.needsArgumentType = null, this.assignArgumentType = null, this.lookupReturnType = null, this.lookupFunctionArgumentTypes = null, this.lookupFunctionArgumentBitRatio = null, this.triggerImplyArgumentType = null, this.triggerImplyArgumentBitRatio = null, this.onNestedFunction = null, this.onFunctionCall = null, this.optimizeFloatMemory = null, this.precision = null, this.loopMaxIterations = null, this.argumentNames = typeof this.source == "string" ? p.getArgumentNamesFromString(this.source) : null, this.argumentTypes = [], this.argumentSizes = [], this.argumentBitRatios = null, this.returnType = null, this.output = [], this.plugins = null, this.leadingReturnStatement = null, this.followingReturnStatement = null, this.dynamicOutput = null, this.dynamicArguments = null, this.strictTypingChecking = !1, this.fixIntegerDivisionAccuracy = null, r) for(const m in r)r.hasOwnProperty(m) && this.hasOwnProperty(m) && (this[m] = r[m]);
                                        this.literalTypes = {}, this.validate(), this._string = null, this._internalVariableNames = {};
                                    }
                                    validate() {
                                        if (typeof this.source != "string" && !this.ast) throw new Error("this.source not a string");
                                        if (!this.ast && !p.isFunctionString(this.source)) throw new Error("this.source not a function string");
                                        if (!this.name) throw new Error("this.name could not be set");
                                        if (this.argumentTypes.length > 0 && this.argumentTypes.length !== this.argumentNames.length) throw new Error(`argumentTypes count of ${this.argumentTypes.length} exceeds ${this.argumentNames.length}`);
                                        if (this.output.length < 1) throw new Error("this.output is not big enough");
                                    }
                                    isIdentifierConstant(n) {
                                        return this.constants ? this.constants.hasOwnProperty(n) : !1;
                                    }
                                    isInput(n) {
                                        return this.argumentTypes[this.argumentNames.indexOf(n)] === "Input";
                                    }
                                    pushState(n) {
                                        this.states.push(n);
                                    }
                                    popState(n) {
                                        if (this.state !== n) throw new Error(`Cannot popState ${n} when in ${this.state}`);
                                        this.states.pop();
                                    }
                                    isState(n) {
                                        return this.state === n;
                                    }
                                    get state() {
                                        return this.states[this.states.length - 1];
                                    }
                                    astMemberExpressionUnroll(n) {
                                        if (n.type === "Identifier") return n.name;
                                        if (n.type === "ThisExpression") return "this";
                                        if (n.type === "MemberExpression" && n.object && n.property) return n.object.hasOwnProperty("name") && n.object.name !== "Math" ? this.astMemberExpressionUnroll(n.property) : this.astMemberExpressionUnroll(n.object) + "." + this.astMemberExpressionUnroll(n.property);
                                        if (n.hasOwnProperty("expressions")) {
                                            const r = n.expressions[0];
                                            if (r.type === "Literal" && r.value === 0 && n.expressions.length === 2) return this.astMemberExpressionUnroll(n.expressions[1]);
                                        }
                                        throw this.astErrorOutput("Unknown astMemberExpressionUnroll", n);
                                    }
                                    getJsAST(n) {
                                        if (this.ast) return this.ast;
                                        if (typeof this.source == "object") return this.traceFunctionAST(this.source), this.ast = this.source;
                                        if (n = n || u, n === null) throw new Error("Missing JS to AST parser");
                                        const r = Object.freeze(n.parse(`const parser_${this.name} = ${this.source};`, {
                                            locations: !0
                                        })), m = r.body[0].declarations[0].init;
                                        if (this.traceFunctionAST(m), !r) throw new Error("Failed to parse JS code");
                                        return this.ast = m;
                                    }
                                    traceFunctionAST(n) {
                                        const { contexts: r, declarations: m, functions: b, identifiers: E, functionCalls: w } = new d(n);
                                        this.contexts = r, this.identifiers = E, this.functionCalls = w, this.functions = b;
                                        for(let v = 0; v < m.length; v++){
                                            const y = m[v], { ast: T, inForLoopInit: _, inForLoopTest: k } = y, { init: C } = T, M = this.getDependencies(C);
                                            let x = null;
                                            if (_ && k) x = "Integer";
                                            else if (C) {
                                                const g = this.getType(C);
                                                switch(g){
                                                    case "Integer":
                                                    case "Float":
                                                    case "Number":
                                                        C.type === "MemberExpression" ? x = g : x = "Number";
                                                        break;
                                                    case "LiteralInteger":
                                                        x = "Number";
                                                        break;
                                                    default:
                                                        x = g;
                                                }
                                            }
                                            y.valueType = x, y.dependencies = M, y.isSafe = this.isSafeDependencies(M);
                                        }
                                        for(let v = 0; v < b.length; v++)this.onNestedFunction(b[v], this.source);
                                    }
                                    getDeclaration(n) {
                                        for(let r = 0; r < this.identifiers.length; r++){
                                            const m = this.identifiers[r];
                                            if (n === m.ast) return m.declaration;
                                        }
                                        return null;
                                    }
                                    getVariableType(n) {
                                        if (n.type !== "Identifier") throw new Error(`ast of ${n.type} not "Identifier"`);
                                        let r = null;
                                        const m = this.argumentNames.indexOf(n.name);
                                        if (m === -1) {
                                            const b = this.getDeclaration(n);
                                            if (b) return b.valueType;
                                        } else {
                                            const b = this.argumentTypes[m];
                                            b && (r = b);
                                        }
                                        if (!r && this.strictTypingChecking) throw new Error(`Declaration of ${name} not found`);
                                        return r;
                                    }
                                    getLookupType(n) {
                                        if (!a.hasOwnProperty(n)) throw new Error(`unknown typeLookupMap ${n}`);
                                        return a[n];
                                    }
                                    getConstantType(n) {
                                        if (this.constantTypes[n]) {
                                            const r = this.constantTypes[n];
                                            return r === "Float" ? "Number" : r;
                                        }
                                        throw new Error(`Type for constant "${n}" not declared`);
                                    }
                                    toString() {
                                        return this._string ? this._string : this._string = this.astGeneric(this.getJsAST(), []).join("").trim();
                                    }
                                    toJSON() {
                                        const n = {
                                            source: this.source,
                                            name: this.name,
                                            constants: this.constants,
                                            constantTypes: this.constantTypes,
                                            isRootKernel: this.isRootKernel,
                                            isSubKernel: this.isSubKernel,
                                            debug: this.debug,
                                            output: this.output,
                                            loopMaxIterations: this.loopMaxIterations,
                                            argumentNames: this.argumentNames,
                                            argumentTypes: this.argumentTypes,
                                            argumentSizes: this.argumentSizes,
                                            returnType: this.returnType,
                                            leadingReturnStatement: this.leadingReturnStatement,
                                            followingReturnStatement: this.followingReturnStatement
                                        };
                                        return {
                                            ast: this.ast,
                                            settings: n
                                        };
                                    }
                                    getType(n) {
                                        if (Array.isArray(n)) return this.getType(n[n.length - 1]);
                                        switch(n.type){
                                            case "BlockStatement":
                                                return this.getType(n.body);
                                            case "ArrayExpression":
                                                switch(this.getType(n.elements[0])){
                                                    case "Array(2)":
                                                    case "Array(3)":
                                                    case "Array(4)":
                                                        return `Matrix(${n.elements.length})`;
                                                }
                                                return `Array(${n.elements.length})`;
                                            case "Literal":
                                                const m = this.astKey(n);
                                                return this.literalTypes[m] ? this.literalTypes[m] : Number.isInteger(n.value) ? "LiteralInteger" : n.value === !0 || n.value === !1 ? "Boolean" : "Number";
                                            case "AssignmentExpression":
                                                return this.getType(n.left);
                                            case "CallExpression":
                                                if (this.isAstMathFunction(n)) return "Number";
                                                if (!n.callee || !n.callee.name) {
                                                    if (n.callee.type === "SequenceExpression" && n.callee.expressions[n.callee.expressions.length - 1].property.name) {
                                                        const y = n.callee.expressions[n.callee.expressions.length - 1].property.name;
                                                        return this.inferArgumentTypesIfNeeded(y, n.arguments), this.lookupReturnType(y, n, this);
                                                    }
                                                    if (this.getVariableSignature(n.callee, !0) === "this.color") return null;
                                                    if (n.callee.type === "MemberExpression" && n.callee.object && n.callee.property && n.callee.property.name && n.arguments) {
                                                        const y = n.callee.property.name;
                                                        return this.inferArgumentTypesIfNeeded(y, n.arguments), this.lookupReturnType(y, n, this);
                                                    }
                                                    throw this.astErrorOutput("Unknown call expression", n);
                                                }
                                                if (n.callee && n.callee.name) {
                                                    const y = n.callee.name;
                                                    return this.inferArgumentTypesIfNeeded(y, n.arguments), this.lookupReturnType(y, n, this);
                                                }
                                                throw this.astErrorOutput(`Unhandled getType Type "${n.type}"`, n);
                                            case "LogicalExpression":
                                                return "Boolean";
                                            case "BinaryExpression":
                                                switch(n.operator){
                                                    case "%":
                                                    case "/":
                                                        if (this.fixIntegerDivisionAccuracy) return "Number";
                                                        break;
                                                    case ">":
                                                    case "<":
                                                        return "Boolean";
                                                    case "&":
                                                    case "|":
                                                    case "^":
                                                    case "<<":
                                                    case ">>":
                                                    case ">>>":
                                                        return "Integer";
                                                }
                                                const b = this.getType(n.left);
                                                if (this.isState("skip-literal-correction")) return b;
                                                if (b === "LiteralInteger") {
                                                    const y = this.getType(n.right);
                                                    return y === "LiteralInteger" ? n.left.value % 1 === 0 ? "Integer" : "Float" : y;
                                                }
                                                return a[b] || b;
                                            case "UpdateExpression":
                                                return this.getType(n.argument);
                                            case "UnaryExpression":
                                                return n.operator === "~" ? "Integer" : this.getType(n.argument);
                                            case "VariableDeclaration":
                                                {
                                                    const y = n.declarations;
                                                    let T;
                                                    for(let _ = 0; _ < y.length; _++){
                                                        const k = y[_];
                                                        T = this.getType(k);
                                                    }
                                                    if (!T) throw this.astErrorOutput("Unable to find type for declaration", n);
                                                    return T;
                                                }
                                            case "VariableDeclarator":
                                                const E = this.getDeclaration(n.id);
                                                if (!E) throw this.astErrorOutput("Unable to find declarator", n);
                                                if (!E.valueType) throw this.astErrorOutput("Unable to find declarator valueType", n);
                                                return E.valueType;
                                            case "Identifier":
                                                if (n.name === "Infinity") return "Number";
                                                if (this.isAstVariable(n) && this.getVariableSignature(n) === "value") return this.getCheckVariableType(n);
                                                const w = this.findIdentifierOrigin(n);
                                                return w && w.init ? this.getType(w.init) : null;
                                            case "ReturnStatement":
                                                return this.getType(n.argument);
                                            case "MemberExpression":
                                                if (this.isAstMathFunction(n)) {
                                                    switch(n.property.name){
                                                        case "ceil":
                                                            return "Integer";
                                                        case "floor":
                                                            return "Integer";
                                                        case "round":
                                                            return "Integer";
                                                    }
                                                    return "Number";
                                                }
                                                if (this.isAstVariable(n)) {
                                                    switch(this.getVariableSignature(n)){
                                                        case "value[]":
                                                            return this.getLookupType(this.getCheckVariableType(n.object));
                                                        case "value[][]":
                                                            return this.getLookupType(this.getCheckVariableType(n.object.object));
                                                        case "value[][][]":
                                                            return this.getLookupType(this.getCheckVariableType(n.object.object.object));
                                                        case "value[][][][]":
                                                            return this.getLookupType(this.getCheckVariableType(n.object.object.object.object));
                                                        case "value.thread.value":
                                                        case "this.thread.value":
                                                            return "Integer";
                                                        case "this.output.value":
                                                            return this.dynamicOutput ? "Integer" : "LiteralInteger";
                                                        case "this.constants.value":
                                                            return this.getConstantType(n.property.name);
                                                        case "this.constants.value[]":
                                                            return this.getLookupType(this.getConstantType(n.object.property.name));
                                                        case "this.constants.value[][]":
                                                            return this.getLookupType(this.getConstantType(n.object.object.property.name));
                                                        case "this.constants.value[][][]":
                                                            return this.getLookupType(this.getConstantType(n.object.object.object.property.name));
                                                        case "this.constants.value[][][][]":
                                                            return this.getLookupType(this.getConstantType(n.object.object.object.object.property.name));
                                                        case "fn()[]":
                                                        case "fn()[][]":
                                                        case "fn()[][][]":
                                                            return this.getLookupType(this.getType(n.object));
                                                        case "value.value":
                                                            if (this.isAstMathVariable(n)) return "Number";
                                                            switch(n.property.name){
                                                                case "r":
                                                                case "g":
                                                                case "b":
                                                                case "a":
                                                                    return this.getLookupType(this.getCheckVariableType(n.object));
                                                            }
                                                        case "[][]":
                                                            return "Number";
                                                    }
                                                    throw this.astErrorOutput("Unhandled getType MemberExpression", n);
                                                }
                                                throw this.astErrorOutput("Unhandled getType MemberExpression", n);
                                            case "ConditionalExpression":
                                                return this.getType(n.consequent);
                                            case "FunctionDeclaration":
                                            case "FunctionExpression":
                                                const v = this.findLastReturn(n.body);
                                                return v ? this.getType(v) : null;
                                            case "IfStatement":
                                                return this.getType(n.consequent);
                                            case "SequenceExpression":
                                                return this.getType(n.expressions[n.expressions.length - 1]);
                                            default:
                                                throw this.astErrorOutput(`Unhandled getType Type "${n.type}"`, n);
                                        }
                                    }
                                    getCheckVariableType(n) {
                                        const r = this.getVariableType(n);
                                        if (!r) throw this.astErrorOutput(`${n.type} is not defined`, n);
                                        return r;
                                    }
                                    inferArgumentTypesIfNeeded(n, r) {
                                        for(let m = 0; m < r.length; m++){
                                            if (!this.needsArgumentType(n, m)) continue;
                                            const b = this.getType(r[m]);
                                            if (!b) throw this.astErrorOutput(`Unable to infer argument ${m}`, r[m]);
                                            this.assignArgumentType(n, m, b);
                                        }
                                    }
                                    isAstMathVariable(n) {
                                        const r = [
                                            "E",
                                            "PI",
                                            "SQRT2",
                                            "SQRT1_2",
                                            "LN2",
                                            "LN10",
                                            "LOG2E",
                                            "LOG10E"
                                        ];
                                        return n.type === "MemberExpression" && n.object && n.object.type === "Identifier" && n.object.name === "Math" && n.property && n.property.type === "Identifier" && r.indexOf(n.property.name) > -1;
                                    }
                                    isAstMathFunction(n) {
                                        const r = [
                                            "abs",
                                            "acos",
                                            "acosh",
                                            "asin",
                                            "asinh",
                                            "atan",
                                            "atan2",
                                            "atanh",
                                            "cbrt",
                                            "ceil",
                                            "clz32",
                                            "cos",
                                            "cosh",
                                            "expm1",
                                            "exp",
                                            "floor",
                                            "fround",
                                            "imul",
                                            "log",
                                            "log2",
                                            "log10",
                                            "log1p",
                                            "max",
                                            "min",
                                            "pow",
                                            "random",
                                            "round",
                                            "sign",
                                            "sin",
                                            "sinh",
                                            "sqrt",
                                            "tan",
                                            "tanh",
                                            "trunc"
                                        ];
                                        return n.type === "CallExpression" && n.callee && n.callee.type === "MemberExpression" && n.callee.object && n.callee.object.type === "Identifier" && n.callee.object.name === "Math" && n.callee.property && n.callee.property.type === "Identifier" && r.indexOf(n.callee.property.name) > -1;
                                    }
                                    isAstVariable(n) {
                                        return n.type === "Identifier" || n.type === "MemberExpression";
                                    }
                                    isSafe(n) {
                                        return this.isSafeDependencies(this.getDependencies(n));
                                    }
                                    isSafeDependencies(n) {
                                        return n && n.every ? n.every((r)=>r.isSafe) : !0;
                                    }
                                    getDependencies(n, r, m) {
                                        if (r || (r = []), !n) return null;
                                        if (Array.isArray(n)) {
                                            for(let b = 0; b < n.length; b++)this.getDependencies(n[b], r, m);
                                            return r;
                                        }
                                        switch(n.type){
                                            case "AssignmentExpression":
                                                return this.getDependencies(n.left, r, m), this.getDependencies(n.right, r, m), r;
                                            case "ConditionalExpression":
                                                return this.getDependencies(n.test, r, m), this.getDependencies(n.alternate, r, m), this.getDependencies(n.consequent, r, m), r;
                                            case "Literal":
                                                r.push({
                                                    origin: "literal",
                                                    value: n.value,
                                                    isSafe: m === !0 ? !1 : n.value > -1 / 0 && n.value < 1 / 0 && !isNaN(n.value)
                                                });
                                                break;
                                            case "VariableDeclarator":
                                                return this.getDependencies(n.init, r, m);
                                            case "Identifier":
                                                const b = this.getDeclaration(n);
                                                if (b) r.push({
                                                    name: n.name,
                                                    origin: "declaration",
                                                    isSafe: m ? !1 : this.isSafeDependencies(b.dependencies)
                                                });
                                                else if (this.argumentNames.indexOf(n.name) > -1) r.push({
                                                    name: n.name,
                                                    origin: "argument",
                                                    isSafe: !1
                                                });
                                                else if (this.strictTypingChecking) throw new Error(`Cannot find identifier origin "${n.name}"`);
                                                break;
                                            case "FunctionDeclaration":
                                                return this.getDependencies(n.body.body[n.body.body.length - 1], r, m);
                                            case "ReturnStatement":
                                                return this.getDependencies(n.argument, r);
                                            case "BinaryExpression":
                                            case "LogicalExpression":
                                                return m = n.operator === "/" || n.operator === "*", this.getDependencies(n.left, r, m), this.getDependencies(n.right, r, m), r;
                                            case "UnaryExpression":
                                            case "UpdateExpression":
                                                return this.getDependencies(n.argument, r, m);
                                            case "VariableDeclaration":
                                                return this.getDependencies(n.declarations, r, m);
                                            case "ArrayExpression":
                                                return r.push({
                                                    origin: "declaration",
                                                    isSafe: !0
                                                }), r;
                                            case "CallExpression":
                                                return r.push({
                                                    origin: "function",
                                                    isSafe: !0
                                                }), r;
                                            case "MemberExpression":
                                                const E = this.getMemberExpressionDetails(n);
                                                switch(E.signature){
                                                    case "value[]":
                                                        this.getDependencies(n.object, r, m);
                                                        break;
                                                    case "value[][]":
                                                        this.getDependencies(n.object.object, r, m);
                                                        break;
                                                    case "value[][][]":
                                                        this.getDependencies(n.object.object.object, r, m);
                                                        break;
                                                    case "this.output.value":
                                                        this.dynamicOutput && r.push({
                                                            name: E.name,
                                                            origin: "output",
                                                            isSafe: !1
                                                        });
                                                        break;
                                                }
                                                if (E) return E.property && this.getDependencies(E.property, r, m), E.xProperty && this.getDependencies(E.xProperty, r, m), E.yProperty && this.getDependencies(E.yProperty, r, m), E.zProperty && this.getDependencies(E.zProperty, r, m), r;
                                            case "SequenceExpression":
                                                return this.getDependencies(n.expressions, r, m);
                                            default:
                                                throw this.astErrorOutput(`Unhandled type ${n.type} in getDependencies`, n);
                                        }
                                        return r;
                                    }
                                    getVariableSignature(n, r) {
                                        if (!this.isAstVariable(n)) throw new Error(`ast of type "${n.type}" is not a variable signature`);
                                        if (n.type === "Identifier") return "value";
                                        const m = [];
                                        for(; n;)n.computed ? m.push("[]") : n.type === "ThisExpression" ? m.unshift("this") : n.property && n.property.name ? n.property.name === "x" || n.property.name === "y" || n.property.name === "z" ? m.unshift(r ? "." + n.property.name : ".value") : n.property.name === "constants" || n.property.name === "thread" || n.property.name === "output" ? m.unshift("." + n.property.name) : m.unshift(r ? "." + n.property.name : ".value") : n.name ? m.unshift(r ? n.name : "value") : n.callee && n.callee.name ? m.unshift(r ? n.callee.name + "()" : "fn()") : n.elements ? m.unshift("[]") : m.unshift("unknown"), n = n.object;
                                        const b = m.join("");
                                        return r || [
                                            "value",
                                            "value[]",
                                            "value[][]",
                                            "value[][][]",
                                            "value[][][][]",
                                            "value.value",
                                            "value.thread.value",
                                            "this.thread.value",
                                            "this.output.value",
                                            "this.constants.value",
                                            "this.constants.value[]",
                                            "this.constants.value[][]",
                                            "this.constants.value[][][]",
                                            "this.constants.value[][][][]",
                                            "fn()[]",
                                            "fn()[][]",
                                            "fn()[][][]",
                                            "[][]"
                                        ].indexOf(b) > -1 ? b : null;
                                    }
                                    build() {
                                        return this.toString().length > 0;
                                    }
                                    astGeneric(n, r) {
                                        if (n === null) throw this.astErrorOutput("NULL ast", n);
                                        if (Array.isArray(n)) {
                                            for(let m = 0; m < n.length; m++)this.astGeneric(n[m], r);
                                            return r;
                                        }
                                        switch(n.type){
                                            case "FunctionDeclaration":
                                                return this.astFunctionDeclaration(n, r);
                                            case "FunctionExpression":
                                                return this.astFunctionExpression(n, r);
                                            case "ReturnStatement":
                                                return this.astReturnStatement(n, r);
                                            case "Literal":
                                                return this.astLiteral(n, r);
                                            case "BinaryExpression":
                                                return this.astBinaryExpression(n, r);
                                            case "Identifier":
                                                return this.astIdentifierExpression(n, r);
                                            case "AssignmentExpression":
                                                return this.astAssignmentExpression(n, r);
                                            case "ExpressionStatement":
                                                return this.astExpressionStatement(n, r);
                                            case "EmptyStatement":
                                                return this.astEmptyStatement(n, r);
                                            case "BlockStatement":
                                                return this.astBlockStatement(n, r);
                                            case "IfStatement":
                                                return this.astIfStatement(n, r);
                                            case "SwitchStatement":
                                                return this.astSwitchStatement(n, r);
                                            case "BreakStatement":
                                                return this.astBreakStatement(n, r);
                                            case "ContinueStatement":
                                                return this.astContinueStatement(n, r);
                                            case "ForStatement":
                                                return this.astForStatement(n, r);
                                            case "WhileStatement":
                                                return this.astWhileStatement(n, r);
                                            case "DoWhileStatement":
                                                return this.astDoWhileStatement(n, r);
                                            case "VariableDeclaration":
                                                return this.astVariableDeclaration(n, r);
                                            case "VariableDeclarator":
                                                return this.astVariableDeclarator(n, r);
                                            case "ThisExpression":
                                                return this.astThisExpression(n, r);
                                            case "SequenceExpression":
                                                return this.astSequenceExpression(n, r);
                                            case "UnaryExpression":
                                                return this.astUnaryExpression(n, r);
                                            case "UpdateExpression":
                                                return this.astUpdateExpression(n, r);
                                            case "LogicalExpression":
                                                return this.astLogicalExpression(n, r);
                                            case "MemberExpression":
                                                return this.astMemberExpression(n, r);
                                            case "CallExpression":
                                                return this.astCallExpression(n, r);
                                            case "ArrayExpression":
                                                return this.astArrayExpression(n, r);
                                            case "DebuggerStatement":
                                                return this.astDebuggerStatement(n, r);
                                            case "ConditionalExpression":
                                                return this.astConditionalExpression(n, r);
                                        }
                                        throw this.astErrorOutput("Unknown ast type : " + n.type, n);
                                    }
                                    astErrorOutput(n, r) {
                                        if (typeof this.source != "string") return new Error(n);
                                        const m = p.getAstString(this.source, r), E = this.source.substr(r.start).split(/\n/), w = E.length > 0 ? E[E.length - 1] : 0;
                                        return new Error(`${n} on line ${E.length}, position ${w.length}:
 ${m}`);
                                    }
                                    astDebuggerStatement(n, r) {
                                        return r;
                                    }
                                    astConditionalExpression(n, r) {
                                        if (n.type !== "ConditionalExpression") throw this.astErrorOutput("Not a conditional expression", n);
                                        return r.push("("), this.astGeneric(n.test, r), r.push("?"), this.astGeneric(n.consequent, r), r.push(":"), this.astGeneric(n.alternate, r), r.push(")"), r;
                                    }
                                    astFunction(n, r) {
                                        throw new Error(`"astFunction" not defined on ${this.constructor.name}`);
                                    }
                                    astFunctionDeclaration(n, r) {
                                        return this.isChildFunction(n) ? r : this.astFunction(n, r);
                                    }
                                    astFunctionExpression(n, r) {
                                        return this.isChildFunction(n) ? r : this.astFunction(n, r);
                                    }
                                    isChildFunction(n) {
                                        for(let r = 0; r < this.functions.length; r++)if (this.functions[r] === n) return !0;
                                        return !1;
                                    }
                                    astReturnStatement(n, r) {
                                        return r;
                                    }
                                    astLiteral(n, r) {
                                        return this.literalTypes[this.astKey(n)] = "Number", r;
                                    }
                                    astBinaryExpression(n, r) {
                                        return r;
                                    }
                                    astIdentifierExpression(n, r) {
                                        return r;
                                    }
                                    astAssignmentExpression(n, r) {
                                        return r;
                                    }
                                    astExpressionStatement(n, r) {
                                        return this.astGeneric(n.expression, r), r.push(";"), r;
                                    }
                                    astEmptyStatement(n, r) {
                                        return r;
                                    }
                                    astBlockStatement(n, r) {
                                        return r;
                                    }
                                    astIfStatement(n, r) {
                                        return r;
                                    }
                                    astSwitchStatement(n, r) {
                                        return r;
                                    }
                                    astBreakStatement(n, r) {
                                        return r.push("break;"), r;
                                    }
                                    astContinueStatement(n, r) {
                                        return r.push(`continue;
`), r;
                                    }
                                    astForStatement(n, r) {
                                        return r;
                                    }
                                    astWhileStatement(n, r) {
                                        return r;
                                    }
                                    astDoWhileStatement(n, r) {
                                        return r;
                                    }
                                    astVariableDeclarator(n, r) {
                                        return this.astGeneric(n.id, r), n.init !== null && (r.push("="), this.astGeneric(n.init, r)), r;
                                    }
                                    astThisExpression(n, r) {
                                        return r;
                                    }
                                    astSequenceExpression(n, r) {
                                        const { expressions: m } = n, b = [];
                                        for(let E = 0; E < m.length; E++){
                                            const w = m[E], v = [];
                                            this.astGeneric(w, v), b.push(v.join(""));
                                        }
                                        return b.length > 1 ? r.push("(", b.join(","), ")") : r.push(b[0]), r;
                                    }
                                    astUnaryExpression(n, r) {
                                        return this.checkAndUpconvertBitwiseUnary(n, r) || (n.prefix ? (r.push(n.operator), this.astGeneric(n.argument, r)) : (this.astGeneric(n.argument, r), r.push(n.operator))), r;
                                    }
                                    checkAndUpconvertBitwiseUnary(n, r) {}
                                    astUpdateExpression(n, r) {
                                        return n.prefix ? (r.push(n.operator), this.astGeneric(n.argument, r)) : (this.astGeneric(n.argument, r), r.push(n.operator)), r;
                                    }
                                    astLogicalExpression(n, r) {
                                        return r.push("("), this.astGeneric(n.left, r), r.push(n.operator), this.astGeneric(n.right, r), r.push(")"), r;
                                    }
                                    astMemberExpression(n, r) {
                                        return r;
                                    }
                                    astCallExpression(n, r) {
                                        return r;
                                    }
                                    astArrayExpression(n, r) {
                                        return r;
                                    }
                                    getMemberExpressionDetails(n) {
                                        if (n.type !== "MemberExpression") throw this.astErrorOutput(`Expression ${n.type} not a MemberExpression`, n);
                                        let r = null, m = null;
                                        const b = this.getVariableSignature(n);
                                        switch(b){
                                            case "value":
                                                return null;
                                            case "value.thread.value":
                                            case "this.thread.value":
                                            case "this.output.value":
                                                return {
                                                    signature: b,
                                                    type: "Integer",
                                                    name: n.property.name
                                                };
                                            case "value[]":
                                                if (typeof n.object.name != "string") throw this.astErrorOutput("Unexpected expression", n);
                                                return r = n.object.name, {
                                                    name: r,
                                                    origin: "user",
                                                    signature: b,
                                                    type: this.getVariableType(n.object),
                                                    xProperty: n.property
                                                };
                                            case "value[][]":
                                                if (typeof n.object.object.name != "string") throw this.astErrorOutput("Unexpected expression", n);
                                                return r = n.object.object.name, {
                                                    name: r,
                                                    origin: "user",
                                                    signature: b,
                                                    type: this.getVariableType(n.object.object),
                                                    yProperty: n.object.property,
                                                    xProperty: n.property
                                                };
                                            case "value[][][]":
                                                if (typeof n.object.object.object.name != "string") throw this.astErrorOutput("Unexpected expression", n);
                                                return r = n.object.object.object.name, {
                                                    name: r,
                                                    origin: "user",
                                                    signature: b,
                                                    type: this.getVariableType(n.object.object.object),
                                                    zProperty: n.object.object.property,
                                                    yProperty: n.object.property,
                                                    xProperty: n.property
                                                };
                                            case "value[][][][]":
                                                if (typeof n.object.object.object.object.name != "string") throw this.astErrorOutput("Unexpected expression", n);
                                                return r = n.object.object.object.object.name, {
                                                    name: r,
                                                    origin: "user",
                                                    signature: b,
                                                    type: this.getVariableType(n.object.object.object.object),
                                                    zProperty: n.object.object.property,
                                                    yProperty: n.object.property,
                                                    xProperty: n.property
                                                };
                                            case "value.value":
                                                if (typeof n.property.name != "string") throw this.astErrorOutput("Unexpected expression", n);
                                                if (this.isAstMathVariable(n)) return r = n.property.name, {
                                                    name: r,
                                                    origin: "Math",
                                                    type: "Number",
                                                    signature: b
                                                };
                                                switch(n.property.name){
                                                    case "r":
                                                    case "g":
                                                    case "b":
                                                    case "a":
                                                        return r = n.object.name, {
                                                            name: r,
                                                            property: n.property.name,
                                                            origin: "user",
                                                            signature: b,
                                                            type: "Number"
                                                        };
                                                    default:
                                                        throw this.astErrorOutput("Unexpected expression", n);
                                                }
                                            case "this.constants.value":
                                                if (typeof n.property.name != "string") throw this.astErrorOutput("Unexpected expression", n);
                                                if (r = n.property.name, m = this.getConstantType(r), !m) throw this.astErrorOutput("Constant has no type", n);
                                                return {
                                                    name: r,
                                                    type: m,
                                                    origin: "constants",
                                                    signature: b
                                                };
                                            case "this.constants.value[]":
                                                if (typeof n.object.property.name != "string") throw this.astErrorOutput("Unexpected expression", n);
                                                if (r = n.object.property.name, m = this.getConstantType(r), !m) throw this.astErrorOutput("Constant has no type", n);
                                                return {
                                                    name: r,
                                                    type: m,
                                                    origin: "constants",
                                                    signature: b,
                                                    xProperty: n.property
                                                };
                                            case "this.constants.value[][]":
                                                {
                                                    if (typeof n.object.object.property.name != "string") throw this.astErrorOutput("Unexpected expression", n);
                                                    if (r = n.object.object.property.name, m = this.getConstantType(r), !m) throw this.astErrorOutput("Constant has no type", n);
                                                    return {
                                                        name: r,
                                                        type: m,
                                                        origin: "constants",
                                                        signature: b,
                                                        yProperty: n.object.property,
                                                        xProperty: n.property
                                                    };
                                                }
                                            case "this.constants.value[][][]":
                                                {
                                                    if (typeof n.object.object.object.property.name != "string") throw this.astErrorOutput("Unexpected expression", n);
                                                    if (r = n.object.object.object.property.name, m = this.getConstantType(r), !m) throw this.astErrorOutput("Constant has no type", n);
                                                    return {
                                                        name: r,
                                                        type: m,
                                                        origin: "constants",
                                                        signature: b,
                                                        zProperty: n.object.object.property,
                                                        yProperty: n.object.property,
                                                        xProperty: n.property
                                                    };
                                                }
                                            case "fn()[]":
                                            case "fn()[][]":
                                            case "[][]":
                                                return {
                                                    signature: b,
                                                    property: n.property
                                                };
                                            default:
                                                throw this.astErrorOutput("Unexpected expression", n);
                                        }
                                    }
                                    findIdentifierOrigin(n) {
                                        const r = [
                                            this.ast
                                        ];
                                        for(; r.length > 0;){
                                            const m = r[0];
                                            if (m.type === "VariableDeclarator" && m.id && m.id.name && m.id.name === n.name) return m;
                                            if (r.shift(), m.argument) r.push(m.argument);
                                            else if (m.body) r.push(m.body);
                                            else if (m.declarations) r.push(m.declarations);
                                            else if (Array.isArray(m)) for(let b = 0; b < m.length; b++)r.push(m[b]);
                                        }
                                        return null;
                                    }
                                    findLastReturn(n) {
                                        const r = [
                                            n || this.ast
                                        ];
                                        for(; r.length > 0;){
                                            const m = r.pop();
                                            if (m.type === "ReturnStatement") return m;
                                            if (m.type !== "FunctionDeclaration") if (m.argument) r.push(m.argument);
                                            else if (m.body) r.push(m.body);
                                            else if (m.declarations) r.push(m.declarations);
                                            else if (Array.isArray(m)) for(let b = 0; b < m.length; b++)r.push(m[b]);
                                            else m.consequent ? r.push(m.consequent) : m.cases && r.push(m.cases);
                                        }
                                        return null;
                                    }
                                    getInternalVariableName(n) {
                                        return this._internalVariableNames.hasOwnProperty(n) || (this._internalVariableNames[n] = 0), this._internalVariableNames[n]++, this._internalVariableNames[n] === 1 ? n : n + this._internalVariableNames[n];
                                    }
                                    astKey(n, r = ",") {
                                        if (!n.start || !n.end) throw new Error("AST start and end needed");
                                        return `${n.start}${r}${n.end}`;
                                    }
                                }
                                const a = {
                                    Number: "Number",
                                    Float: "Float",
                                    Integer: "Integer",
                                    Array: "Number",
                                    "Array(2)": "Number",
                                    "Array(3)": "Number",
                                    "Array(4)": "Number",
                                    "Matrix(2)": "Number",
                                    "Matrix(3)": "Number",
                                    "Matrix(4)": "Number",
                                    Array2D: "Number",
                                    Array3D: "Number",
                                    Input: "Number",
                                    HTMLCanvas: "Array(4)",
                                    OffscreenCanvas: "Array(4)",
                                    HTMLImage: "Array(4)",
                                    ImageBitmap: "Array(4)",
                                    ImageData: "Array(4)",
                                    HTMLVideo: "Array(4)",
                                    HTMLImageArray: "Array(4)",
                                    NumberTexture: "Number",
                                    MemoryOptimizedNumberTexture: "Number",
                                    "Array1D(2)": "Array(2)",
                                    "Array1D(3)": "Array(3)",
                                    "Array1D(4)": "Array(4)",
                                    "Array2D(2)": "Array(2)",
                                    "Array2D(3)": "Array(3)",
                                    "Array2D(4)": "Array(4)",
                                    "Array3D(2)": "Array(2)",
                                    "Array3D(3)": "Array(3)",
                                    "Array3D(4)": "Array(4)",
                                    "ArrayTexture(1)": "Number",
                                    "ArrayTexture(2)": "Array(2)",
                                    "ArrayTexture(3)": "Array(3)",
                                    "ArrayTexture(4)": "Array(4)"
                                };
                                i.exports = {
                                    FunctionNode: l
                                };
                            },
                            {
                                "../utils": 114,
                                "./function-tracer": 11,
                                acorn: 1
                            }
                        ],
                        11: [
                            function(e, i, h) {
                                const { utils: u } = e("../utils");
                                function p(a) {
                                    return a.length > 0 ? a[a.length - 1] : null;
                                }
                                const d = {
                                    trackIdentifiers: "trackIdentifiers",
                                    memberExpression: "memberExpression",
                                    inForLoopInit: "inForLoopInit"
                                };
                                class l {
                                    constructor(o){
                                        this.runningContexts = [], this.functionContexts = [], this.contexts = [], this.functionCalls = [], this.declarations = [], this.identifiers = [], this.functions = [], this.returnStatements = [], this.trackedIdentifiers = null, this.states = [], this.newFunctionContext(), this.scan(o);
                                    }
                                    isState(o) {
                                        return this.states[this.states.length - 1] === o;
                                    }
                                    hasState(o) {
                                        return this.states.indexOf(o) > -1;
                                    }
                                    pushState(o) {
                                        this.states.push(o);
                                    }
                                    popState(o) {
                                        if (this.isState(o)) this.states.pop();
                                        else throw new Error(`Cannot pop the non-active state "${o}"`);
                                    }
                                    get currentFunctionContext() {
                                        return p(this.functionContexts);
                                    }
                                    get currentContext() {
                                        return p(this.runningContexts);
                                    }
                                    newFunctionContext() {
                                        const o = {
                                            "@contextType": "function"
                                        };
                                        this.contexts.push(o), this.functionContexts.push(o);
                                    }
                                    newContext(o) {
                                        const n = Object.assign({
                                            "@contextType": "const/let"
                                        }, this.currentContext);
                                        this.contexts.push(n), this.runningContexts.push(n), o();
                                        const { currentFunctionContext: r } = this;
                                        for(const m in r)!r.hasOwnProperty(m) || n.hasOwnProperty(m) || (n[m] = r[m]);
                                        return this.runningContexts.pop(), n;
                                    }
                                    useFunctionContext(o) {
                                        const n = p(this.functionContexts);
                                        this.runningContexts.push(n), o(), this.runningContexts.pop();
                                    }
                                    getIdentifiers(o) {
                                        const n = this.trackedIdentifiers = [];
                                        return this.pushState(d.trackIdentifiers), o(), this.trackedIdentifiers = null, this.popState(d.trackIdentifiers), n;
                                    }
                                    getDeclaration(o) {
                                        const { currentContext: n, currentFunctionContext: r, runningContexts: m } = this, b = n[o] || r[o] || null;
                                        if (!b && n === r && m.length > 0) {
                                            const E = m[m.length - 2];
                                            if (E[o]) return E[o];
                                        }
                                        return b;
                                    }
                                    scan(o) {
                                        if (o) {
                                            if (Array.isArray(o)) {
                                                for(let n = 0; n < o.length; n++)this.scan(o[n]);
                                                return;
                                            }
                                            switch(o.type){
                                                case "Program":
                                                    this.useFunctionContext(()=>{
                                                        this.scan(o.body);
                                                    });
                                                    break;
                                                case "BlockStatement":
                                                    this.newContext(()=>{
                                                        this.scan(o.body);
                                                    });
                                                    break;
                                                case "AssignmentExpression":
                                                case "LogicalExpression":
                                                    this.scan(o.left), this.scan(o.right);
                                                    break;
                                                case "BinaryExpression":
                                                    this.scan(o.left), this.scan(o.right);
                                                    break;
                                                case "UpdateExpression":
                                                    if (o.operator === "++") {
                                                        const n = this.getDeclaration(o.argument.name);
                                                        n && (n.suggestedType = "Integer");
                                                    }
                                                    this.scan(o.argument);
                                                    break;
                                                case "UnaryExpression":
                                                    this.scan(o.argument);
                                                    break;
                                                case "VariableDeclaration":
                                                    o.kind === "var" ? this.useFunctionContext(()=>{
                                                        o.declarations = u.normalizeDeclarations(o), this.scan(o.declarations);
                                                    }) : (o.declarations = u.normalizeDeclarations(o), this.scan(o.declarations));
                                                    break;
                                                case "VariableDeclarator":
                                                    {
                                                        const { currentContext: n } = this, r = this.hasState(d.inForLoopInit), m = {
                                                            ast: o,
                                                            context: n,
                                                            name: o.id.name,
                                                            origin: "declaration",
                                                            inForLoopInit: r,
                                                            inForLoopTest: null,
                                                            assignable: n === this.currentFunctionContext || !r && !n.hasOwnProperty(o.id.name),
                                                            suggestedType: null,
                                                            valueType: null,
                                                            dependencies: null,
                                                            isSafe: null
                                                        };
                                                        n[o.id.name] || (n[o.id.name] = m), this.declarations.push(m), this.scan(o.id), this.scan(o.init);
                                                        break;
                                                    }
                                                case "FunctionExpression":
                                                case "FunctionDeclaration":
                                                    this.runningContexts.length === 0 ? this.scan(o.body) : this.functions.push(o);
                                                    break;
                                                case "IfStatement":
                                                    this.scan(o.test), this.scan(o.consequent), o.alternate && this.scan(o.alternate);
                                                    break;
                                                case "ForStatement":
                                                    {
                                                        let n;
                                                        const r = this.newContext(()=>{
                                                            this.pushState(d.inForLoopInit), this.scan(o.init), this.popState(d.inForLoopInit), n = this.getIdentifiers(()=>{
                                                                this.scan(o.test);
                                                            }), this.scan(o.update), this.newContext(()=>{
                                                                this.scan(o.body);
                                                            });
                                                        });
                                                        if (n) for(const m in r)m !== "@contextType" && n.indexOf(m) > -1 && (r[m].inForLoopTest = !0);
                                                        break;
                                                    }
                                                case "DoWhileStatement":
                                                case "WhileStatement":
                                                    this.newContext(()=>{
                                                        this.scan(o.body), this.scan(o.test);
                                                    });
                                                    break;
                                                case "Identifier":
                                                    {
                                                        this.isState(d.trackIdentifiers) && this.trackedIdentifiers.push(o.name), this.identifiers.push({
                                                            context: this.currentContext,
                                                            declaration: this.getDeclaration(o.name),
                                                            ast: o
                                                        });
                                                        break;
                                                    }
                                                case "ReturnStatement":
                                                    this.returnStatements.push(o), this.scan(o.argument);
                                                    break;
                                                case "MemberExpression":
                                                    this.pushState(d.memberExpression), this.scan(o.object), this.scan(o.property), this.popState(d.memberExpression);
                                                    break;
                                                case "ExpressionStatement":
                                                    this.scan(o.expression);
                                                    break;
                                                case "SequenceExpression":
                                                    this.scan(o.expressions);
                                                    break;
                                                case "CallExpression":
                                                    this.functionCalls.push({
                                                        context: this.currentContext,
                                                        ast: o
                                                    }), this.scan(o.arguments);
                                                    break;
                                                case "ArrayExpression":
                                                    this.scan(o.elements);
                                                    break;
                                                case "ConditionalExpression":
                                                    this.scan(o.test), this.scan(o.alternate), this.scan(o.consequent);
                                                    break;
                                                case "SwitchStatement":
                                                    this.scan(o.discriminant), this.scan(o.cases);
                                                    break;
                                                case "SwitchCase":
                                                    this.scan(o.test), this.scan(o.consequent);
                                                    break;
                                                case "ThisExpression":
                                                case "Literal":
                                                case "DebuggerStatement":
                                                case "EmptyStatement":
                                                case "BreakStatement":
                                                case "ContinueStatement":
                                                    break;
                                                default:
                                                    throw new Error(`unhandled type "${o.type}"`);
                                            }
                                        }
                                    }
                                }
                                i.exports = {
                                    FunctionTracer: l
                                };
                            },
                            {
                                "../utils": 114
                            }
                        ],
                        12: [
                            function(e, i, h) {
                                const { glWiretap: u } = e("gl-wiretap"), { utils: p } = e("../../utils");
                                function d(m) {
                                    return m.toString().replace("=>", "").replace(/^function /, "").replace(/utils[.]/g, "/*utils.*/");
                                }
                                function l(m, b, E, w, v) {
                                    E.built || E.build.apply(E, b), b = b ? Array.from(b).map((pt)=>{
                                        switch(typeof pt){
                                            case "boolean":
                                                return new Boolean(pt);
                                            case "number":
                                                return new Number(pt);
                                            default:
                                                return pt;
                                        }
                                    }) : null;
                                    const y = [], T = u(E.context, {
                                        useTrackablePrimitives: !0,
                                        onReadPixels: (pt)=>{
                                            if (J.subKernels) {
                                                if (!_) y.push(`    const result = { result: ${a(pt, J)} };`), _ = !0;
                                                else {
                                                    const _t = J.subKernels[k++].property;
                                                    y.push(`    result${isNaN(_t) ? "." + _t : `[${_t}]`} = ${a(pt, J)};`);
                                                }
                                                k === J.subKernels.length && y.push("    return result;");
                                                return;
                                            }
                                            pt ? y.push(`    return ${a(pt, J)};`) : y.push("    return null;");
                                        },
                                        onUnrecognizedArgumentLookup: (pt)=>{
                                            const _t = r(pt, J.kernelArguments, [], T);
                                            if (_t) return _t;
                                            const Dt = r(pt, J.kernelConstants, P ? Object.keys(P).map((Ut)=>P[Ut]) : [], T);
                                            return Dt || null;
                                        }
                                    });
                                    let _ = !1, k = 0;
                                    const { source: C, canvas: M, output: x, pipeline: g, graphical: I, loopMaxIterations: A, constants: P, optimizeFloatMemory: O, precision: R, fixIntegerDivisionAccuracy: G, functions: U, nativeFunctions: it, subKernels: q, immutable: B, argumentTypes: st, constantTypes: rt, kernelArguments: mt, kernelConstants: tt, tactic: et } = E, J = new m(C, {
                                        canvas: M,
                                        context: T,
                                        checkContext: !1,
                                        output: x,
                                        pipeline: g,
                                        graphical: I,
                                        loopMaxIterations: A,
                                        constants: P,
                                        optimizeFloatMemory: O,
                                        precision: R,
                                        fixIntegerDivisionAccuracy: G,
                                        functions: U,
                                        nativeFunctions: it,
                                        subKernels: q,
                                        immutable: B,
                                        argumentTypes: st,
                                        constantTypes: rt,
                                        tactic: et
                                    });
                                    let yt = [];
                                    if (T.setIndent(2), J.build.apply(J, b), yt.push(T.toString()), T.reset(), J.kernelArguments.forEach((pt, _t)=>{
                                        switch(pt.type){
                                            case "Integer":
                                            case "Boolean":
                                            case "Number":
                                            case "Float":
                                            case "Array":
                                            case "Array(2)":
                                            case "Array(3)":
                                            case "Array(4)":
                                            case "HTMLCanvas":
                                            case "HTMLImage":
                                            case "HTMLVideo":
                                                T.insertVariable(`uploadValue_${pt.name}`, pt.uploadValue);
                                                break;
                                            case "HTMLImageArray":
                                                for(let Dt = 0; Dt < b[_t].length; Dt++){
                                                    const Ut = b[_t];
                                                    T.insertVariable(`uploadValue_${pt.name}[${Dt}]`, Ut[Dt]);
                                                }
                                                break;
                                            case "Input":
                                                T.insertVariable(`uploadValue_${pt.name}`, pt.uploadValue);
                                                break;
                                            case "MemoryOptimizedNumberTexture":
                                            case "NumberTexture":
                                            case "Array1D(2)":
                                            case "Array1D(3)":
                                            case "Array1D(4)":
                                            case "Array2D(2)":
                                            case "Array2D(3)":
                                            case "Array2D(4)":
                                            case "Array3D(2)":
                                            case "Array3D(3)":
                                            case "Array3D(4)":
                                            case "ArrayTexture(1)":
                                            case "ArrayTexture(2)":
                                            case "ArrayTexture(3)":
                                            case "ArrayTexture(4)":
                                                T.insertVariable(`uploadValue_${pt.name}`, b[_t].texture);
                                                break;
                                            default:
                                                throw new Error(`unhandled kernelArgumentType insertion for glWiretap of type ${pt.type}`);
                                        }
                                    }), yt.push("/** start of injected functions **/"), yt.push(`function ${d(p.flattenTo)}`), yt.push(`function ${d(p.flatten2dArrayTo)}`), yt.push(`function ${d(p.flatten3dArrayTo)}`), yt.push(`function ${d(p.flatten4dArrayTo)}`), yt.push(`function ${d(p.isArray)}`), J.renderOutput !== J.renderTexture && J.formatValues && yt.push(`  const renderOutput = function ${d(J.formatValues)};`), yt.push("/** end of injected functions **/"), yt.push(`  const innerKernel = function (${J.kernelArguments.map((pt)=>pt.varName).join(", ")}) {`), T.setIndent(4), J.run.apply(J, b), J.renderKernels ? J.renderKernels() : J.renderOutput && J.renderOutput(), yt.push("    /** start setup uploads for kernel values **/"), J.kernelArguments.forEach((pt)=>{
                                        yt.push("    " + pt.getStringValueHandler().split(`
`).join(`
    `));
                                    }), yt.push("    /** end setup uploads for kernel values **/"), yt.push(T.toString()), J.renderOutput === J.renderTexture) {
                                        T.reset();
                                        const pt = T.getContextVariableName(J.framebuffer);
                                        if (J.renderKernels) {
                                            const _t = J.renderKernels(), Dt = T.getContextVariableName(J.texture.texture);
                                            yt.push(`    return {
      result: {
        texture: ${Dt},
        type: '${_t.result.type}',
        toArray: ${n(_t.result, Dt, pt)}
      },`);
                                            const { subKernels: Ut, mappedTextures: Gt } = J;
                                            for(let at = 0; at < Ut.length; at++){
                                                const Lt = Gt[at], Nt = Ut[at], Ht = _t[Nt.property], ie = T.getContextVariableName(Lt.texture);
                                                yt.push(`
      ${Nt.property}: {
        texture: ${ie},
        type: '${Ht.type}',
        toArray: ${n(Ht, ie, pt)}
      },`);
                                            }
                                            yt.push("    };");
                                        } else {
                                            const _t = J.renderOutput(), Dt = T.getContextVariableName(J.texture.texture);
                                            yt.push(`    return {
        texture: ${Dt},
        type: '${_t.type}',
        toArray: ${n(_t, Dt, pt)}
      };`);
                                        }
                                    }
                                    yt.push(`    ${v ? `
` + v + "    " : ""}`), yt.push(y.join(`
`)), yt.push("  };"), J.graphical && (yt.push(o(J)), yt.push("  innerKernel.getPixels = getPixels;")), yt.push("  return innerKernel;");
                                    let Pt = [];
                                    return tt.forEach((pt)=>{
                                        Pt.push(`${pt.getStringValueHandler()}`);
                                    }), `function kernel(settings) {
  const { context, constants } = settings;
  ${Pt.join("")}
  ${w || ""}
${yt.join(`
`)}
}`;
                                }
                                function a(m, b) {
                                    const E = b.precision === "single" ? m : `new Float32Array(${m}.buffer)`;
                                    return b.output[2] ? `renderOutput(${E}, ${b.output[0]}, ${b.output[1]}, ${b.output[2]})` : b.output[1] ? `renderOutput(${E}, ${b.output[0]}, ${b.output[1]})` : `renderOutput(${E}, ${b.output[0]})`;
                                }
                                function o(m) {
                                    const b = m.getPixels.toString(), E = !/^function/.test(b);
                                    return p.flattenFunctionToString(`${E ? "function " : ""}${b}`, {
                                        findDependency: (w, v)=>w === "utils" ? `const ${v} = ${p[v].toString()};` : null,
                                        thisLookup: (w)=>{
                                            if (w === "context") return null;
                                            if (m.hasOwnProperty(w)) return JSON.stringify(m[w]);
                                            throw new Error(`unhandled thisLookup ${w}`);
                                        }
                                    });
                                }
                                function n(m, b, E) {
                                    const w = m.toArray.toString(), v = !/^function/.test(w), y = p.flattenFunctionToString(`${v ? "function " : ""}${w}`, {
                                        findDependency: (T, _)=>{
                                            if (T === "utils") return `const ${_} = ${p[_].toString()};`;
                                            if (T === "this") return _ === "framebuffer" ? "" : `${v ? "function " : ""}${m[_].toString()}`;
                                            throw new Error("unhandled fromObject");
                                        },
                                        thisLookup: (T, _)=>{
                                            if (T === "texture") return b;
                                            if (T === "context") return _ ? null : "gl";
                                            if (m.hasOwnProperty(T)) return JSON.stringify(m[T]);
                                            throw new Error(`unhandled thisLookup ${T}`);
                                        }
                                    });
                                    return `() => {
  function framebuffer() { return ${E}; };
  ${y}
  return toArray();
  }`;
                                }
                                function r(m, b, E, w, v) {
                                    if (m === null || b === null) return null;
                                    switch(typeof m){
                                        case "boolean":
                                        case "number":
                                            return null;
                                    }
                                    if (typeof HTMLImageElement < "u" && m instanceof HTMLImageElement) for(let y = 0; y < b.length; y++){
                                        const T = b[y];
                                        if (T.type !== "HTMLImageArray" && T || T.uploadValue !== m) continue;
                                        const _ = E[y].indexOf(m);
                                        if (_ === -1) continue;
                                        const k = `uploadValue_${T.name}[${_}]`;
                                        return w.insertVariable(k, m), k;
                                    }
                                    for(let y = 0; y < b.length; y++){
                                        const T = b[y];
                                        if (m !== T.uploadValue) continue;
                                        const _ = `uploadValue_${T.name}`;
                                        return w.insertVariable(_, T), _;
                                    }
                                    return null;
                                }
                                i.exports = {
                                    glKernelString: l
                                };
                            },
                            {
                                "../../utils": 114,
                                "gl-wiretap": 3
                            }
                        ],
                        13: [
                            function(e, i, h) {
                                const { Kernel: u } = e("../kernel"), { utils: p } = e("../../utils"), { GLTextureArray2Float: d } = e("./texture/array-2-float"), { GLTextureArray2Float2D: l } = e("./texture/array-2-float-2d"), { GLTextureArray2Float3D: a } = e("./texture/array-2-float-3d"), { GLTextureArray3Float: o } = e("./texture/array-3-float"), { GLTextureArray3Float2D: n } = e("./texture/array-3-float-2d"), { GLTextureArray3Float3D: r } = e("./texture/array-3-float-3d"), { GLTextureArray4Float: m } = e("./texture/array-4-float"), { GLTextureArray4Float2D: b } = e("./texture/array-4-float-2d"), { GLTextureArray4Float3D: E } = e("./texture/array-4-float-3d"), { GLTextureFloat: w } = e("./texture/float"), { GLTextureFloat2D: v } = e("./texture/float-2d"), { GLTextureFloat3D: y } = e("./texture/float-3d"), { GLTextureMemoryOptimized: T } = e("./texture/memory-optimized"), { GLTextureMemoryOptimized2D: _ } = e("./texture/memory-optimized-2d"), { GLTextureMemoryOptimized3D: k } = e("./texture/memory-optimized-3d"), { GLTextureUnsigned: C } = e("./texture/unsigned"), { GLTextureUnsigned2D: M } = e("./texture/unsigned-2d"), { GLTextureUnsigned3D: x } = e("./texture/unsigned-3d"), { GLTextureGraphical: g } = e("./texture/graphical");
                                class I extends u {
                                    static get mode() {
                                        return "gpu";
                                    }
                                    static getIsFloatRead() {
                                        const O = `function kernelFunction() {
      return 1;
    }`, R = new this(O, {
                                            context: this.testContext,
                                            canvas: this.testCanvas,
                                            validate: !1,
                                            output: [
                                                1
                                            ],
                                            precision: "single",
                                            returnType: "Number",
                                            tactic: "speed"
                                        });
                                        R.build(), R.run();
                                        const G = R.renderOutput();
                                        return R.destroy(!0), G[0] === 1;
                                    }
                                    static getIsIntegerDivisionAccurate() {
                                        function O(it, q) {
                                            return it[this.thread.x] / q[this.thread.x];
                                        }
                                        const R = new this(O.toString(), {
                                            context: this.testContext,
                                            canvas: this.testCanvas,
                                            validate: !1,
                                            output: [
                                                2
                                            ],
                                            returnType: "Number",
                                            precision: "unsigned",
                                            tactic: "speed"
                                        }), G = [
                                            [
                                                6,
                                                6030401
                                            ],
                                            [
                                                3,
                                                3991
                                            ]
                                        ];
                                        R.build.apply(R, G), R.run.apply(R, G);
                                        const U = R.renderOutput();
                                        return R.destroy(!0), U[0] === 2 && U[1] === 1511;
                                    }
                                    static getIsSpeedTacticSupported() {
                                        function O(it) {
                                            return it[this.thread.x];
                                        }
                                        const R = new this(O.toString(), {
                                            context: this.testContext,
                                            canvas: this.testCanvas,
                                            validate: !1,
                                            output: [
                                                4
                                            ],
                                            returnType: "Number",
                                            precision: "unsigned",
                                            tactic: "speed"
                                        }), G = [
                                            [
                                                0,
                                                1,
                                                2,
                                                3
                                            ]
                                        ];
                                        R.build.apply(R, G), R.run.apply(R, G);
                                        const U = R.renderOutput();
                                        return R.destroy(!0), Math.round(U[0]) === 0 && Math.round(U[1]) === 1 && Math.round(U[2]) === 2 && Math.round(U[3]) === 3;
                                    }
                                    static get testCanvas() {
                                        throw new Error(`"testCanvas" not defined on ${this.name}`);
                                    }
                                    static get testContext() {
                                        throw new Error(`"testContext" not defined on ${this.name}`);
                                    }
                                    static getFeatures() {
                                        const O = this.testContext, R = this.getIsDrawBuffers();
                                        return Object.freeze({
                                            isFloatRead: this.getIsFloatRead(),
                                            isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
                                            isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
                                            isTextureFloat: this.getIsTextureFloat(),
                                            isDrawBuffers: R,
                                            kernelMap: R,
                                            channelCount: this.getChannelCount(),
                                            maxTextureSize: this.getMaxTextureSize(),
                                            lowIntPrecision: O.getShaderPrecisionFormat(O.FRAGMENT_SHADER, O.LOW_INT),
                                            lowFloatPrecision: O.getShaderPrecisionFormat(O.FRAGMENT_SHADER, O.LOW_FLOAT),
                                            mediumIntPrecision: O.getShaderPrecisionFormat(O.FRAGMENT_SHADER, O.MEDIUM_INT),
                                            mediumFloatPrecision: O.getShaderPrecisionFormat(O.FRAGMENT_SHADER, O.MEDIUM_FLOAT),
                                            highIntPrecision: O.getShaderPrecisionFormat(O.FRAGMENT_SHADER, O.HIGH_INT),
                                            highFloatPrecision: O.getShaderPrecisionFormat(O.FRAGMENT_SHADER, O.HIGH_FLOAT)
                                        });
                                    }
                                    static setupFeatureChecks() {
                                        throw new Error(`"setupFeatureChecks" not defined on ${this.name}`);
                                    }
                                    static getSignature(O, R) {
                                        return O.getVariablePrecisionString() + (R.length > 0 ? ":" + R.join(",") : "");
                                    }
                                    setFixIntegerDivisionAccuracy(O) {
                                        return this.fixIntegerDivisionAccuracy = O, this;
                                    }
                                    setPrecision(O) {
                                        return this.precision = O, this;
                                    }
                                    setFloatTextures(O) {
                                        return p.warnDeprecated("method", "setFloatTextures", "setOptimizeFloatMemory"), this.floatTextures = O, this;
                                    }
                                    static nativeFunctionArguments(O) {
                                        const R = [], G = [], U = [], it = /^[a-zA-Z_]/, q = /[a-zA-Z_0-9]/;
                                        let B = 0, st = null, rt = null;
                                        for(; B < O.length;){
                                            const mt = O[B], tt = O[B + 1], et = U.length > 0 ? U[U.length - 1] : null;
                                            if (et === "FUNCTION_ARGUMENTS" && mt === "/" && tt === "*") {
                                                U.push("MULTI_LINE_COMMENT"), B += 2;
                                                continue;
                                            } else if (et === "MULTI_LINE_COMMENT" && mt === "*" && tt === "/") {
                                                U.pop(), B += 2;
                                                continue;
                                            } else if (et === "FUNCTION_ARGUMENTS" && mt === "/" && tt === "/") {
                                                U.push("COMMENT"), B += 2;
                                                continue;
                                            } else if (et === "COMMENT" && mt === `
`) {
                                                U.pop(), B++;
                                                continue;
                                            } else if (et === null && mt === "(") {
                                                U.push("FUNCTION_ARGUMENTS"), B++;
                                                continue;
                                            } else if (et === "FUNCTION_ARGUMENTS") {
                                                if (mt === ")") {
                                                    U.pop();
                                                    break;
                                                }
                                                if (mt === "f" && tt === "l" && O[B + 2] === "o" && O[B + 3] === "a" && O[B + 4] === "t" && O[B + 5] === " ") {
                                                    U.push("DECLARE_VARIABLE"), rt = "float", st = "", B += 6;
                                                    continue;
                                                } else if (mt === "i" && tt === "n" && O[B + 2] === "t" && O[B + 3] === " ") {
                                                    U.push("DECLARE_VARIABLE"), rt = "int", st = "", B += 4;
                                                    continue;
                                                } else if (mt === "v" && tt === "e" && O[B + 2] === "c" && O[B + 3] === "2" && O[B + 4] === " ") {
                                                    U.push("DECLARE_VARIABLE"), rt = "vec2", st = "", B += 5;
                                                    continue;
                                                } else if (mt === "v" && tt === "e" && O[B + 2] === "c" && O[B + 3] === "3" && O[B + 4] === " ") {
                                                    U.push("DECLARE_VARIABLE"), rt = "vec3", st = "", B += 5;
                                                    continue;
                                                } else if (mt === "v" && tt === "e" && O[B + 2] === "c" && O[B + 3] === "4" && O[B + 4] === " ") {
                                                    U.push("DECLARE_VARIABLE"), rt = "vec4", st = "", B += 5;
                                                    continue;
                                                }
                                            } else if (et === "DECLARE_VARIABLE") {
                                                if (st === "") {
                                                    if (mt === " ") {
                                                        B++;
                                                        continue;
                                                    }
                                                    if (!it.test(mt)) throw new Error("variable name is not expected string");
                                                }
                                                st += mt, q.test(tt) || (U.pop(), G.push(st), R.push(A[rt]));
                                            }
                                            B++;
                                        }
                                        if (U.length > 0) throw new Error("GLSL function was not parsable");
                                        return {
                                            argumentNames: G,
                                            argumentTypes: R
                                        };
                                    }
                                    static nativeFunctionReturnType(O) {
                                        return A[O.match(/int|float|vec[2-4]/)[0]];
                                    }
                                    static combineKernels(O, R) {
                                        O.apply(null, arguments);
                                        const { texSize: G, context: U, threadDim: it } = R.texSize;
                                        let q;
                                        if (R.precision === "single") {
                                            const B = G[0], st = Math.ceil(G[1] / 4);
                                            q = new Float32Array(B * st * 4 * 4), U.readPixels(0, 0, B, st * 4, U.RGBA, U.FLOAT, q);
                                        } else {
                                            const B = new Uint8Array(G[0] * G[1] * 4);
                                            U.readPixels(0, 0, G[0], G[1], U.RGBA, U.UNSIGNED_BYTE, B), q = new Float32Array(B.buffer);
                                        }
                                        if (q = q.subarray(0, it[0] * it[1] * it[2]), R.output.length === 1) return q;
                                        if (R.output.length === 2) return p.splitArray(q, R.output[0]);
                                        if (R.output.length === 3) return p.splitArray(q, R.output[0] * R.output[1]).map(function(st) {
                                            return p.splitArray(st, R.output[0]);
                                        });
                                    }
                                    constructor(O, R){
                                        super(O, R), this.transferValues = null, this.formatValues = null, this.TextureConstructor = null, this.renderOutput = null, this.renderRawOutput = null, this.texSize = null, this.translatedSource = null, this.compiledFragmentShader = null, this.compiledVertexShader = null, this.switchingKernels = null, this._textureSwitched = null, this._mappedTextureSwitched = null;
                                    }
                                    checkTextureSize() {
                                        const { features: O } = this.constructor;
                                        if (this.texSize[0] > O.maxTextureSize || this.texSize[1] > O.maxTextureSize) throw new Error(`Texture size [${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than supported size [${O.maxTextureSize},${O.maxTextureSize}]`);
                                    }
                                    translateSource() {
                                        throw new Error(`"translateSource" not defined on ${this.constructor.name}`);
                                    }
                                    pickRenderStrategy(O) {
                                        if (this.graphical) return this.renderRawOutput = this.readPackedPixelsToUint8Array, this.transferValues = (R)=>R, this.TextureConstructor = g, null;
                                        if (this.precision === "unsigned") if (this.renderRawOutput = this.readPackedPixelsToUint8Array, this.transferValues = this.readPackedPixelsToFloat32Array, this.pipeline) switch(this.renderOutput = this.renderTexture, this.subKernels !== null && (this.renderKernels = this.renderKernelsToTextures), this.returnType){
                                            case "LiteralInteger":
                                            case "Float":
                                            case "Number":
                                            case "Integer":
                                                return this.output[2] > 0 ? (this.TextureConstructor = x, null) : this.output[1] > 0 ? (this.TextureConstructor = M, null) : (this.TextureConstructor = C, null);
                                            case "Array(2)":
                                            case "Array(3)":
                                            case "Array(4)":
                                                return this.requestFallback(O);
                                        }
                                        else switch(this.subKernels !== null && (this.renderKernels = this.renderKernelsToArrays), this.returnType){
                                            case "LiteralInteger":
                                            case "Float":
                                            case "Number":
                                            case "Integer":
                                                return this.renderOutput = this.renderValues, this.output[2] > 0 ? (this.TextureConstructor = x, this.formatValues = p.erect3DPackedFloat, null) : this.output[1] > 0 ? (this.TextureConstructor = M, this.formatValues = p.erect2DPackedFloat, null) : (this.TextureConstructor = C, this.formatValues = p.erectPackedFloat, null);
                                            case "Array(2)":
                                            case "Array(3)":
                                            case "Array(4)":
                                                return this.requestFallback(O);
                                        }
                                        else if (this.precision === "single") {
                                            if (this.renderRawOutput = this.readFloatPixelsToFloat32Array, this.transferValues = this.readFloatPixelsToFloat32Array, this.pipeline) switch(this.renderOutput = this.renderTexture, this.subKernels !== null && (this.renderKernels = this.renderKernelsToTextures), this.returnType){
                                                case "LiteralInteger":
                                                case "Float":
                                                case "Number":
                                                case "Integer":
                                                    return this.optimizeFloatMemory ? this.output[2] > 0 ? (this.TextureConstructor = k, null) : this.output[1] > 0 ? (this.TextureConstructor = _, null) : (this.TextureConstructor = T, null) : this.output[2] > 0 ? (this.TextureConstructor = y, null) : this.output[1] > 0 ? (this.TextureConstructor = v, null) : (this.TextureConstructor = w, null);
                                                case "Array(2)":
                                                    return this.output[2] > 0 ? (this.TextureConstructor = a, null) : this.output[1] > 0 ? (this.TextureConstructor = l, null) : (this.TextureConstructor = d, null);
                                                case "Array(3)":
                                                    return this.output[2] > 0 ? (this.TextureConstructor = r, null) : this.output[1] > 0 ? (this.TextureConstructor = n, null) : (this.TextureConstructor = o, null);
                                                case "Array(4)":
                                                    return this.output[2] > 0 ? (this.TextureConstructor = E, null) : this.output[1] > 0 ? (this.TextureConstructor = b, null) : (this.TextureConstructor = m, null);
                                            }
                                            if (this.renderOutput = this.renderValues, this.subKernels !== null && (this.renderKernels = this.renderKernelsToArrays), this.optimizeFloatMemory) switch(this.returnType){
                                                case "LiteralInteger":
                                                case "Float":
                                                case "Number":
                                                case "Integer":
                                                    return this.output[2] > 0 ? (this.TextureConstructor = k, this.formatValues = p.erectMemoryOptimized3DFloat, null) : this.output[1] > 0 ? (this.TextureConstructor = _, this.formatValues = p.erectMemoryOptimized2DFloat, null) : (this.TextureConstructor = T, this.formatValues = p.erectMemoryOptimizedFloat, null);
                                                case "Array(2)":
                                                    return this.output[2] > 0 ? (this.TextureConstructor = a, this.formatValues = p.erect3DArray2, null) : this.output[1] > 0 ? (this.TextureConstructor = l, this.formatValues = p.erect2DArray2, null) : (this.TextureConstructor = d, this.formatValues = p.erectArray2, null);
                                                case "Array(3)":
                                                    return this.output[2] > 0 ? (this.TextureConstructor = r, this.formatValues = p.erect3DArray3, null) : this.output[1] > 0 ? (this.TextureConstructor = n, this.formatValues = p.erect2DArray3, null) : (this.TextureConstructor = o, this.formatValues = p.erectArray3, null);
                                                case "Array(4)":
                                                    return this.output[2] > 0 ? (this.TextureConstructor = E, this.formatValues = p.erect3DArray4, null) : this.output[1] > 0 ? (this.TextureConstructor = b, this.formatValues = p.erect2DArray4, null) : (this.TextureConstructor = m, this.formatValues = p.erectArray4, null);
                                            }
                                            else switch(this.returnType){
                                                case "LiteralInteger":
                                                case "Float":
                                                case "Number":
                                                case "Integer":
                                                    return this.output[2] > 0 ? (this.TextureConstructor = y, this.formatValues = p.erect3DFloat, null) : this.output[1] > 0 ? (this.TextureConstructor = v, this.formatValues = p.erect2DFloat, null) : (this.TextureConstructor = w, this.formatValues = p.erectFloat, null);
                                                case "Array(2)":
                                                    return this.output[2] > 0 ? (this.TextureConstructor = a, this.formatValues = p.erect3DArray2, null) : this.output[1] > 0 ? (this.TextureConstructor = l, this.formatValues = p.erect2DArray2, null) : (this.TextureConstructor = d, this.formatValues = p.erectArray2, null);
                                                case "Array(3)":
                                                    return this.output[2] > 0 ? (this.TextureConstructor = r, this.formatValues = p.erect3DArray3, null) : this.output[1] > 0 ? (this.TextureConstructor = n, this.formatValues = p.erect2DArray3, null) : (this.TextureConstructor = o, this.formatValues = p.erectArray3, null);
                                                case "Array(4)":
                                                    return this.output[2] > 0 ? (this.TextureConstructor = E, this.formatValues = p.erect3DArray4, null) : this.output[1] > 0 ? (this.TextureConstructor = b, this.formatValues = p.erect2DArray4, null) : (this.TextureConstructor = m, this.formatValues = p.erectArray4, null);
                                            }
                                        } else throw new Error(`unhandled precision of "${this.precision}"`);
                                        throw new Error(`unhandled return type "${this.returnType}"`);
                                    }
                                    getKernelString() {
                                        throw new Error("abstract method call");
                                    }
                                    getMainResultTexture() {
                                        switch(this.returnType){
                                            case "LiteralInteger":
                                            case "Float":
                                            case "Integer":
                                            case "Number":
                                                return this.getMainResultNumberTexture();
                                            case "Array(2)":
                                                return this.getMainResultArray2Texture();
                                            case "Array(3)":
                                                return this.getMainResultArray3Texture();
                                            case "Array(4)":
                                                return this.getMainResultArray4Texture();
                                            default:
                                                throw new Error(`unhandled returnType type ${this.returnType}`);
                                        }
                                    }
                                    getMainResultKernelNumberTexture() {
                                        throw new Error("abstract method call");
                                    }
                                    getMainResultSubKernelNumberTexture() {
                                        throw new Error("abstract method call");
                                    }
                                    getMainResultKernelArray2Texture() {
                                        throw new Error("abstract method call");
                                    }
                                    getMainResultSubKernelArray2Texture() {
                                        throw new Error("abstract method call");
                                    }
                                    getMainResultKernelArray3Texture() {
                                        throw new Error("abstract method call");
                                    }
                                    getMainResultSubKernelArray3Texture() {
                                        throw new Error("abstract method call");
                                    }
                                    getMainResultKernelArray4Texture() {
                                        throw new Error("abstract method call");
                                    }
                                    getMainResultSubKernelArray4Texture() {
                                        throw new Error("abstract method call");
                                    }
                                    getMainResultGraphical() {
                                        throw new Error("abstract method call");
                                    }
                                    getMainResultMemoryOptimizedFloats() {
                                        throw new Error("abstract method call");
                                    }
                                    getMainResultPackedPixels() {
                                        throw new Error("abstract method call");
                                    }
                                    getMainResultString() {
                                        return this.graphical ? this.getMainResultGraphical() : this.precision === "single" ? this.optimizeFloatMemory ? this.getMainResultMemoryOptimizedFloats() : this.getMainResultTexture() : this.getMainResultPackedPixels();
                                    }
                                    getMainResultNumberTexture() {
                                        return p.linesToString(this.getMainResultKernelNumberTexture()) + p.linesToString(this.getMainResultSubKernelNumberTexture());
                                    }
                                    getMainResultArray2Texture() {
                                        return p.linesToString(this.getMainResultKernelArray2Texture()) + p.linesToString(this.getMainResultSubKernelArray2Texture());
                                    }
                                    getMainResultArray3Texture() {
                                        return p.linesToString(this.getMainResultKernelArray3Texture()) + p.linesToString(this.getMainResultSubKernelArray3Texture());
                                    }
                                    getMainResultArray4Texture() {
                                        return p.linesToString(this.getMainResultKernelArray4Texture()) + p.linesToString(this.getMainResultSubKernelArray4Texture());
                                    }
                                    getFloatTacticDeclaration() {
                                        return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} float;
`;
                                    }
                                    getIntTacticDeclaration() {
                                        return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic, !0)} int;
`;
                                    }
                                    getSampler2DTacticDeclaration() {
                                        return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2D;
`;
                                    }
                                    getSampler2DArrayTacticDeclaration() {
                                        return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2DArray;
`;
                                    }
                                    renderTexture() {
                                        return this.immutable ? this.texture.clone() : this.texture;
                                    }
                                    readPackedPixelsToUint8Array() {
                                        if (this.precision !== "unsigned") throw new Error('Requires this.precision to be "unsigned"');
                                        const { texSize: O, context: R } = this, G = new Uint8Array(O[0] * O[1] * 4);
                                        return R.readPixels(0, 0, O[0], O[1], R.RGBA, R.UNSIGNED_BYTE, G), G;
                                    }
                                    readPackedPixelsToFloat32Array() {
                                        return new Float32Array(this.readPackedPixelsToUint8Array().buffer);
                                    }
                                    readFloatPixelsToFloat32Array() {
                                        if (this.precision !== "single") throw new Error('Requires this.precision to be "single"');
                                        const { texSize: O, context: R } = this, G = O[0], U = O[1], it = new Float32Array(G * U * 4);
                                        return R.readPixels(0, 0, G, U, R.RGBA, R.FLOAT, it), it;
                                    }
                                    getPixels(O) {
                                        const { context: R, output: G } = this, [U, it] = G, q = new Uint8Array(U * it * 4);
                                        return R.readPixels(0, 0, U, it, R.RGBA, R.UNSIGNED_BYTE, q), new Uint8ClampedArray((O ? q : p.flipPixels(q, U, it)).buffer);
                                    }
                                    renderKernelsToArrays() {
                                        const O = {
                                            result: this.renderOutput()
                                        };
                                        for(let R = 0; R < this.subKernels.length; R++)O[this.subKernels[R].property] = this.mappedTextures[R].toArray();
                                        return O;
                                    }
                                    renderKernelsToTextures() {
                                        const O = {
                                            result: this.renderOutput()
                                        };
                                        if (this.immutable) for(let R = 0; R < this.subKernels.length; R++)O[this.subKernels[R].property] = this.mappedTextures[R].clone();
                                        else for(let R = 0; R < this.subKernels.length; R++)O[this.subKernels[R].property] = this.mappedTextures[R];
                                        return O;
                                    }
                                    resetSwitchingKernels() {
                                        const O = this.switchingKernels;
                                        return this.switchingKernels = null, O;
                                    }
                                    setOutput(O) {
                                        const R = this.toKernelOutput(O);
                                        if (this.program) {
                                            if (!this.dynamicOutput) throw new Error("Resizing a kernel with dynamicOutput: false is not possible");
                                            const G = [
                                                R[0],
                                                R[1] || 1,
                                                R[2] || 1
                                            ], U = p.getKernelTextureSize({
                                                optimizeFloatMemory: this.optimizeFloatMemory,
                                                precision: this.precision
                                            }, G), it = this.texSize;
                                            if (it) {
                                                const B = this.getVariablePrecisionString(it, this.tactic), st = this.getVariablePrecisionString(U, this.tactic);
                                                if (B !== st) {
                                                    this.debug && console.warn("Precision requirement changed, asking GPU instance to recompile"), this.switchKernels({
                                                        type: "outputPrecisionMismatch",
                                                        precision: st,
                                                        needed: O
                                                    });
                                                    return;
                                                }
                                            }
                                            this.output = R, this.threadDim = G, this.texSize = U;
                                            const { context: q } = this;
                                            if (q.bindFramebuffer(q.FRAMEBUFFER, this.framebuffer), this.updateMaxTexSize(), this.framebuffer.width = this.texSize[0], this.framebuffer.height = this.texSize[1], q.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]), this.canvas.width = this.maxTexSize[0], this.canvas.height = this.maxTexSize[1], this.texture && this.texture.delete(), this.texture = null, this._setupOutputTexture(), this.mappedTextures && this.mappedTextures.length > 0) {
                                                for(let B = 0; B < this.mappedTextures.length; B++)this.mappedTextures[B].delete();
                                                this.mappedTextures = null, this._setupSubOutputTextures();
                                            }
                                        } else this.output = R;
                                        return this;
                                    }
                                    renderValues() {
                                        return this.formatValues(this.transferValues(), this.output[0], this.output[1], this.output[2]);
                                    }
                                    switchKernels(O) {
                                        this.switchingKernels ? this.switchingKernels.push(O) : this.switchingKernels = [
                                            O
                                        ];
                                    }
                                    getVariablePrecisionString(O = this.texSize, R = this.tactic, G = !1) {
                                        if (!R) {
                                            if (!this.constructor.features.isSpeedTacticSupported) return "highp";
                                            const U = this.constructor.features[G ? "lowIntPrecision" : "lowFloatPrecision"], it = this.constructor.features[G ? "mediumIntPrecision" : "mediumFloatPrecision"], q = this.constructor.features[G ? "highIntPrecision" : "highFloatPrecision"], B = Math.log2(O[0] * O[1]);
                                            if (B <= U.rangeMax) return "lowp";
                                            if (B <= it.rangeMax) return "mediump";
                                            if (B <= q.rangeMax) return "highp";
                                            throw new Error("The required size exceeds that of the ability of your system");
                                        }
                                        switch(R){
                                            case "speed":
                                                return "lowp";
                                            case "balanced":
                                                return "mediump";
                                            case "precision":
                                                return "highp";
                                            default:
                                                throw new Error(`Unknown tactic "${R}" use "speed", "balanced", "precision", or empty for auto`);
                                        }
                                    }
                                    updateTextureArgumentRefs(O, R) {
                                        if (this.immutable) {
                                            if (this.texture.texture === R.texture) {
                                                const { prevArg: G } = O;
                                                G && (G.texture._refs === 1 && (this.texture.delete(), this.texture = G.clone(), this._textureSwitched = !0), G.delete()), O.prevArg = R.clone();
                                            } else if (this.mappedTextures && this.mappedTextures.length > 0) {
                                                const { mappedTextures: G } = this;
                                                for(let U = 0; U < G.length; U++){
                                                    const it = G[U];
                                                    if (it.texture === R.texture) {
                                                        const { prevArg: q } = O;
                                                        q && (q.texture._refs === 1 && (it.delete(), G[U] = q.clone(), this._mappedTextureSwitched[U] = !0), q.delete()), O.prevArg = R.clone();
                                                        return;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    onActivate(O) {
                                        if (this._textureSwitched = !0, this.texture = O.texture, this.mappedTextures) {
                                            for(let R = 0; R < this.mappedTextures.length; R++)this._mappedTextureSwitched[R] = !0;
                                            this.mappedTextures = O.mappedTextures;
                                        }
                                    }
                                    initCanvas() {}
                                }
                                const A = {
                                    int: "Integer",
                                    float: "Number",
                                    vec2: "Array(2)",
                                    vec3: "Array(3)",
                                    vec4: "Array(4)"
                                };
                                i.exports = {
                                    GLKernel: I
                                };
                            },
                            {
                                "../../utils": 114,
                                "../kernel": 36,
                                "./texture/array-2-float": 16,
                                "./texture/array-2-float-2d": 14,
                                "./texture/array-2-float-3d": 15,
                                "./texture/array-3-float": 19,
                                "./texture/array-3-float-2d": 17,
                                "./texture/array-3-float-3d": 18,
                                "./texture/array-4-float": 22,
                                "./texture/array-4-float-2d": 20,
                                "./texture/array-4-float-3d": 21,
                                "./texture/float": 25,
                                "./texture/float-2d": 23,
                                "./texture/float-3d": 24,
                                "./texture/graphical": 26,
                                "./texture/memory-optimized": 30,
                                "./texture/memory-optimized-2d": 28,
                                "./texture/memory-optimized-3d": 29,
                                "./texture/unsigned": 33,
                                "./texture/unsigned-2d": 31,
                                "./texture/unsigned-3d": 32
                            }
                        ],
                        14: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureFloat: p } = e("./float");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "ArrayTexture(2)";
                                    }
                                    toArray() {
                                        return u.erect2DArray2(this.renderValues(), this.output[0], this.output[1]);
                                    }
                                }
                                i.exports = {
                                    GLTextureArray2Float2D: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./float": 25
                            }
                        ],
                        15: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureFloat: p } = e("./float");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "ArrayTexture(2)";
                                    }
                                    toArray() {
                                        return u.erect3DArray2(this.renderValues(), this.output[0], this.output[1], this.output[2]);
                                    }
                                }
                                i.exports = {
                                    GLTextureArray2Float3D: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./float": 25
                            }
                        ],
                        16: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureFloat: p } = e("./float");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "ArrayTexture(2)";
                                    }
                                    toArray() {
                                        return u.erectArray2(this.renderValues(), this.output[0], this.output[1]);
                                    }
                                }
                                i.exports = {
                                    GLTextureArray2Float: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./float": 25
                            }
                        ],
                        17: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureFloat: p } = e("./float");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "ArrayTexture(3)";
                                    }
                                    toArray() {
                                        return u.erect2DArray3(this.renderValues(), this.output[0], this.output[1]);
                                    }
                                }
                                i.exports = {
                                    GLTextureArray3Float2D: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./float": 25
                            }
                        ],
                        18: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureFloat: p } = e("./float");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "ArrayTexture(3)";
                                    }
                                    toArray() {
                                        return u.erect3DArray3(this.renderValues(), this.output[0], this.output[1], this.output[2]);
                                    }
                                }
                                i.exports = {
                                    GLTextureArray3Float3D: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./float": 25
                            }
                        ],
                        19: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureFloat: p } = e("./float");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "ArrayTexture(3)";
                                    }
                                    toArray() {
                                        return u.erectArray3(this.renderValues(), this.output[0]);
                                    }
                                }
                                i.exports = {
                                    GLTextureArray3Float: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./float": 25
                            }
                        ],
                        20: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureFloat: p } = e("./float");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "ArrayTexture(4)";
                                    }
                                    toArray() {
                                        return u.erect2DArray4(this.renderValues(), this.output[0], this.output[1]);
                                    }
                                }
                                i.exports = {
                                    GLTextureArray4Float2D: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./float": 25
                            }
                        ],
                        21: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureFloat: p } = e("./float");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "ArrayTexture(4)";
                                    }
                                    toArray() {
                                        return u.erect3DArray4(this.renderValues(), this.output[0], this.output[1], this.output[2]);
                                    }
                                }
                                i.exports = {
                                    GLTextureArray4Float3D: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./float": 25
                            }
                        ],
                        22: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureFloat: p } = e("./float");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "ArrayTexture(4)";
                                    }
                                    toArray() {
                                        return u.erectArray4(this.renderValues(), this.output[0]);
                                    }
                                }
                                i.exports = {
                                    GLTextureArray4Float: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./float": 25
                            }
                        ],
                        23: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureFloat: p } = e("./float");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "ArrayTexture(1)";
                                    }
                                    toArray() {
                                        return u.erect2DFloat(this.renderValues(), this.output[0], this.output[1]);
                                    }
                                }
                                i.exports = {
                                    GLTextureFloat2D: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./float": 25
                            }
                        ],
                        24: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureFloat: p } = e("./float");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "ArrayTexture(1)";
                                    }
                                    toArray() {
                                        return u.erect3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
                                    }
                                }
                                i.exports = {
                                    GLTextureFloat3D: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./float": 25
                            }
                        ],
                        25: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTexture: p } = e("./index");
                                class d extends p {
                                    get textureType() {
                                        return this.context.FLOAT;
                                    }
                                    constructor(a){
                                        super(a), this.type = "ArrayTexture(1)";
                                    }
                                    renderRawOutput() {
                                        const a = this.context, o = this.size;
                                        a.bindFramebuffer(a.FRAMEBUFFER, this.framebuffer()), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, this.texture, 0);
                                        const n = new Float32Array(o[0] * o[1] * 4);
                                        return a.readPixels(0, 0, o[0], o[1], a.RGBA, a.FLOAT, n), n;
                                    }
                                    renderValues() {
                                        return this._deleted ? null : this.renderRawOutput();
                                    }
                                    toArray() {
                                        return u.erectFloat(this.renderValues(), this.output[0]);
                                    }
                                }
                                i.exports = {
                                    GLTextureFloat: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./index": 27
                            }
                        ],
                        26: [
                            function(e, i, h) {
                                const { GLTextureUnsigned: u } = e("./unsigned");
                                class p extends u {
                                    constructor(l){
                                        super(l), this.type = "ArrayTexture(4)";
                                    }
                                    toArray() {
                                        return this.renderValues();
                                    }
                                }
                                i.exports = {
                                    GLTextureGraphical: p
                                };
                            },
                            {
                                "./unsigned": 33
                            }
                        ],
                        27: [
                            function(e, i, h) {
                                const { Texture: u } = e("../../../texture");
                                class p extends u {
                                    get textureType() {
                                        throw new Error(`"textureType" not implemented on ${this.name}`);
                                    }
                                    clone() {
                                        return new this.constructor(this);
                                    }
                                    beforeMutate() {
                                        return this.texture._refs > 1 ? (this.newTexture(), !0) : !1;
                                    }
                                    cloneTexture() {
                                        this.texture._refs--;
                                        const { context: a, size: o, texture: n, kernel: r } = this;
                                        r.debug && console.warn("cloning internal texture"), a.bindFramebuffer(a.FRAMEBUFFER, this.framebuffer()), d(a, n), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, n, 0);
                                        const m = a.createTexture();
                                        d(a, m), a.texImage2D(a.TEXTURE_2D, 0, this.internalFormat, o[0], o[1], 0, this.textureFormat, this.textureType, null), a.copyTexSubImage2D(a.TEXTURE_2D, 0, 0, 0, 0, 0, o[0], o[1]), m._refs = 1, this.texture = m;
                                    }
                                    newTexture() {
                                        this.texture._refs--;
                                        const a = this.context, o = this.size;
                                        this.kernel.debug && console.warn("new internal texture");
                                        const r = a.createTexture();
                                        d(a, r), a.texImage2D(a.TEXTURE_2D, 0, this.internalFormat, o[0], o[1], 0, this.textureFormat, this.textureType, null), r._refs = 1, this.texture = r;
                                    }
                                    clear() {
                                        if (this.texture._refs) {
                                            this.texture._refs--;
                                            const n = this.context, r = this.texture = n.createTexture();
                                            d(n, r);
                                            const m = this.size;
                                            r._refs = 1, n.texImage2D(n.TEXTURE_2D, 0, this.internalFormat, m[0], m[1], 0, this.textureFormat, this.textureType, null);
                                        }
                                        const { context: a, texture: o } = this;
                                        a.bindFramebuffer(a.FRAMEBUFFER, this.framebuffer()), a.bindTexture(a.TEXTURE_2D, o), d(a, o), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, o, 0), a.clearColor(0, 0, 0, 0), a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT);
                                    }
                                    delete() {
                                        this._deleted || (this._deleted = !0, !(this.texture._refs && (this.texture._refs--, this.texture._refs)) && this.context.deleteTexture(this.texture));
                                    }
                                    framebuffer() {
                                        return this._framebuffer || (this._framebuffer = this.kernel.getRawValueFramebuffer(this.size[0], this.size[1])), this._framebuffer;
                                    }
                                }
                                function d(l, a) {
                                    l.activeTexture(l.TEXTURE15), l.bindTexture(l.TEXTURE_2D, a), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MIN_FILTER, l.NEAREST), l.texParameteri(l.TEXTURE_2D, l.TEXTURE_MAG_FILTER, l.NEAREST);
                                }
                                i.exports = {
                                    GLTexture: p
                                };
                            },
                            {
                                "../../../texture": 113
                            }
                        ],
                        28: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureFloat: p } = e("./float");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "MemoryOptimizedNumberTexture";
                                    }
                                    toArray() {
                                        return u.erectMemoryOptimized2DFloat(this.renderValues(), this.output[0], this.output[1]);
                                    }
                                }
                                i.exports = {
                                    GLTextureMemoryOptimized2D: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./float": 25
                            }
                        ],
                        29: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureFloat: p } = e("./float");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "MemoryOptimizedNumberTexture";
                                    }
                                    toArray() {
                                        return u.erectMemoryOptimized3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
                                    }
                                }
                                i.exports = {
                                    GLTextureMemoryOptimized3D: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./float": 25
                            }
                        ],
                        30: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureFloat: p } = e("./float");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "MemoryOptimizedNumberTexture";
                                    }
                                    toArray() {
                                        return u.erectMemoryOptimizedFloat(this.renderValues(), this.output[0]);
                                    }
                                }
                                i.exports = {
                                    GLTextureMemoryOptimized: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./float": 25
                            }
                        ],
                        31: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureUnsigned: p } = e("./unsigned");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "NumberTexture";
                                    }
                                    toArray() {
                                        return u.erect2DPackedFloat(this.renderValues(), this.output[0], this.output[1]);
                                    }
                                }
                                i.exports = {
                                    GLTextureUnsigned2D: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./unsigned": 33
                            }
                        ],
                        32: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTextureUnsigned: p } = e("./unsigned");
                                class d extends p {
                                    constructor(a){
                                        super(a), this.type = "NumberTexture";
                                    }
                                    toArray() {
                                        return u.erect3DPackedFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
                                    }
                                }
                                i.exports = {
                                    GLTextureUnsigned3D: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./unsigned": 33
                            }
                        ],
                        33: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { GLTexture: p } = e("./index");
                                class d extends p {
                                    get textureType() {
                                        return this.context.UNSIGNED_BYTE;
                                    }
                                    constructor(a){
                                        super(a), this.type = "NumberTexture";
                                    }
                                    renderRawOutput() {
                                        const { context: a } = this;
                                        a.bindFramebuffer(a.FRAMEBUFFER, this.framebuffer()), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, this.texture, 0);
                                        const o = new Uint8Array(this.size[0] * this.size[1] * 4);
                                        return a.readPixels(0, 0, this.size[0], this.size[1], a.RGBA, a.UNSIGNED_BYTE, o), o;
                                    }
                                    renderValues() {
                                        return this._deleted ? null : new Float32Array(this.renderRawOutput().buffer);
                                    }
                                    toArray() {
                                        return u.erectPackedFloat(this.renderValues(), this.output[0]);
                                    }
                                }
                                i.exports = {
                                    GLTextureUnsigned: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./index": 27
                            }
                        ],
                        34: [
                            function(e, i, h) {
                                const u = e("gl"), { WebGLKernel: p } = e("../web-gl/kernel"), { glKernelString: d } = e("../gl/kernel-string");
                                let l = null, a = null, o = null, n = null, r = null;
                                class m extends p {
                                    static get isSupported() {
                                        return l !== null || (this.setupFeatureChecks(), l = o !== null), l;
                                    }
                                    static setupFeatureChecks() {
                                        if (a = null, n = null, typeof u == "function") try {
                                            if (o = u(2, 2, {
                                                preserveDrawingBuffer: !0
                                            }), !o || !o.getExtension) return;
                                            n = {
                                                STACKGL_resize_drawingbuffer: o.getExtension("STACKGL_resize_drawingbuffer"),
                                                STACKGL_destroy_context: o.getExtension("STACKGL_destroy_context"),
                                                OES_texture_float: o.getExtension("OES_texture_float"),
                                                OES_texture_float_linear: o.getExtension("OES_texture_float_linear"),
                                                OES_element_index_uint: o.getExtension("OES_element_index_uint"),
                                                WEBGL_draw_buffers: o.getExtension("WEBGL_draw_buffers"),
                                                WEBGL_color_buffer_float: o.getExtension("WEBGL_color_buffer_float")
                                            }, r = this.getFeatures();
                                        } catch (E) {
                                            console.warn(E);
                                        }
                                    }
                                    static isContextMatch(E) {
                                        try {
                                            return E.getParameter(E.RENDERER) === "ANGLE";
                                        } catch  {
                                            return !1;
                                        }
                                    }
                                    static getIsTextureFloat() {
                                        return !!n.OES_texture_float;
                                    }
                                    static getIsDrawBuffers() {
                                        return !!n.WEBGL_draw_buffers;
                                    }
                                    static getChannelCount() {
                                        return n.WEBGL_draw_buffers ? o.getParameter(n.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) : 1;
                                    }
                                    static getMaxTextureSize() {
                                        return o.getParameter(o.MAX_TEXTURE_SIZE);
                                    }
                                    static get testCanvas() {
                                        return a;
                                    }
                                    static get testContext() {
                                        return o;
                                    }
                                    static get features() {
                                        return r;
                                    }
                                    initCanvas() {
                                        return {};
                                    }
                                    initContext() {
                                        return u(2, 2, {
                                            preserveDrawingBuffer: !0
                                        });
                                    }
                                    initExtensions() {
                                        this.extensions = {
                                            STACKGL_resize_drawingbuffer: this.context.getExtension("STACKGL_resize_drawingbuffer"),
                                            STACKGL_destroy_context: this.context.getExtension("STACKGL_destroy_context"),
                                            OES_texture_float: this.context.getExtension("OES_texture_float"),
                                            OES_texture_float_linear: this.context.getExtension("OES_texture_float_linear"),
                                            OES_element_index_uint: this.context.getExtension("OES_element_index_uint"),
                                            WEBGL_draw_buffers: this.context.getExtension("WEBGL_draw_buffers")
                                        };
                                    }
                                    build() {
                                        super.build.apply(this, arguments), this.fallbackRequested || this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
                                    }
                                    destroyExtensions() {
                                        this.extensions.STACKGL_resize_drawingbuffer = null, this.extensions.STACKGL_destroy_context = null, this.extensions.OES_texture_float = null, this.extensions.OES_texture_float_linear = null, this.extensions.OES_element_index_uint = null, this.extensions.WEBGL_draw_buffers = null;
                                    }
                                    static destroyContext(E) {
                                        const w = E.getExtension("STACKGL_destroy_context");
                                        w && w.destroy && w.destroy();
                                    }
                                    toString() {
                                        return d(this.constructor, arguments, this, `const gl = context || require('gl')(1, 1);
`, `    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }
`);
                                    }
                                    setOutput(E) {
                                        return super.setOutput(E), this.graphical && this.extensions.STACKGL_resize_drawingbuffer && this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]), this;
                                    }
                                }
                                i.exports = {
                                    HeadlessGLKernel: m
                                };
                            },
                            {
                                "../gl/kernel-string": 12,
                                "../web-gl/kernel": 70,
                                gl: 2
                            }
                        ],
                        35: [
                            function(e, i, h) {
                                class u {
                                    constructor(d, l){
                                        const { name: a, kernel: o, context: n, checkContext: r, onRequestContextHandle: m, onUpdateValueMismatch: b, origin: E, strictIntegers: w, type: v, tactic: y } = l;
                                        if (!a) throw new Error("name not set");
                                        if (!v) throw new Error("type not set");
                                        if (!E) throw new Error("origin not set");
                                        if (E !== "user" && E !== "constants") throw new Error(`origin must be "user" or "constants" value is "${E}"`);
                                        if (!m) throw new Error("onRequestContextHandle is not set");
                                        this.name = a, this.origin = E, this.tactic = y, this.varName = E === "constants" ? `constants.${a}` : a, this.kernel = o, this.strictIntegers = w, this.type = d.type || v, this.size = d.size || null, this.index = null, this.context = n, this.checkContext = r ?? !0, this.contextHandle = null, this.onRequestContextHandle = m, this.onUpdateValueMismatch = b, this.forceUploadEachRun = null;
                                    }
                                    get id() {
                                        return `${this.origin}_${name}`;
                                    }
                                    getSource() {
                                        throw new Error(`"getSource" not defined on ${this.constructor.name}`);
                                    }
                                    updateValue(d) {
                                        throw new Error(`"updateValue" not defined on ${this.constructor.name}`);
                                    }
                                }
                                i.exports = {
                                    KernelValue: u
                                };
                            },
                            {}
                        ],
                        36: [
                            function(e, i, h) {
                                const { utils: u } = e("../utils"), { Input: p } = e("../input");
                                class d {
                                    static get isSupported() {
                                        throw new Error(`"isSupported" not implemented on ${this.name}`);
                                    }
                                    static isContextMatch(o) {
                                        throw new Error(`"isContextMatch" not implemented on ${this.name}`);
                                    }
                                    static getFeatures() {
                                        throw new Error(`"getFeatures" not implemented on ${this.name}`);
                                    }
                                    static destroyContext(o) {
                                        throw new Error(`"destroyContext" called on ${this.name}`);
                                    }
                                    static nativeFunctionArguments() {
                                        throw new Error(`"nativeFunctionArguments" called on ${this.name}`);
                                    }
                                    static nativeFunctionReturnType() {
                                        throw new Error(`"nativeFunctionReturnType" called on ${this.name}`);
                                    }
                                    static combineKernels() {
                                        throw new Error(`"combineKernels" called on ${this.name}`);
                                    }
                                    constructor(o, n){
                                        if (typeof o != "object") {
                                            if (typeof o != "string") throw new Error("source not a string");
                                            if (!u.isFunctionString(o)) throw new Error("source not a function string");
                                        }
                                        this.useLegacyEncoder = !1, this.fallbackRequested = !1, this.onRequestFallback = null, this.argumentNames = typeof o == "string" ? u.getArgumentNamesFromString(o) : null, this.argumentTypes = null, this.argumentSizes = null, this.argumentBitRatios = null, this.kernelArguments = null, this.kernelConstants = null, this.forceUploadKernelConstants = null, this.source = o, this.output = null, this.debug = !1, this.graphical = !1, this.loopMaxIterations = 0, this.constants = null, this.constantTypes = null, this.constantBitRatios = null, this.dynamicArguments = !1, this.dynamicOutput = !1, this.canvas = null, this.context = null, this.checkContext = null, this.gpu = null, this.functions = null, this.nativeFunctions = null, this.injectedNative = null, this.subKernels = null, this.validate = !0, this.immutable = !1, this.pipeline = !1, this.precision = null, this.tactic = null, this.plugins = null, this.returnType = null, this.leadingReturnStatement = null, this.followingReturnStatement = null, this.optimizeFloatMemory = null, this.strictIntegers = !1, this.fixIntegerDivisionAccuracy = null, this.built = !1, this.signature = null;
                                    }
                                    mergeSettings(o) {
                                        for(let n in o)if (!(!o.hasOwnProperty(n) || !this.hasOwnProperty(n))) {
                                            switch(n){
                                                case "output":
                                                    if (!Array.isArray(o.output)) {
                                                        this.setOutput(o.output);
                                                        continue;
                                                    }
                                                    break;
                                                case "functions":
                                                    this.functions = [];
                                                    for(let r = 0; r < o.functions.length; r++)this.addFunction(o.functions[r]);
                                                    continue;
                                                case "graphical":
                                                    o[n] && !o.hasOwnProperty("precision") && (this.precision = "unsigned"), this[n] = o[n];
                                                    continue;
                                                case "nativeFunctions":
                                                    if (!o.nativeFunctions) continue;
                                                    this.nativeFunctions = [];
                                                    for(let r = 0; r < o.nativeFunctions.length; r++){
                                                        const m = o.nativeFunctions[r], { name: b, source: E } = m;
                                                        this.addNativeFunction(b, E, m);
                                                    }
                                                    continue;
                                            }
                                            this[n] = o[n];
                                        }
                                        this.canvas || (this.canvas = this.initCanvas()), this.context || (this.context = this.initContext()), this.plugins || (this.plugins = this.initPlugins(o));
                                    }
                                    build() {
                                        throw new Error(`"build" not defined on ${this.constructor.name}`);
                                    }
                                    run() {
                                        throw new Error(`"run" not defined on ${this.constructor.name}`);
                                    }
                                    initCanvas() {
                                        throw new Error(`"initCanvas" not defined on ${this.constructor.name}`);
                                    }
                                    initContext() {
                                        throw new Error(`"initContext" not defined on ${this.constructor.name}`);
                                    }
                                    initPlugins(o) {
                                        throw new Error(`"initPlugins" not defined on ${this.constructor.name}`);
                                    }
                                    addFunction(o, n = {}) {
                                        if (o.name && o.source && o.argumentTypes && "returnType" in o) this.functions.push(o);
                                        else if ("settings" in o && "source" in o) this.functions.push(this.functionToIGPUFunction(o.source, o.settings));
                                        else if (typeof o == "string" || typeof o == "function") this.functions.push(this.functionToIGPUFunction(o, n));
                                        else throw new Error("function not properly defined");
                                        return this;
                                    }
                                    addNativeFunction(o, n, r = {}) {
                                        const { argumentTypes: m, argumentNames: b } = r.argumentTypes ? l(r.argumentTypes) : this.constructor.nativeFunctionArguments(n) || {};
                                        return this.nativeFunctions.push({
                                            name: o,
                                            source: n,
                                            settings: r,
                                            argumentTypes: m,
                                            argumentNames: b,
                                            returnType: r.returnType || this.constructor.nativeFunctionReturnType(n)
                                        }), this;
                                    }
                                    setupArguments(o) {
                                        if (this.kernelArguments = [], this.argumentTypes) for(let n = 0; n < this.argumentTypes.length; n++)this.kernelArguments.push({
                                            type: this.argumentTypes[n]
                                        });
                                        else if (!this.argumentTypes) {
                                            this.argumentTypes = [];
                                            for(let n = 0; n < o.length; n++){
                                                const r = u.getVariableType(o[n], this.strictIntegers), m = r === "Integer" ? "Number" : r;
                                                this.argumentTypes.push(m), this.kernelArguments.push({
                                                    type: m
                                                });
                                            }
                                        }
                                        this.argumentSizes = new Array(o.length), this.argumentBitRatios = new Int32Array(o.length);
                                        for(let n = 0; n < o.length; n++){
                                            const r = o[n];
                                            this.argumentSizes[n] = r.constructor === p ? r.size : null, this.argumentBitRatios[n] = this.getBitRatio(r);
                                        }
                                        if (this.argumentNames.length !== o.length) throw new Error("arguments are miss-aligned");
                                    }
                                    setupConstants() {
                                        this.kernelConstants = [];
                                        let o = this.constantTypes === null;
                                        if (o && (this.constantTypes = {}), this.constantBitRatios = {}, this.constants) for(let n in this.constants){
                                            if (o) {
                                                const r = u.getVariableType(this.constants[n], this.strictIntegers);
                                                this.constantTypes[n] = r, this.kernelConstants.push({
                                                    name: n,
                                                    type: r
                                                });
                                            } else this.kernelConstants.push({
                                                name: n,
                                                type: this.constantTypes[n]
                                            });
                                            this.constantBitRatios[n] = this.getBitRatio(this.constants[n]);
                                        }
                                    }
                                    setOptimizeFloatMemory(o) {
                                        return this.optimizeFloatMemory = o, this;
                                    }
                                    toKernelOutput(o) {
                                        return o.hasOwnProperty("x") ? o.hasOwnProperty("y") ? o.hasOwnProperty("z") ? [
                                            o.x,
                                            o.y,
                                            o.z
                                        ] : [
                                            o.x,
                                            o.y
                                        ] : [
                                            o.x
                                        ] : o;
                                    }
                                    setOutput(o) {
                                        return this.output = this.toKernelOutput(o), this;
                                    }
                                    setDebug(o) {
                                        return this.debug = o, this;
                                    }
                                    setGraphical(o) {
                                        return this.graphical = o, this.precision = "unsigned", this;
                                    }
                                    setLoopMaxIterations(o) {
                                        return this.loopMaxIterations = o, this;
                                    }
                                    setConstants(o) {
                                        return this.constants = o, this;
                                    }
                                    setConstantTypes(o) {
                                        return this.constantTypes = o, this;
                                    }
                                    setFunctions(o) {
                                        for(let n = 0; n < o.length; n++)this.addFunction(o[n]);
                                        return this;
                                    }
                                    setNativeFunctions(o) {
                                        for(let n = 0; n < o.length; n++){
                                            const r = o[n], { name: m, source: b } = r;
                                            this.addNativeFunction(m, b, r);
                                        }
                                        return this;
                                    }
                                    setInjectedNative(o) {
                                        return this.injectedNative = o, this;
                                    }
                                    setPipeline(o) {
                                        return this.pipeline = o, this;
                                    }
                                    setPrecision(o) {
                                        return this.precision = o, this;
                                    }
                                    setDimensions(o) {
                                        return u.warnDeprecated("method", "setDimensions", "setOutput"), this.output = o, this;
                                    }
                                    setOutputToTexture(o) {
                                        return u.warnDeprecated("method", "setOutputToTexture", "setPipeline"), this.pipeline = o, this;
                                    }
                                    setImmutable(o) {
                                        return this.immutable = o, this;
                                    }
                                    setCanvas(o) {
                                        return this.canvas = o, this;
                                    }
                                    setStrictIntegers(o) {
                                        return this.strictIntegers = o, this;
                                    }
                                    setDynamicOutput(o) {
                                        return this.dynamicOutput = o, this;
                                    }
                                    setHardcodeConstants(o) {
                                        return u.warnDeprecated("method", "setHardcodeConstants"), this.setDynamicOutput(o), this.setDynamicArguments(o), this;
                                    }
                                    setDynamicArguments(o) {
                                        return this.dynamicArguments = o, this;
                                    }
                                    setUseLegacyEncoder(o) {
                                        return this.useLegacyEncoder = o, this;
                                    }
                                    setWarnVarUsage(o) {
                                        return u.warnDeprecated("method", "setWarnVarUsage"), this;
                                    }
                                    getCanvas() {
                                        return u.warnDeprecated("method", "getCanvas"), this.canvas;
                                    }
                                    getWebGl() {
                                        return u.warnDeprecated("method", "getWebGl"), this.context;
                                    }
                                    setContext(o) {
                                        return this.context = o, this;
                                    }
                                    setArgumentTypes(o) {
                                        if (Array.isArray(o)) this.argumentTypes = o;
                                        else {
                                            this.argumentTypes = [];
                                            for(const n in o){
                                                if (!o.hasOwnProperty(n)) continue;
                                                const r = this.argumentNames.indexOf(n);
                                                if (r === -1) throw new Error(`unable to find argument ${n}`);
                                                this.argumentTypes[r] = o[n];
                                            }
                                        }
                                        return this;
                                    }
                                    setTactic(o) {
                                        return this.tactic = o, this;
                                    }
                                    requestFallback(o) {
                                        if (!this.onRequestFallback) throw new Error(`"onRequestFallback" not defined on ${this.constructor.name}`);
                                        return this.fallbackRequested = !0, this.onRequestFallback(o);
                                    }
                                    validateSettings() {
                                        throw new Error(`"validateSettings" not defined on ${this.constructor.name}`);
                                    }
                                    addSubKernel(o) {
                                        if (this.subKernels === null && (this.subKernels = []), !o.source) throw new Error('subKernel missing "source" property');
                                        if (!o.property && isNaN(o.property)) throw new Error('subKernel missing "property" property');
                                        if (!o.name) throw new Error('subKernel missing "name" property');
                                        return this.subKernels.push(o), this;
                                    }
                                    destroy(o) {
                                        throw new Error(`"destroy" called on ${this.constructor.name}`);
                                    }
                                    getBitRatio(o) {
                                        if (this.precision === "single") return 4;
                                        if (Array.isArray(o[0])) return this.getBitRatio(o[0]);
                                        if (o.constructor === p) return this.getBitRatio(o.value);
                                        switch(o.constructor){
                                            case Uint8ClampedArray:
                                            case Uint8Array:
                                            case Int8Array:
                                                return 1;
                                            case Uint16Array:
                                            case Int16Array:
                                                return 2;
                                            case Float32Array:
                                            case Int32Array:
                                            default:
                                                return 4;
                                        }
                                    }
                                    getPixels(o) {
                                        throw new Error(`"getPixels" called on ${this.constructor.name}`);
                                    }
                                    checkOutput() {
                                        if (!this.output || !u.isArray(this.output)) throw new Error("kernel.output not an array");
                                        if (this.output.length < 1) throw new Error("kernel.output is empty, needs at least 1 value");
                                        for(let o = 0; o < this.output.length; o++)if (isNaN(this.output[o]) || this.output[o] < 1) throw new Error(`${this.constructor.name}.output[${o}] incorrectly defined as \`${this.output[o]}\`, needs to be numeric, and greater than 0`);
                                    }
                                    prependString(o) {
                                        throw new Error(`"prependString" called on ${this.constructor.name}`);
                                    }
                                    hasPrependString(o) {
                                        throw new Error(`"hasPrependString" called on ${this.constructor.name}`);
                                    }
                                    toJSON() {
                                        return {
                                            settings: {
                                                output: this.output,
                                                pipeline: this.pipeline,
                                                argumentNames: this.argumentNames,
                                                argumentsTypes: this.argumentTypes,
                                                constants: this.constants,
                                                pluginNames: this.plugins ? this.plugins.map((o)=>o.name) : null,
                                                returnType: this.returnType
                                            }
                                        };
                                    }
                                    buildSignature(o) {
                                        const n = this.constructor;
                                        this.signature = n.getSignature(this, n.getArgumentTypes(this, o));
                                    }
                                    static getArgumentTypes(o, n) {
                                        const r = new Array(n.length);
                                        for(let m = 0; m < n.length; m++){
                                            const b = n[m], E = o.argumentTypes[m];
                                            if (b.type) r[m] = b.type;
                                            else switch(E){
                                                case "Number":
                                                case "Integer":
                                                case "Float":
                                                case "ArrayTexture(1)":
                                                    r[m] = u.getVariableType(b);
                                                    break;
                                                default:
                                                    r[m] = E;
                                            }
                                        }
                                        return r;
                                    }
                                    static getSignature(o, n) {
                                        throw new Error(`"getSignature" not implemented on ${this.name}`);
                                    }
                                    functionToIGPUFunction(o, n = {}) {
                                        if (typeof o != "string" && typeof o != "function") throw new Error("source not a string or function");
                                        const r = typeof o == "string" ? o : o.toString();
                                        let m = [];
                                        return Array.isArray(n.argumentTypes) ? m = n.argumentTypes : typeof n.argumentTypes == "object" ? m = u.getArgumentNamesFromString(r).map((b)=>n.argumentTypes[b]) || [] : m = n.argumentTypes || [], {
                                            name: u.getFunctionNameFromString(r) || null,
                                            source: r,
                                            argumentTypes: m,
                                            returnType: n.returnType || null
                                        };
                                    }
                                    onActivate(o) {}
                                }
                                function l(a) {
                                    const o = Object.keys(a), n = [];
                                    for(let r = 0; r < o.length; r++){
                                        const m = o[r];
                                        n.push(a[m]);
                                    }
                                    return {
                                        argumentTypes: n,
                                        argumentNames: o
                                    };
                                }
                                i.exports = {
                                    Kernel: d
                                };
                            },
                            {
                                "../input": 110,
                                "../utils": 114
                            }
                        ],
                        37: [
                            function(e, i, h) {
                                const u = `__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

varying vec2 vTexCoord;

float acosh(float x) {
  return log(x + sqrt(x * x - 1.0));
}

float sinh(float x) {
  return (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;
}

float asinh(float x) {
  return log(x + sqrt(x * x + 1.0));
}

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float atanh(float x) {
  x = (x + 1.0) / (x - 1.0);
  if (x < 0.0) {
    return 0.5 * log(-x);
  }
  return 0.5 * log(x);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float cosh(float x) {
  return (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; 
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float tanh(float x) {
  float e = exp(2.0 * x);
  return (e - 1.0) / (e + 1.0);
}

float trunc(float x) {
  if (x >= 0.0) {
    return floor(x); 
  } else {
    return ceil(x);
  }
}

vec4 _round(vec4 x) {
  return floor(x + 0.5);
}

float _round(float x) {
  return floor(x + 0.5);
}

const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x / y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(_round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;
  if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;
  return 0.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  if (channel == 0) return texel.r * 255.0;
  if (channel == 1) return texel.g * 255.0;
  if (channel == 2) return texel.b * 255.0;
  if (channel == 3) return texel.a * 255.0;
  return 0.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return texel.r;
  if (channel == 1) return texel.g;
  if (channel == 2) return texel.b;
  if (channel == 3) return texel.a;
  return 0.0;
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture2D(tex, st / vec2(texSize));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));
  
  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

void color(sampler2D image) {
  actualColor = texture2D(image, vTexCoord);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;
                                i.exports = {
                                    fragmentShader: u
                                };
                            },
                            {}
                        ],
                        38: [
                            function(e, i, h) {
                                const { utils: u } = e("../../utils"), { FunctionNode: p } = e("../function-node");
                                class d extends p {
                                    constructor(n, r){
                                        super(n, r), r && r.hasOwnProperty("fixIntegerDivisionAccuracy") && (this.fixIntegerDivisionAccuracy = r.fixIntegerDivisionAccuracy);
                                    }
                                    astConditionalExpression(n, r) {
                                        if (n.type !== "ConditionalExpression") throw this.astErrorOutput("Not a conditional expression", n);
                                        const m = this.getType(n.consequent), b = this.getType(n.alternate);
                                        return m === null && b === null ? (r.push("if ("), this.astGeneric(n.test, r), r.push(") {"), this.astGeneric(n.consequent, r), r.push(";"), r.push("} else {"), this.astGeneric(n.alternate, r), r.push(";"), r.push("}"), r) : (r.push("("), this.astGeneric(n.test, r), r.push("?"), this.astGeneric(n.consequent, r), r.push(":"), this.astGeneric(n.alternate, r), r.push(")"), r);
                                    }
                                    astFunction(n, r) {
                                        if (this.isRootKernel) r.push("void");
                                        else {
                                            this.returnType || this.findLastReturn() && (this.returnType = this.getType(n.body), this.returnType === "LiteralInteger" && (this.returnType = "Number"));
                                            const { returnType: m } = this;
                                            if (!m) r.push("void");
                                            else {
                                                const b = l[m];
                                                if (!b) throw new Error(`unknown type ${m}`);
                                                r.push(b);
                                            }
                                        }
                                        if (r.push(" "), r.push(this.name), r.push("("), !this.isRootKernel) for(let m = 0; m < this.argumentNames.length; ++m){
                                            const b = this.argumentNames[m];
                                            m > 0 && r.push(", ");
                                            let E = this.argumentTypes[this.argumentNames.indexOf(b)];
                                            if (!E) throw this.astErrorOutput(`Unknown argument ${b} type`, n);
                                            E === "LiteralInteger" && (this.argumentTypes[m] = E = "Number");
                                            const w = l[E];
                                            if (!w) throw this.astErrorOutput("Unexpected expression", n);
                                            const v = u.sanitizeName(b);
                                            w === "sampler2D" || w === "sampler2DArray" ? r.push(`${w} user_${v},ivec2 user_${v}Size,ivec3 user_${v}Dim`) : r.push(`${w} user_${v}`);
                                        }
                                        r.push(`) {
`);
                                        for(let m = 0; m < n.body.body.length; ++m)this.astGeneric(n.body.body[m], r), r.push(`
`);
                                        return r.push(`}
`), r;
                                    }
                                    astReturnStatement(n, r) {
                                        if (!n.argument) throw this.astErrorOutput("Unexpected return statement", n);
                                        this.pushState("skip-literal-correction");
                                        const m = this.getType(n.argument);
                                        this.popState("skip-literal-correction");
                                        const b = [];
                                        switch(this.returnType || (m === "LiteralInteger" || m === "Integer" ? this.returnType = "Number" : this.returnType = m), this.returnType){
                                            case "LiteralInteger":
                                            case "Number":
                                            case "Float":
                                                switch(m){
                                                    case "Integer":
                                                        b.push("float("), this.astGeneric(n.argument, b), b.push(")");
                                                        break;
                                                    case "LiteralInteger":
                                                        this.castLiteralToFloat(n.argument, b), this.getType(n) === "Integer" && (b.unshift("float("), b.push(")"));
                                                        break;
                                                    default:
                                                        this.astGeneric(n.argument, b);
                                                }
                                                break;
                                            case "Integer":
                                                switch(m){
                                                    case "Float":
                                                    case "Number":
                                                        this.castValueToInteger(n.argument, b);
                                                        break;
                                                    case "LiteralInteger":
                                                        this.castLiteralToInteger(n.argument, b);
                                                        break;
                                                    default:
                                                        this.astGeneric(n.argument, b);
                                                }
                                                break;
                                            case "Array(4)":
                                            case "Array(3)":
                                            case "Array(2)":
                                            case "Matrix(2)":
                                            case "Matrix(3)":
                                            case "Matrix(4)":
                                            case "Input":
                                                this.astGeneric(n.argument, b);
                                                break;
                                            default:
                                                throw this.astErrorOutput(`unhandled return type ${this.returnType}`, n);
                                        }
                                        return this.isRootKernel ? (r.push(`kernelResult = ${b.join("")};`), r.push("return;")) : this.isSubKernel ? (r.push(`subKernelResult_${this.name} = ${b.join("")};`), r.push(`return subKernelResult_${this.name};`)) : r.push(`return ${b.join("")};`), r;
                                    }
                                    astLiteral(n, r) {
                                        if (isNaN(n.value)) throw this.astErrorOutput("Non-numeric literal not supported : " + n.value, n);
                                        const m = this.astKey(n);
                                        return Number.isInteger(n.value) ? this.isState("casting-to-integer") || this.isState("building-integer") ? (this.literalTypes[m] = "Integer", r.push(`${n.value}`)) : this.isState("casting-to-float") || this.isState("building-float") ? (this.literalTypes[m] = "Number", r.push(`${n.value}.0`)) : (this.literalTypes[m] = "Number", r.push(`${n.value}.0`)) : this.isState("casting-to-integer") || this.isState("building-integer") ? (this.literalTypes[m] = "Integer", r.push(Math.round(n.value))) : (this.literalTypes[m] = "Number", r.push(`${n.value}`)), r;
                                    }
                                    astBinaryExpression(n, r) {
                                        if (this.checkAndUpconvertOperator(n, r)) return r;
                                        if (this.fixIntegerDivisionAccuracy && n.operator === "/") {
                                            switch(r.push("divWithIntCheck("), this.pushState("building-float"), this.getType(n.left)){
                                                case "Integer":
                                                    this.castValueToFloat(n.left, r);
                                                    break;
                                                case "LiteralInteger":
                                                    this.castLiteralToFloat(n.left, r);
                                                    break;
                                                default:
                                                    this.astGeneric(n.left, r);
                                            }
                                            switch(r.push(", "), this.getType(n.right)){
                                                case "Integer":
                                                    this.castValueToFloat(n.right, r);
                                                    break;
                                                case "LiteralInteger":
                                                    this.castLiteralToFloat(n.right, r);
                                                    break;
                                                default:
                                                    this.astGeneric(n.right, r);
                                            }
                                            return this.popState("building-float"), r.push(")"), r;
                                        }
                                        r.push("(");
                                        const m = this.getType(n.left) || "Number", b = this.getType(n.right) || "Number", E = m + " & " + b;
                                        switch(E){
                                            case "Integer & Integer":
                                                this.pushState("building-integer"), this.astGeneric(n.left, r), r.push(a[n.operator] || n.operator), this.astGeneric(n.right, r), this.popState("building-integer");
                                                break;
                                            case "Number & Float":
                                            case "Float & Number":
                                            case "Float & Float":
                                            case "Number & Number":
                                                this.pushState("building-float"), this.astGeneric(n.left, r), r.push(a[n.operator] || n.operator), this.astGeneric(n.right, r), this.popState("building-float");
                                                break;
                                            case "LiteralInteger & LiteralInteger":
                                                this.isState("casting-to-integer") || this.isState("building-integer") ? (this.pushState("building-integer"), this.astGeneric(n.left, r), r.push(a[n.operator] || n.operator), this.astGeneric(n.right, r), this.popState("building-integer")) : (this.pushState("building-float"), this.castLiteralToFloat(n.left, r), r.push(a[n.operator] || n.operator), this.castLiteralToFloat(n.right, r), this.popState("building-float"));
                                                break;
                                            case "Integer & Float":
                                            case "Integer & Number":
                                                if ((n.operator === ">" || n.operator === "<" && n.right.type === "Literal") && !Number.isInteger(n.right.value)) {
                                                    this.pushState("building-float"), this.castValueToFloat(n.left, r), r.push(a[n.operator] || n.operator), this.astGeneric(n.right, r), this.popState("building-float");
                                                    break;
                                                }
                                                if (this.pushState("building-integer"), this.astGeneric(n.left, r), r.push(a[n.operator] || n.operator), this.pushState("casting-to-integer"), n.right.type === "Literal") {
                                                    const w = [];
                                                    if (this.astGeneric(n.right, w), this.getType(n.right) === "Integer") r.push(w.join(""));
                                                    else throw this.astErrorOutput("Unhandled binary expression with literal", n);
                                                } else r.push("int("), this.astGeneric(n.right, r), r.push(")");
                                                this.popState("casting-to-integer"), this.popState("building-integer");
                                                break;
                                            case "Integer & LiteralInteger":
                                                this.pushState("building-integer"), this.astGeneric(n.left, r), r.push(a[n.operator] || n.operator), this.castLiteralToInteger(n.right, r), this.popState("building-integer");
                                                break;
                                            case "Number & Integer":
                                                this.pushState("building-float"), this.astGeneric(n.left, r), r.push(a[n.operator] || n.operator), this.castValueToFloat(n.right, r), this.popState("building-float");
                                                break;
                                            case "Float & LiteralInteger":
                                            case "Number & LiteralInteger":
                                                this.pushState("building-float"), this.astGeneric(n.left, r), r.push(a[n.operator] || n.operator), this.castLiteralToFloat(n.right, r), this.popState("building-float");
                                                break;
                                            case "LiteralInteger & Float":
                                            case "LiteralInteger & Number":
                                                this.isState("casting-to-integer") ? (this.pushState("building-integer"), this.castLiteralToInteger(n.left, r), r.push(a[n.operator] || n.operator), this.castValueToInteger(n.right, r), this.popState("building-integer")) : (this.pushState("building-float"), this.astGeneric(n.left, r), r.push(a[n.operator] || n.operator), this.pushState("casting-to-float"), this.astGeneric(n.right, r), this.popState("casting-to-float"), this.popState("building-float"));
                                                break;
                                            case "LiteralInteger & Integer":
                                                this.pushState("building-integer"), this.castLiteralToInteger(n.left, r), r.push(a[n.operator] || n.operator), this.astGeneric(n.right, r), this.popState("building-integer");
                                                break;
                                            case "Boolean & Boolean":
                                                this.pushState("building-boolean"), this.astGeneric(n.left, r), r.push(a[n.operator] || n.operator), this.astGeneric(n.right, r), this.popState("building-boolean");
                                                break;
                                            case "Float & Integer":
                                                this.pushState("building-float"), this.astGeneric(n.left, r), r.push(a[n.operator] || n.operator), this.castValueToFloat(n.right, r), this.popState("building-float");
                                                break;
                                            default:
                                                throw this.astErrorOutput(`Unhandled binary expression between ${E}`, n);
                                        }
                                        return r.push(")"), r;
                                    }
                                    checkAndUpconvertOperator(n, r) {
                                        const m = this.checkAndUpconvertBitwiseOperators(n, r);
                                        if (m) return m;
                                        const E = {
                                            "%": this.fixIntegerDivisionAccuracy ? "integerCorrectionModulo" : "modulo",
                                            "**": "pow"
                                        }[n.operator];
                                        if (!E) return null;
                                        switch(r.push(E), r.push("("), this.getType(n.left)){
                                            case "Integer":
                                                this.castValueToFloat(n.left, r);
                                                break;
                                            case "LiteralInteger":
                                                this.castLiteralToFloat(n.left, r);
                                                break;
                                            default:
                                                this.astGeneric(n.left, r);
                                        }
                                        switch(r.push(","), this.getType(n.right)){
                                            case "Integer":
                                                this.castValueToFloat(n.right, r);
                                                break;
                                            case "LiteralInteger":
                                                this.castLiteralToFloat(n.right, r);
                                                break;
                                            default:
                                                this.astGeneric(n.right, r);
                                        }
                                        return r.push(")"), r;
                                    }
                                    checkAndUpconvertBitwiseOperators(n, r) {
                                        const b = {
                                            "&": "bitwiseAnd",
                                            "|": "bitwiseOr",
                                            "^": "bitwiseXOR",
                                            "<<": "bitwiseZeroFillLeftShift",
                                            ">>": "bitwiseSignedRightShift",
                                            ">>>": "bitwiseZeroFillRightShift"
                                        }[n.operator];
                                        if (!b) return null;
                                        switch(r.push(b), r.push("("), this.getType(n.left)){
                                            case "Number":
                                            case "Float":
                                                this.castValueToInteger(n.left, r);
                                                break;
                                            case "LiteralInteger":
                                                this.castLiteralToInteger(n.left, r);
                                                break;
                                            default:
                                                this.astGeneric(n.left, r);
                                        }
                                        switch(r.push(","), this.getType(n.right)){
                                            case "Number":
                                            case "Float":
                                                this.castValueToInteger(n.right, r);
                                                break;
                                            case "LiteralInteger":
                                                this.castLiteralToInteger(n.right, r);
                                                break;
                                            default:
                                                this.astGeneric(n.right, r);
                                        }
                                        return r.push(")"), r;
                                    }
                                    checkAndUpconvertBitwiseUnary(n, r) {
                                        const b = {
                                            "~": "bitwiseNot"
                                        }[n.operator];
                                        if (!b) return null;
                                        switch(r.push(b), r.push("("), this.getType(n.argument)){
                                            case "Number":
                                            case "Float":
                                                this.castValueToInteger(n.argument, r);
                                                break;
                                            case "LiteralInteger":
                                                this.castLiteralToInteger(n.argument, r);
                                                break;
                                            default:
                                                this.astGeneric(n.argument, r);
                                        }
                                        return r.push(")"), r;
                                    }
                                    castLiteralToInteger(n, r) {
                                        return this.pushState("casting-to-integer"), this.astGeneric(n, r), this.popState("casting-to-integer"), r;
                                    }
                                    castLiteralToFloat(n, r) {
                                        return this.pushState("casting-to-float"), this.astGeneric(n, r), this.popState("casting-to-float"), r;
                                    }
                                    castValueToInteger(n, r) {
                                        return this.pushState("casting-to-integer"), r.push("int("), this.astGeneric(n, r), r.push(")"), this.popState("casting-to-integer"), r;
                                    }
                                    castValueToFloat(n, r) {
                                        return this.pushState("casting-to-float"), r.push("float("), this.astGeneric(n, r), r.push(")"), this.popState("casting-to-float"), r;
                                    }
                                    astIdentifierExpression(n, r) {
                                        if (n.type !== "Identifier") throw this.astErrorOutput("IdentifierExpression - not an Identifier", n);
                                        const m = this.getType(n), b = u.sanitizeName(n.name);
                                        return n.name === "Infinity" ? r.push("3.402823466e+38") : m === "Boolean" ? this.argumentNames.indexOf(b) > -1 ? r.push(`bool(user_${b})`) : r.push(`user_${b}`) : r.push(`user_${b}`), r;
                                    }
                                    astForStatement(n, r) {
                                        if (n.type !== "ForStatement") throw this.astErrorOutput("Invalid for statement", n);
                                        const m = [], b = [], E = [], w = [];
                                        let v = null;
                                        if (n.init) {
                                            const { declarations: y } = n.init;
                                            y.length > 1 && (v = !1), this.astGeneric(n.init, m);
                                            for(let T = 0; T < y.length; T++)y[T].init && y[T].init.type !== "Literal" && (v = !1);
                                        } else v = !1;
                                        if (n.test ? this.astGeneric(n.test, b) : v = !1, n.update ? this.astGeneric(n.update, E) : v = !1, n.body && (this.pushState("loop-body"), this.astGeneric(n.body, w), this.popState("loop-body")), v === null && (v = this.isSafe(n.init) && this.isSafe(n.test)), v) {
                                            const y = m.join(""), T = y[y.length - 1] !== ";";
                                            r.push(`for (${y}${T ? ";" : ""}${b.join("")};${E.join("")}){
`), r.push(w.join("")), r.push(`}
`);
                                        } else {
                                            const y = this.getInternalVariableName("safeI");
                                            m.length > 0 && r.push(m.join(""), `
`), r.push(`for (int ${y}=0;${y}<LOOP_MAX;${y}++){
`), b.length > 0 && r.push(`if (!${b.join("")}) break;
`), r.push(w.join("")), r.push(`
${E.join("")};`), r.push(`}
`);
                                        }
                                        return r;
                                    }
                                    astWhileStatement(n, r) {
                                        if (n.type !== "WhileStatement") throw this.astErrorOutput("Invalid while statement", n);
                                        const m = this.getInternalVariableName("safeI");
                                        return r.push(`for (int ${m}=0;${m}<LOOP_MAX;${m}++){
`), r.push("if (!"), this.astGeneric(n.test, r), r.push(`) break;
`), this.astGeneric(n.body, r), r.push(`}
`), r;
                                    }
                                    astDoWhileStatement(n, r) {
                                        if (n.type !== "DoWhileStatement") throw this.astErrorOutput("Invalid while statement", n);
                                        const m = this.getInternalVariableName("safeI");
                                        return r.push(`for (int ${m}=0;${m}<LOOP_MAX;${m}++){
`), this.astGeneric(n.body, r), r.push("if (!"), this.astGeneric(n.test, r), r.push(`) break;
`), r.push(`}
`), r;
                                    }
                                    astAssignmentExpression(n, r) {
                                        if (n.operator === "%=") this.astGeneric(n.left, r), r.push("="), r.push("mod("), this.astGeneric(n.left, r), r.push(","), this.astGeneric(n.right, r), r.push(")");
                                        else if (n.operator === "**=") this.astGeneric(n.left, r), r.push("="), r.push("pow("), this.astGeneric(n.left, r), r.push(","), this.astGeneric(n.right, r), r.push(")");
                                        else {
                                            const m = this.getType(n.left), b = this.getType(n.right);
                                            return this.astGeneric(n.left, r), r.push(n.operator), m !== "Integer" && b === "Integer" ? (r.push("float("), this.astGeneric(n.right, r), r.push(")")) : this.astGeneric(n.right, r), r;
                                        }
                                    }
                                    astBlockStatement(n, r) {
                                        if (this.isState("loop-body")) {
                                            this.pushState("block-body");
                                            for(let m = 0; m < n.body.length; m++)this.astGeneric(n.body[m], r);
                                            this.popState("block-body");
                                        } else {
                                            r.push(`{
`);
                                            for(let m = 0; m < n.body.length; m++)this.astGeneric(n.body[m], r);
                                            r.push(`}
`);
                                        }
                                        return r;
                                    }
                                    astVariableDeclaration(n, r) {
                                        const m = n.declarations;
                                        if (!m || !m[0] || !m[0].init) throw this.astErrorOutput("Unexpected expression", n);
                                        const b = [];
                                        let E = null;
                                        const w = [];
                                        let v = [];
                                        for(let y = 0; y < m.length; y++){
                                            const T = m[y], _ = T.init, k = this.getDeclaration(T.id), C = this.getType(T.init);
                                            let M = C;
                                            M === "LiteralInteger" && (k.suggestedType === "Integer" ? M = "Integer" : M = "Number");
                                            const x = l[M];
                                            if (!x) throw this.astErrorOutput(`Markup type ${M} not handled`, n);
                                            const g = [];
                                            if (C === "Integer" && M === "Integer") {
                                                if (k.valueType = "Number", y === 0 || E === null) g.push("float ");
                                                else if (M !== E) throw new Error("Unhandled declaration");
                                                E = M, g.push(`user_${u.sanitizeName(T.id.name)}=`), g.push("float("), this.astGeneric(_, g), g.push(")");
                                            } else k.valueType = M, y === 0 || E === null ? g.push(`${x} `) : M !== E && (w.push(v.join(",")), v = [], g.push(`${x} `)), E = M, g.push(`user_${u.sanitizeName(T.id.name)}=`), C === "Number" && M === "Integer" ? _.left && _.left.type === "Literal" ? this.astGeneric(_, g) : (g.push("int("), this.astGeneric(_, g), g.push(")")) : C === "LiteralInteger" && M === "Integer" ? this.castLiteralToInteger(_, g) : this.astGeneric(_, g);
                                            v.push(g.join(""));
                                        }
                                        return v.length > 0 && w.push(v.join(",")), b.push(w.join(";")), r.push(b.join("")), r.push(";"), r;
                                    }
                                    astIfStatement(n, r) {
                                        return r.push("if ("), this.astGeneric(n.test, r), r.push(")"), n.consequent.type === "BlockStatement" ? this.astGeneric(n.consequent, r) : (r.push(` {
`), this.astGeneric(n.consequent, r), r.push(`
}
`)), n.alternate && (r.push("else "), n.alternate.type === "BlockStatement" || n.alternate.type === "IfStatement" ? this.astGeneric(n.alternate, r) : (r.push(` {
`), this.astGeneric(n.alternate, r), r.push(`
}
`))), r;
                                    }
                                    astSwitchStatement(n, r) {
                                        if (n.type !== "SwitchStatement") throw this.astErrorOutput("Invalid switch statement", n);
                                        const { discriminant: m, cases: b } = n, E = this.getType(m), w = `switchDiscriminant${this.astKey(n, "_")}`;
                                        switch(E){
                                            case "Float":
                                            case "Number":
                                                r.push(`float ${w} = `), this.astGeneric(m, r), r.push(`;
`);
                                                break;
                                            case "Integer":
                                                r.push(`int ${w} = `), this.astGeneric(m, r), r.push(`;
`);
                                                break;
                                        }
                                        if (b.length === 1 && !b[0].test) return this.astGeneric(b[0].consequent, r), r;
                                        let v = !1, y = [], T = !1, _ = !1;
                                        for(let k = 0; k < b.length; k++){
                                            if (b[k].test) {
                                                if (k === 0 || !_ ? (_ = !0, r.push(`if (${w} == `)) : v ? (r.push(`${w} == `), v = !1) : r.push(` else if (${w} == `), E === "Integer") switch(this.getType(b[k].test)){
                                                    case "Number":
                                                    case "Float":
                                                        this.castValueToInteger(b[k].test, r);
                                                        break;
                                                    case "LiteralInteger":
                                                        this.castLiteralToInteger(b[k].test, r);
                                                        break;
                                                }
                                                else if (E === "Float") switch(this.getType(b[k].test)){
                                                    case "LiteralInteger":
                                                        this.castLiteralToFloat(b[k].test, r);
                                                        break;
                                                    case "Integer":
                                                        this.castValueToFloat(b[k].test, r);
                                                        break;
                                                }
                                                else throw new Error("unhanlded");
                                                if (!b[k].consequent || b[k].consequent.length === 0) {
                                                    v = !0, r.push(" || ");
                                                    continue;
                                                }
                                                r.push(`) {
`);
                                            } else if (b.length > k + 1) {
                                                T = !0, this.astGeneric(b[k].consequent, y);
                                                continue;
                                            } else r.push(` else {
`);
                                            this.astGeneric(b[k].consequent, r), r.push(`
}`);
                                        }
                                        return T && (r.push(" else {"), r.push(y.join("")), r.push("}")), r;
                                    }
                                    astThisExpression(n, r) {
                                        return r.push("this"), r;
                                    }
                                    astMemberExpression(n, r) {
                                        const { property: m, name: b, signature: E, origin: w, type: v, xProperty: y, yProperty: T, zProperty: _ } = this.getMemberExpressionDetails(n);
                                        switch(E){
                                            case "value.thread.value":
                                            case "this.thread.value":
                                                if (b !== "x" && b !== "y" && b !== "z") throw this.astErrorOutput("Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`", n);
                                                return r.push(`threadId.${b}`), r;
                                            case "this.output.value":
                                                if (this.dynamicOutput) switch(b){
                                                    case "x":
                                                        this.isState("casting-to-float") ? r.push("float(uOutputDim.x)") : r.push("uOutputDim.x");
                                                        break;
                                                    case "y":
                                                        this.isState("casting-to-float") ? r.push("float(uOutputDim.y)") : r.push("uOutputDim.y");
                                                        break;
                                                    case "z":
                                                        this.isState("casting-to-float") ? r.push("float(uOutputDim.z)") : r.push("uOutputDim.z");
                                                        break;
                                                    default:
                                                        throw this.astErrorOutput("Unexpected expression", n);
                                                }
                                                else switch(b){
                                                    case "x":
                                                        this.isState("casting-to-integer") ? r.push(this.output[0]) : r.push(this.output[0], ".0");
                                                        break;
                                                    case "y":
                                                        this.isState("casting-to-integer") ? r.push(this.output[1]) : r.push(this.output[1], ".0");
                                                        break;
                                                    case "z":
                                                        this.isState("casting-to-integer") ? r.push(this.output[2]) : r.push(this.output[2], ".0");
                                                        break;
                                                    default:
                                                        throw this.astErrorOutput("Unexpected expression", n);
                                                }
                                                return r;
                                            case "value":
                                                throw this.astErrorOutput("Unexpected expression", n);
                                            case "value[]":
                                            case "value[][]":
                                            case "value[][][]":
                                            case "value[][][][]":
                                            case "value.value":
                                                if (w === "Math") return r.push(Math[b]), r;
                                                const C = u.sanitizeName(b);
                                                switch(m){
                                                    case "r":
                                                        return r.push(`user_${C}.r`), r;
                                                    case "g":
                                                        return r.push(`user_${C}.g`), r;
                                                    case "b":
                                                        return r.push(`user_${C}.b`), r;
                                                    case "a":
                                                        return r.push(`user_${C}.a`), r;
                                                }
                                                break;
                                            case "this.constants.value":
                                                if (typeof y > "u") switch(v){
                                                    case "Array(2)":
                                                    case "Array(3)":
                                                    case "Array(4)":
                                                        return r.push(`constants_${u.sanitizeName(b)}`), r;
                                                }
                                            case "this.constants.value[]":
                                            case "this.constants.value[][]":
                                            case "this.constants.value[][][]":
                                            case "this.constants.value[][][][]":
                                                break;
                                            case "fn()[]":
                                                return this.astCallExpression(n.object, r), r.push("["), r.push(this.memberExpressionPropertyMarkup(m)), r.push("]"), r;
                                            case "fn()[][]":
                                                return this.astCallExpression(n.object.object, r), r.push("["), r.push(this.memberExpressionPropertyMarkup(n.object.property)), r.push("]"), r.push("["), r.push(this.memberExpressionPropertyMarkup(n.property)), r.push("]"), r;
                                            case "[][]":
                                                return this.astArrayExpression(n.object, r), r.push("["), r.push(this.memberExpressionPropertyMarkup(m)), r.push("]"), r;
                                            default:
                                                throw this.astErrorOutput("Unexpected expression", n);
                                        }
                                        if (n.computed === !1) switch(v){
                                            case "Number":
                                            case "Integer":
                                            case "Float":
                                            case "Boolean":
                                                return r.push(`${w}_${u.sanitizeName(b)}`), r;
                                        }
                                        const k = `${w}_${u.sanitizeName(b)}`;
                                        switch(v){
                                            case "Array(2)":
                                            case "Array(3)":
                                            case "Array(4)":
                                                this.astGeneric(n.object, r), r.push("["), r.push(this.memberExpressionPropertyMarkup(y)), r.push("]");
                                                break;
                                            case "HTMLImageArray":
                                                r.push(`getImage3D(${k}, ${k}Size, ${k}Dim, `), this.memberExpressionXYZ(y, T, _, r), r.push(")");
                                                break;
                                            case "ArrayTexture(1)":
                                                r.push(`getFloatFromSampler2D(${k}, ${k}Size, ${k}Dim, `), this.memberExpressionXYZ(y, T, _, r), r.push(")");
                                                break;
                                            case "Array1D(2)":
                                            case "Array2D(2)":
                                            case "Array3D(2)":
                                                r.push(`getMemoryOptimizedVec2(${k}, ${k}Size, ${k}Dim, `), this.memberExpressionXYZ(y, T, _, r), r.push(")");
                                                break;
                                            case "ArrayTexture(2)":
                                                r.push(`getVec2FromSampler2D(${k}, ${k}Size, ${k}Dim, `), this.memberExpressionXYZ(y, T, _, r), r.push(")");
                                                break;
                                            case "Array1D(3)":
                                            case "Array2D(3)":
                                            case "Array3D(3)":
                                                r.push(`getMemoryOptimizedVec3(${k}, ${k}Size, ${k}Dim, `), this.memberExpressionXYZ(y, T, _, r), r.push(")");
                                                break;
                                            case "ArrayTexture(3)":
                                                r.push(`getVec3FromSampler2D(${k}, ${k}Size, ${k}Dim, `), this.memberExpressionXYZ(y, T, _, r), r.push(")");
                                                break;
                                            case "Array1D(4)":
                                            case "Array2D(4)":
                                            case "Array3D(4)":
                                                r.push(`getMemoryOptimizedVec4(${k}, ${k}Size, ${k}Dim, `), this.memberExpressionXYZ(y, T, _, r), r.push(")");
                                                break;
                                            case "ArrayTexture(4)":
                                            case "HTMLCanvas":
                                            case "OffscreenCanvas":
                                            case "HTMLImage":
                                            case "ImageBitmap":
                                            case "ImageData":
                                            case "HTMLVideo":
                                                r.push(`getVec4FromSampler2D(${k}, ${k}Size, ${k}Dim, `), this.memberExpressionXYZ(y, T, _, r), r.push(")");
                                                break;
                                            case "NumberTexture":
                                            case "Array":
                                            case "Array2D":
                                            case "Array3D":
                                            case "Array4D":
                                            case "Input":
                                            case "Number":
                                            case "Float":
                                            case "Integer":
                                                if (this.precision === "single") r.push(`getMemoryOptimized32(${k}, ${k}Size, ${k}Dim, `), this.memberExpressionXYZ(y, T, _, r), r.push(")");
                                                else {
                                                    const C = w === "user" ? this.lookupFunctionArgumentBitRatio(this.name, b) : this.constantBitRatios[b];
                                                    switch(C){
                                                        case 1:
                                                            r.push(`get8(${k}, ${k}Size, ${k}Dim, `);
                                                            break;
                                                        case 2:
                                                            r.push(`get16(${k}, ${k}Size, ${k}Dim, `);
                                                            break;
                                                        case 4:
                                                        case 0:
                                                            r.push(`get32(${k}, ${k}Size, ${k}Dim, `);
                                                            break;
                                                        default:
                                                            throw new Error(`unhandled bit ratio of ${C}`);
                                                    }
                                                    this.memberExpressionXYZ(y, T, _, r), r.push(")");
                                                }
                                                break;
                                            case "MemoryOptimizedNumberTexture":
                                                r.push(`getMemoryOptimized32(${k}, ${k}Size, ${k}Dim, `), this.memberExpressionXYZ(y, T, _, r), r.push(")");
                                                break;
                                            case "Matrix(2)":
                                            case "Matrix(3)":
                                            case "Matrix(4)":
                                                r.push(`${k}[${this.memberExpressionPropertyMarkup(T)}]`), T && r.push(`[${this.memberExpressionPropertyMarkup(y)}]`);
                                                break;
                                            default:
                                                throw new Error(`unhandled member expression "${v}"`);
                                        }
                                        return r;
                                    }
                                    astCallExpression(n, r) {
                                        if (!n.callee) throw this.astErrorOutput("Unknown CallExpression", n);
                                        let m = null;
                                        const b = this.isAstMathFunction(n);
                                        if (b || n.callee.object && n.callee.object.type === "ThisExpression" ? m = n.callee.property.name : n.callee.type === "SequenceExpression" && n.callee.expressions[0].type === "Literal" && !isNaN(n.callee.expressions[0].raw) ? m = n.callee.expressions[1].property.name : m = n.callee.name, !m) throw this.astErrorOutput("Unhandled function, couldn't find name", n);
                                        switch(m){
                                            case "pow":
                                                m = "_pow";
                                                break;
                                            case "round":
                                                m = "_round";
                                                break;
                                        }
                                        if (this.calledFunctions.indexOf(m) < 0 && this.calledFunctions.push(m), m === "random" && this.plugins && this.plugins.length > 0) for(let E = 0; E < this.plugins.length; E++){
                                            const w = this.plugins[E];
                                            if (w.functionMatch === "Math.random()" && w.functionReplace) return r.push(w.functionReplace), r;
                                        }
                                        if (this.onFunctionCall && this.onFunctionCall(this.name, m, n.arguments), r.push(m), r.push("("), b) for(let E = 0; E < n.arguments.length; ++E){
                                            const w = n.arguments[E], v = this.getType(w);
                                            switch(E > 0 && r.push(", "), v){
                                                case "Integer":
                                                    this.castValueToFloat(w, r);
                                                    break;
                                                default:
                                                    this.astGeneric(w, r);
                                                    break;
                                            }
                                        }
                                        else {
                                            const E = this.lookupFunctionArgumentTypes(m) || [];
                                            for(let w = 0; w < n.arguments.length; ++w){
                                                const v = n.arguments[w];
                                                let y = E[w];
                                                w > 0 && r.push(", ");
                                                const T = this.getType(v);
                                                switch(y || (this.triggerImplyArgumentType(m, w, T, this), y = T), T){
                                                    case "Boolean":
                                                        this.astGeneric(v, r);
                                                        continue;
                                                    case "Number":
                                                    case "Float":
                                                        if (y === "Integer") {
                                                            r.push("int("), this.astGeneric(v, r), r.push(")");
                                                            continue;
                                                        } else if (y === "Number" || y === "Float") {
                                                            this.astGeneric(v, r);
                                                            continue;
                                                        } else if (y === "LiteralInteger") {
                                                            this.castLiteralToFloat(v, r);
                                                            continue;
                                                        }
                                                        break;
                                                    case "Integer":
                                                        if (y === "Number" || y === "Float") {
                                                            r.push("float("), this.astGeneric(v, r), r.push(")");
                                                            continue;
                                                        } else if (y === "Integer") {
                                                            this.astGeneric(v, r);
                                                            continue;
                                                        }
                                                        break;
                                                    case "LiteralInteger":
                                                        if (y === "Integer") {
                                                            this.castLiteralToInteger(v, r);
                                                            continue;
                                                        } else if (y === "Number" || y === "Float") {
                                                            this.castLiteralToFloat(v, r);
                                                            continue;
                                                        } else if (y === "LiteralInteger") {
                                                            this.astGeneric(v, r);
                                                            continue;
                                                        }
                                                        break;
                                                    case "Array(2)":
                                                    case "Array(3)":
                                                    case "Array(4)":
                                                        if (y === T) {
                                                            if (v.type === "Identifier") r.push(`user_${u.sanitizeName(v.name)}`);
                                                            else if (v.type === "ArrayExpression" || v.type === "MemberExpression" || v.type === "CallExpression") this.astGeneric(v, r);
                                                            else throw this.astErrorOutput(`Unhandled argument type ${v.type}`, n);
                                                            continue;
                                                        }
                                                        break;
                                                    case "HTMLCanvas":
                                                    case "OffscreenCanvas":
                                                    case "HTMLImage":
                                                    case "ImageBitmap":
                                                    case "ImageData":
                                                    case "HTMLImageArray":
                                                    case "HTMLVideo":
                                                    case "ArrayTexture(1)":
                                                    case "ArrayTexture(2)":
                                                    case "ArrayTexture(3)":
                                                    case "ArrayTexture(4)":
                                                    case "Array":
                                                    case "Input":
                                                        if (y === T) {
                                                            if (v.type !== "Identifier") throw this.astErrorOutput(`Unhandled argument type ${v.type}`, n);
                                                            this.triggerImplyArgumentBitRatio(this.name, v.name, m, w);
                                                            const _ = u.sanitizeName(v.name);
                                                            r.push(`user_${_},user_${_}Size,user_${_}Dim`);
                                                            continue;
                                                        }
                                                        break;
                                                }
                                                throw this.astErrorOutput(`Unhandled argument combination of ${T} and ${y} for argument named "${v.name}"`, n);
                                            }
                                        }
                                        return r.push(")"), r;
                                    }
                                    astArrayExpression(n, r) {
                                        const m = this.getType(n), b = n.elements.length;
                                        switch(m){
                                            case "Matrix(2)":
                                            case "Matrix(3)":
                                            case "Matrix(4)":
                                                r.push(`mat${b}(`);
                                                break;
                                            default:
                                                r.push(`vec${b}(`);
                                        }
                                        for(let E = 0; E < b; ++E){
                                            E > 0 && r.push(", ");
                                            const w = n.elements[E];
                                            this.astGeneric(w, r);
                                        }
                                        return r.push(")"), r;
                                    }
                                    memberExpressionXYZ(n, r, m, b) {
                                        return m ? b.push(this.memberExpressionPropertyMarkup(m), ", ") : b.push("0, "), r ? b.push(this.memberExpressionPropertyMarkup(r), ", ") : b.push("0, "), b.push(this.memberExpressionPropertyMarkup(n)), b;
                                    }
                                    memberExpressionPropertyMarkup(n) {
                                        if (!n) throw new Error("Property not set");
                                        const r = this.getType(n), m = [];
                                        switch(r){
                                            case "Number":
                                            case "Float":
                                                this.castValueToInteger(n, m);
                                                break;
                                            case "LiteralInteger":
                                                this.castLiteralToInteger(n, m);
                                                break;
                                            default:
                                                this.astGeneric(n, m);
                                        }
                                        return m.join("");
                                    }
                                }
                                const l = {
                                    Array: "sampler2D",
                                    "Array(2)": "vec2",
                                    "Array(3)": "vec3",
                                    "Array(4)": "vec4",
                                    "Matrix(2)": "mat2",
                                    "Matrix(3)": "mat3",
                                    "Matrix(4)": "mat4",
                                    Array2D: "sampler2D",
                                    Array3D: "sampler2D",
                                    Boolean: "bool",
                                    Float: "float",
                                    Input: "sampler2D",
                                    Integer: "int",
                                    Number: "float",
                                    LiteralInteger: "float",
                                    NumberTexture: "sampler2D",
                                    MemoryOptimizedNumberTexture: "sampler2D",
                                    "ArrayTexture(1)": "sampler2D",
                                    "ArrayTexture(2)": "sampler2D",
                                    "ArrayTexture(3)": "sampler2D",
                                    "ArrayTexture(4)": "sampler2D",
                                    HTMLVideo: "sampler2D",
                                    HTMLCanvas: "sampler2D",
                                    OffscreenCanvas: "sampler2D",
                                    HTMLImage: "sampler2D",
                                    ImageBitmap: "sampler2D",
                                    ImageData: "sampler2D",
                                    HTMLImageArray: "sampler2DArray"
                                }, a = {
                                    "===": "==",
                                    "!==": "!="
                                };
                                i.exports = {
                                    WebGLFunctionNode: d
                                };
                            },
                            {
                                "../../utils": 114,
                                "../function-node": 10
                            }
                        ],
                        39: [
                            function(e, i, h) {
                                const { WebGLKernelValueBoolean: u } = e("./kernel-value/boolean"), { WebGLKernelValueFloat: p } = e("./kernel-value/float"), { WebGLKernelValueInteger: d } = e("./kernel-value/integer"), { WebGLKernelValueHTMLImage: l } = e("./kernel-value/html-image"), { WebGLKernelValueDynamicHTMLImage: a } = e("./kernel-value/dynamic-html-image"), { WebGLKernelValueHTMLVideo: o } = e("./kernel-value/html-video"), { WebGLKernelValueDynamicHTMLVideo: n } = e("./kernel-value/dynamic-html-video"), { WebGLKernelValueSingleInput: r } = e("./kernel-value/single-input"), { WebGLKernelValueDynamicSingleInput: m } = e("./kernel-value/dynamic-single-input"), { WebGLKernelValueUnsignedInput: b } = e("./kernel-value/unsigned-input"), { WebGLKernelValueDynamicUnsignedInput: E } = e("./kernel-value/dynamic-unsigned-input"), { WebGLKernelValueMemoryOptimizedNumberTexture: w } = e("./kernel-value/memory-optimized-number-texture"), { WebGLKernelValueDynamicMemoryOptimizedNumberTexture: v } = e("./kernel-value/dynamic-memory-optimized-number-texture"), { WebGLKernelValueNumberTexture: y } = e("./kernel-value/number-texture"), { WebGLKernelValueDynamicNumberTexture: T } = e("./kernel-value/dynamic-number-texture"), { WebGLKernelValueSingleArray: _ } = e("./kernel-value/single-array"), { WebGLKernelValueDynamicSingleArray: k } = e("./kernel-value/dynamic-single-array"), { WebGLKernelValueSingleArray1DI: C } = e("./kernel-value/single-array1d-i"), { WebGLKernelValueDynamicSingleArray1DI: M } = e("./kernel-value/dynamic-single-array1d-i"), { WebGLKernelValueSingleArray2DI: x } = e("./kernel-value/single-array2d-i"), { WebGLKernelValueDynamicSingleArray2DI: g } = e("./kernel-value/dynamic-single-array2d-i"), { WebGLKernelValueSingleArray3DI: I } = e("./kernel-value/single-array3d-i"), { WebGLKernelValueDynamicSingleArray3DI: A } = e("./kernel-value/dynamic-single-array3d-i"), { WebGLKernelValueArray2: P } = e("./kernel-value/array2"), { WebGLKernelValueArray3: O } = e("./kernel-value/array3"), { WebGLKernelValueArray4: R } = e("./kernel-value/array4"), { WebGLKernelValueUnsignedArray: G } = e("./kernel-value/unsigned-array"), { WebGLKernelValueDynamicUnsignedArray: U } = e("./kernel-value/dynamic-unsigned-array"), it = {
                                    unsigned: {
                                        dynamic: {
                                            Boolean: u,
                                            Integer: d,
                                            Float: p,
                                            Array: U,
                                            "Array(2)": P,
                                            "Array(3)": O,
                                            "Array(4)": R,
                                            "Array1D(2)": !1,
                                            "Array1D(3)": !1,
                                            "Array1D(4)": !1,
                                            "Array2D(2)": !1,
                                            "Array2D(3)": !1,
                                            "Array2D(4)": !1,
                                            "Array3D(2)": !1,
                                            "Array3D(3)": !1,
                                            "Array3D(4)": !1,
                                            Input: E,
                                            NumberTexture: T,
                                            "ArrayTexture(1)": T,
                                            "ArrayTexture(2)": T,
                                            "ArrayTexture(3)": T,
                                            "ArrayTexture(4)": T,
                                            MemoryOptimizedNumberTexture: v,
                                            HTMLCanvas: a,
                                            OffscreenCanvas: a,
                                            HTMLImage: a,
                                            ImageBitmap: a,
                                            ImageData: a,
                                            HTMLImageArray: !1,
                                            HTMLVideo: n
                                        },
                                        static: {
                                            Boolean: u,
                                            Float: p,
                                            Integer: d,
                                            Array: G,
                                            "Array(2)": P,
                                            "Array(3)": O,
                                            "Array(4)": R,
                                            "Array1D(2)": !1,
                                            "Array1D(3)": !1,
                                            "Array1D(4)": !1,
                                            "Array2D(2)": !1,
                                            "Array2D(3)": !1,
                                            "Array2D(4)": !1,
                                            "Array3D(2)": !1,
                                            "Array3D(3)": !1,
                                            "Array3D(4)": !1,
                                            Input: b,
                                            NumberTexture: y,
                                            "ArrayTexture(1)": y,
                                            "ArrayTexture(2)": y,
                                            "ArrayTexture(3)": y,
                                            "ArrayTexture(4)": y,
                                            MemoryOptimizedNumberTexture: w,
                                            HTMLCanvas: l,
                                            OffscreenCanvas: l,
                                            HTMLImage: l,
                                            ImageBitmap: l,
                                            ImageData: l,
                                            HTMLImageArray: !1,
                                            HTMLVideo: o
                                        }
                                    },
                                    single: {
                                        dynamic: {
                                            Boolean: u,
                                            Integer: d,
                                            Float: p,
                                            Array: k,
                                            "Array(2)": P,
                                            "Array(3)": O,
                                            "Array(4)": R,
                                            "Array1D(2)": M,
                                            "Array1D(3)": M,
                                            "Array1D(4)": M,
                                            "Array2D(2)": g,
                                            "Array2D(3)": g,
                                            "Array2D(4)": g,
                                            "Array3D(2)": A,
                                            "Array3D(3)": A,
                                            "Array3D(4)": A,
                                            Input: m,
                                            NumberTexture: T,
                                            "ArrayTexture(1)": T,
                                            "ArrayTexture(2)": T,
                                            "ArrayTexture(3)": T,
                                            "ArrayTexture(4)": T,
                                            MemoryOptimizedNumberTexture: v,
                                            HTMLCanvas: a,
                                            OffscreenCanvas: a,
                                            HTMLImage: a,
                                            ImageBitmap: a,
                                            ImageData: a,
                                            HTMLImageArray: !1,
                                            HTMLVideo: n
                                        },
                                        static: {
                                            Boolean: u,
                                            Float: p,
                                            Integer: d,
                                            Array: _,
                                            "Array(2)": P,
                                            "Array(3)": O,
                                            "Array(4)": R,
                                            "Array1D(2)": C,
                                            "Array1D(3)": C,
                                            "Array1D(4)": C,
                                            "Array2D(2)": x,
                                            "Array2D(3)": x,
                                            "Array2D(4)": x,
                                            "Array3D(2)": I,
                                            "Array3D(3)": I,
                                            "Array3D(4)": I,
                                            Input: r,
                                            NumberTexture: y,
                                            "ArrayTexture(1)": y,
                                            "ArrayTexture(2)": y,
                                            "ArrayTexture(3)": y,
                                            "ArrayTexture(4)": y,
                                            MemoryOptimizedNumberTexture: w,
                                            HTMLCanvas: l,
                                            OffscreenCanvas: l,
                                            HTMLImage: l,
                                            ImageBitmap: l,
                                            ImageData: l,
                                            HTMLImageArray: !1,
                                            HTMLVideo: o
                                        }
                                    }
                                };
                                function q(B, st, rt, mt) {
                                    if (!B) throw new Error("type missing");
                                    if (!st) throw new Error("dynamic missing");
                                    if (!rt) throw new Error("precision missing");
                                    mt.type && (B = mt.type);
                                    const tt = it[rt][st];
                                    if (tt[B] === !1) return null;
                                    if (tt[B] === void 0) throw new Error(`Could not find a KernelValue for ${B}`);
                                    return tt[B];
                                }
                                i.exports = {
                                    lookupKernelValueType: q,
                                    kernelValueMaps: it
                                };
                            },
                            {
                                "./kernel-value/array2": 41,
                                "./kernel-value/array3": 42,
                                "./kernel-value/array4": 43,
                                "./kernel-value/boolean": 44,
                                "./kernel-value/dynamic-html-image": 45,
                                "./kernel-value/dynamic-html-video": 46,
                                "./kernel-value/dynamic-memory-optimized-number-texture": 47,
                                "./kernel-value/dynamic-number-texture": 48,
                                "./kernel-value/dynamic-single-array": 49,
                                "./kernel-value/dynamic-single-array1d-i": 50,
                                "./kernel-value/dynamic-single-array2d-i": 51,
                                "./kernel-value/dynamic-single-array3d-i": 52,
                                "./kernel-value/dynamic-single-input": 53,
                                "./kernel-value/dynamic-unsigned-array": 54,
                                "./kernel-value/dynamic-unsigned-input": 55,
                                "./kernel-value/float": 56,
                                "./kernel-value/html-image": 57,
                                "./kernel-value/html-video": 58,
                                "./kernel-value/integer": 60,
                                "./kernel-value/memory-optimized-number-texture": 61,
                                "./kernel-value/number-texture": 62,
                                "./kernel-value/single-array": 63,
                                "./kernel-value/single-array1d-i": 64,
                                "./kernel-value/single-array2d-i": 65,
                                "./kernel-value/single-array3d-i": 66,
                                "./kernel-value/single-input": 67,
                                "./kernel-value/unsigned-array": 68,
                                "./kernel-value/unsigned-input": 69
                            }
                        ],
                        40: [
                            function(e, i, h) {
                                const { WebGLKernelValue: u } = e("./index"), { Input: p } = e("../../../input");
                                class d extends u {
                                    checkSize(a, o) {
                                        if (!this.kernel.validate) return;
                                        const { maxTextureSize: n } = this.kernel.constructor.features;
                                        if (a > n || o > n) throw a > o ? new Error(`Argument texture width of ${a} larger than maximum size of ${n} for your GPU`) : a < o ? new Error(`Argument texture height of ${o} larger than maximum size of ${n} for your GPU`) : new Error(`Argument texture height and width of ${o} larger than maximum size of ${n} for your GPU`);
                                    }
                                    setup() {
                                        this.requestTexture(), this.setupTexture(), this.defineTexture();
                                    }
                                    requestTexture() {
                                        this.texture = this.onRequestTexture();
                                    }
                                    defineTexture() {
                                        const { context: a } = this;
                                        a.activeTexture(this.contextHandle), a.bindTexture(a.TEXTURE_2D, this.texture), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST);
                                    }
                                    setupTexture() {
                                        this.contextHandle = this.onRequestContextHandle(), this.index = this.onRequestIndex(), this.dimensionsId = this.id + "Dim", this.sizeId = this.id + "Size";
                                    }
                                    getBitRatio(a) {
                                        if (Array.isArray(a[0])) return this.getBitRatio(a[0]);
                                        if (a.constructor === p) return this.getBitRatio(a.value);
                                        switch(a.constructor){
                                            case Uint8ClampedArray:
                                            case Uint8Array:
                                            case Int8Array:
                                                return 1;
                                            case Uint16Array:
                                            case Int16Array:
                                                return 2;
                                            case Float32Array:
                                            case Int32Array:
                                            default:
                                                return 4;
                                        }
                                    }
                                    destroy() {
                                        this.prevArg && this.prevArg.delete(), this.context.deleteTexture(this.texture);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelArray: d
                                };
                            },
                            {
                                "../../../input": 110,
                                "./index": 59
                            }
                        ],
                        41: [
                            function(e, i, h) {
                                const { WebGLKernelValue: u } = e("./index");
                                class p extends u {
                                    constructor(l, a){
                                        super(l, a), this.uploadValue = l;
                                    }
                                    getSource(l) {
                                        return this.origin === "constants" ? `const vec2 ${this.id} = vec2(${l[0]},${l[1]});
` : `uniform vec2 ${this.id};
`;
                                    }
                                    getStringValueHandler() {
                                        return this.origin === "constants" ? "" : `const uploadValue_${this.name} = ${this.varName};
`;
                                    }
                                    updateValue(l) {
                                        this.origin !== "constants" && this.kernel.setUniform2fv(this.id, this.uploadValue = l);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueArray2: p
                                };
                            },
                            {
                                "./index": 59
                            }
                        ],
                        42: [
                            function(e, i, h) {
                                const { WebGLKernelValue: u } = e("./index");
                                class p extends u {
                                    constructor(l, a){
                                        super(l, a), this.uploadValue = l;
                                    }
                                    getSource(l) {
                                        return this.origin === "constants" ? `const vec3 ${this.id} = vec3(${l[0]},${l[1]},${l[2]});
` : `uniform vec3 ${this.id};
`;
                                    }
                                    getStringValueHandler() {
                                        return this.origin === "constants" ? "" : `const uploadValue_${this.name} = ${this.varName};
`;
                                    }
                                    updateValue(l) {
                                        this.origin !== "constants" && this.kernel.setUniform3fv(this.id, this.uploadValue = l);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueArray3: p
                                };
                            },
                            {
                                "./index": 59
                            }
                        ],
                        43: [
                            function(e, i, h) {
                                const { WebGLKernelValue: u } = e("./index");
                                class p extends u {
                                    constructor(l, a){
                                        super(l, a), this.uploadValue = l;
                                    }
                                    getSource(l) {
                                        return this.origin === "constants" ? `const vec4 ${this.id} = vec4(${l[0]},${l[1]},${l[2]},${l[3]});
` : `uniform vec4 ${this.id};
`;
                                    }
                                    getStringValueHandler() {
                                        return this.origin === "constants" ? "" : `const uploadValue_${this.name} = ${this.varName};
`;
                                    }
                                    updateValue(l) {
                                        this.origin !== "constants" && this.kernel.setUniform4fv(this.id, this.uploadValue = l);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueArray4: p
                                };
                            },
                            {
                                "./index": 59
                            }
                        ],
                        44: [
                            function(e, i, h) {
                                e("../../../utils");
                                const { WebGLKernelValue: u } = e("./index");
                                class p extends u {
                                    constructor(l, a){
                                        super(l, a), this.uploadValue = l;
                                    }
                                    getSource(l) {
                                        return this.origin === "constants" ? `const bool ${this.id} = ${l};
` : `uniform bool ${this.id};
`;
                                    }
                                    getStringValueHandler() {
                                        return `const uploadValue_${this.name} = ${this.varName};
`;
                                    }
                                    updateValue(l) {
                                        this.origin !== "constants" && this.kernel.setUniform1i(this.id, this.uploadValue = l);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueBoolean: p
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./index": 59
                            }
                        ],
                        45: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueHTMLImage: p } = e("./html-image");
                                class d extends p {
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `uniform ivec2 ${this.sizeId}`,
                                            `uniform ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        const { width: o, height: n } = a;
                                        this.checkSize(o, n), this.dimensions = [
                                            o,
                                            n,
                                            1
                                        ], this.textureSize = [
                                            o,
                                            n
                                        ], this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueDynamicHTMLImage: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./html-image": 57
                            }
                        ],
                        46: [
                            function(e, i, h) {
                                const { WebGLKernelValueDynamicHTMLImage: u } = e("./dynamic-html-image");
                                class p extends u {
                                }
                                i.exports = {
                                    WebGLKernelValueDynamicHTMLVideo: p
                                };
                            },
                            {
                                "./dynamic-html-image": 45
                            }
                        ],
                        47: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueMemoryOptimizedNumberTexture: p } = e("./memory-optimized-number-texture");
                                class d extends p {
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `uniform ivec2 ${this.sizeId}`,
                                            `uniform ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        this.dimensions = a.dimensions, this.checkSize(a.size[0], a.size[1]), this.textureSize = a.size, this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueDynamicMemoryOptimizedNumberTexture: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./memory-optimized-number-texture": 61
                            }
                        ],
                        48: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueNumberTexture: p } = e("./number-texture");
                                class d extends p {
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `uniform ivec2 ${this.sizeId}`,
                                            `uniform ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        this.dimensions = a.dimensions, this.checkSize(a.size[0], a.size[1]), this.textureSize = a.size, this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueDynamicNumberTexture: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./number-texture": 62
                            }
                        ],
                        49: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueSingleArray: p } = e("./single-array");
                                class d extends p {
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `uniform ivec2 ${this.sizeId}`,
                                            `uniform ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        this.dimensions = u.getDimensions(a, !0), this.textureSize = u.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueDynamicSingleArray: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./single-array": 63
                            }
                        ],
                        50: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueSingleArray1DI: p } = e("./single-array1d-i");
                                class d extends p {
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `uniform ivec2 ${this.sizeId}`,
                                            `uniform ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        this.setShape(a), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueDynamicSingleArray1DI: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./single-array1d-i": 64
                            }
                        ],
                        51: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueSingleArray2DI: p } = e("./single-array2d-i");
                                class d extends p {
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `uniform ivec2 ${this.sizeId}`,
                                            `uniform ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        this.setShape(a), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueDynamicSingleArray2DI: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./single-array2d-i": 65
                            }
                        ],
                        52: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueSingleArray3DI: p } = e("./single-array3d-i");
                                class d extends p {
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `uniform ivec2 ${this.sizeId}`,
                                            `uniform ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        this.setShape(a), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueDynamicSingleArray3DI: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./single-array3d-i": 66
                            }
                        ],
                        53: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueSingleInput: p } = e("./single-input");
                                class d extends p {
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `uniform ivec2 ${this.sizeId}`,
                                            `uniform ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        let [o, n, r] = a.size;
                                        this.dimensions = new Int32Array([
                                            o || 1,
                                            n || 1,
                                            r || 1
                                        ]), this.textureSize = u.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueDynamicSingleInput: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./single-input": 67
                            }
                        ],
                        54: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueUnsignedArray: p } = e("./unsigned-array");
                                class d extends p {
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `uniform ivec2 ${this.sizeId}`,
                                            `uniform ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        this.dimensions = u.getDimensions(a, !0), this.textureSize = u.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]);
                                        const o = this.getTransferArrayType(a);
                                        this.preUploadValue = new o(this.uploadArrayLength), this.uploadValue = new Uint8Array(this.preUploadValue.buffer), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueDynamicUnsignedArray: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./unsigned-array": 68
                            }
                        ],
                        55: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueUnsignedInput: p } = e("./unsigned-input");
                                class d extends p {
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `uniform ivec2 ${this.sizeId}`,
                                            `uniform ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        let [o, n, r] = a.size;
                                        this.dimensions = new Int32Array([
                                            o || 1,
                                            n || 1,
                                            r || 1
                                        ]), this.textureSize = u.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]);
                                        const m = this.getTransferArrayType(a.value);
                                        this.preUploadValue = new m(this.uploadArrayLength), this.uploadValue = new Uint8Array(this.preUploadValue.buffer), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueDynamicUnsignedInput: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./unsigned-input": 69
                            }
                        ],
                        56: [
                            function(e, i, h) {
                                e("../../../utils");
                                const { WebGLKernelValue: u } = e("./index");
                                class p extends u {
                                    constructor(l, a){
                                        super(l, a), this.uploadValue = l;
                                    }
                                    getStringValueHandler() {
                                        return `const uploadValue_${this.name} = ${this.varName};
`;
                                    }
                                    getSource(l) {
                                        return this.origin === "constants" ? Number.isInteger(l) ? `const float ${this.id} = ${l}.0;
` : `const float ${this.id} = ${l};
` : `uniform float ${this.id};
`;
                                    }
                                    updateValue(l) {
                                        this.origin !== "constants" && this.kernel.setUniform1f(this.id, this.uploadValue = l);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueFloat: p
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./index": 59
                            }
                        ],
                        57: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelArray: p } = e("./array");
                                class d extends p {
                                    constructor(a, o){
                                        super(a, o);
                                        const { width: n, height: r } = a;
                                        this.checkSize(n, r), this.dimensions = [
                                            n,
                                            r,
                                            1
                                        ], this.textureSize = [
                                            n,
                                            r
                                        ], this.uploadValue = a;
                                    }
                                    getStringValueHandler() {
                                        return `const uploadValue_${this.name} = ${this.varName};
`;
                                    }
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                    updateValue(a) {
                                        if (a.constructor !== this.initialValueConstructor) {
                                            this.onUpdateValueMismatch(a.constructor);
                                            return;
                                        }
                                        const { context: o } = this;
                                        o.activeTexture(this.contextHandle), o.bindTexture(o.TEXTURE_2D, this.texture), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !0), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, o.RGBA, o.UNSIGNED_BYTE, this.uploadValue = a), this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueHTMLImage: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./array": 40
                            }
                        ],
                        58: [
                            function(e, i, h) {
                                const { WebGLKernelValueHTMLImage: u } = e("./html-image");
                                class p extends u {
                                }
                                i.exports = {
                                    WebGLKernelValueHTMLVideo: p
                                };
                            },
                            {
                                "./html-image": 57
                            }
                        ],
                        59: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { KernelValue: p } = e("../../kernel-value");
                                class d extends p {
                                    constructor(a, o){
                                        super(a, o), this.dimensionsId = null, this.sizeId = null, this.initialValueConstructor = a.constructor, this.onRequestTexture = o.onRequestTexture, this.onRequestIndex = o.onRequestIndex, this.uploadValue = null, this.textureSize = null, this.bitRatio = null, this.prevArg = null;
                                    }
                                    get id() {
                                        return `${this.origin}_${u.sanitizeName(this.name)}`;
                                    }
                                    setup() {}
                                    getTransferArrayType(a) {
                                        if (Array.isArray(a[0])) return this.getTransferArrayType(a[0]);
                                        switch(a.constructor){
                                            case Array:
                                            case Int32Array:
                                            case Int16Array:
                                            case Int8Array:
                                                return Float32Array;
                                            case Uint8ClampedArray:
                                            case Uint8Array:
                                            case Uint16Array:
                                            case Uint32Array:
                                            case Float32Array:
                                            case Float64Array:
                                                return a.constructor;
                                        }
                                        return console.warn("Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros"), a.constructor;
                                    }
                                    getStringValueHandler() {
                                        throw new Error(`"getStringValueHandler" not implemented on ${this.constructor.name}`);
                                    }
                                    getVariablePrecisionString() {
                                        return this.kernel.getVariablePrecisionString(this.textureSize || void 0, this.tactic || void 0);
                                    }
                                    destroy() {}
                                }
                                i.exports = {
                                    WebGLKernelValue: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../kernel-value": 35
                            }
                        ],
                        60: [
                            function(e, i, h) {
                                e("../../../utils");
                                const { WebGLKernelValue: u } = e("./index");
                                class p extends u {
                                    constructor(l, a){
                                        super(l, a), this.uploadValue = l;
                                    }
                                    getStringValueHandler() {
                                        return `const uploadValue_${this.name} = ${this.varName};
`;
                                    }
                                    getSource(l) {
                                        return this.origin === "constants" ? `const int ${this.id} = ${parseInt(l)};
` : `uniform int ${this.id};
`;
                                    }
                                    updateValue(l) {
                                        this.origin !== "constants" && this.kernel.setUniform1i(this.id, this.uploadValue = l);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueInteger: p
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./index": 59
                            }
                        ],
                        61: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelArray: p } = e("./array"), d = "Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()";
                                class l extends p {
                                    constructor(o, n){
                                        super(o, n);
                                        const [r, m] = o.size;
                                        this.checkSize(r, m), this.dimensions = o.dimensions, this.textureSize = o.size, this.uploadValue = o.texture, this.forceUploadEachRun = !0;
                                    }
                                    setup() {
                                        this.setupTexture();
                                    }
                                    getStringValueHandler() {
                                        return `const uploadValue_${this.name} = ${this.varName}.texture;
`;
                                    }
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                    updateValue(o) {
                                        if (o.constructor !== this.initialValueConstructor) {
                                            this.onUpdateValueMismatch(o.constructor);
                                            return;
                                        }
                                        if (this.checkContext && o.context !== this.context) throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
                                        const { kernel: n, context: r } = this;
                                        if (n.pipeline) if (n.immutable) n.updateTextureArgumentRefs(this, o);
                                        else {
                                            if (n.texture && n.texture.texture === o.texture) throw new Error(d);
                                            if (n.mappedTextures) {
                                                const { mappedTextures: m } = n;
                                                for(let b = 0; b < m.length; b++)if (m[b].texture === o.texture) throw new Error(d);
                                            }
                                        }
                                        r.activeTexture(this.contextHandle), r.bindTexture(r.TEXTURE_2D, this.uploadValue = o.texture), this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueMemoryOptimizedNumberTexture: l,
                                    sameError: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./array": 40
                            }
                        ],
                        62: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelArray: p } = e("./array"), { sameError: d } = e("./memory-optimized-number-texture");
                                class l extends p {
                                    constructor(o, n){
                                        super(o, n);
                                        const [r, m] = o.size;
                                        this.checkSize(r, m);
                                        const { size: b, dimensions: E } = o;
                                        this.bitRatio = this.getBitRatio(o), this.dimensions = E, this.textureSize = b, this.uploadValue = o.texture, this.forceUploadEachRun = !0;
                                    }
                                    setup() {
                                        this.setupTexture();
                                    }
                                    getStringValueHandler() {
                                        return `const uploadValue_${this.name} = ${this.varName}.texture;
`;
                                    }
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                    updateValue(o) {
                                        if (o.constructor !== this.initialValueConstructor) {
                                            this.onUpdateValueMismatch(o.constructor);
                                            return;
                                        }
                                        if (this.checkContext && o.context !== this.context) throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
                                        const { kernel: n, context: r } = this;
                                        if (n.pipeline) if (n.immutable) n.updateTextureArgumentRefs(this, o);
                                        else {
                                            if (n.texture && n.texture.texture === o.texture) throw new Error(d);
                                            if (n.mappedTextures) {
                                                const { mappedTextures: m } = n;
                                                for(let b = 0; b < m.length; b++)if (m[b].texture === o.texture) throw new Error(d);
                                            }
                                        }
                                        r.activeTexture(this.contextHandle), r.bindTexture(r.TEXTURE_2D, this.uploadValue = o.texture), this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueNumberTexture: l
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./array": 40,
                                "./memory-optimized-number-texture": 61
                            }
                        ],
                        63: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelArray: p } = e("./array");
                                class d extends p {
                                    constructor(a, o){
                                        super(a, o), this.bitRatio = 4, this.dimensions = u.getDimensions(a, !0), this.textureSize = u.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength);
                                    }
                                    getStringValueHandler() {
                                        return u.linesToString([
                                            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
                                            `flattenTo(${this.varName}, uploadValue_${this.name})`
                                        ]);
                                    }
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                    updateValue(a) {
                                        if (a.constructor !== this.initialValueConstructor) {
                                            this.onUpdateValueMismatch(a.constructor);
                                            return;
                                        }
                                        const { context: o } = this;
                                        u.flattenTo(a, this.uploadValue), o.activeTexture(this.contextHandle), o.bindTexture(o.TEXTURE_2D, this.texture), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !1), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, this.textureSize[0], this.textureSize[1], 0, o.RGBA, o.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueSingleArray: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./array": 40
                            }
                        ],
                        64: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelArray: p } = e("./array");
                                class d extends p {
                                    constructor(a, o){
                                        super(a, o), this.bitRatio = 4, this.setShape(a);
                                    }
                                    setShape(a) {
                                        const o = u.getDimensions(a, !0);
                                        this.textureSize = u.getMemoryOptimizedFloatTextureSize(o, this.bitRatio), this.dimensions = new Int32Array([
                                            o[1],
                                            1,
                                            1
                                        ]), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength);
                                    }
                                    getStringValueHandler() {
                                        return u.linesToString([
                                            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
                                            `flattenTo(${this.varName}, uploadValue_${this.name})`
                                        ]);
                                    }
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                    updateValue(a) {
                                        if (a.constructor !== this.initialValueConstructor) {
                                            this.onUpdateValueMismatch(a.constructor);
                                            return;
                                        }
                                        const { context: o } = this;
                                        u.flatten2dArrayTo(a, this.uploadValue), o.activeTexture(this.contextHandle), o.bindTexture(o.TEXTURE_2D, this.texture), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !1), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, this.textureSize[0], this.textureSize[1], 0, o.RGBA, o.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueSingleArray1DI: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./array": 40
                            }
                        ],
                        65: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelArray: p } = e("./array");
                                class d extends p {
                                    constructor(a, o){
                                        super(a, o), this.bitRatio = 4, this.setShape(a);
                                    }
                                    setShape(a) {
                                        const o = u.getDimensions(a, !0);
                                        this.textureSize = u.getMemoryOptimizedFloatTextureSize(o, this.bitRatio), this.dimensions = new Int32Array([
                                            o[1],
                                            o[2],
                                            1
                                        ]), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength);
                                    }
                                    getStringValueHandler() {
                                        return u.linesToString([
                                            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
                                            `flattenTo(${this.varName}, uploadValue_${this.name})`
                                        ]);
                                    }
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                    updateValue(a) {
                                        if (a.constructor !== this.initialValueConstructor) {
                                            this.onUpdateValueMismatch(a.constructor);
                                            return;
                                        }
                                        const { context: o } = this;
                                        u.flatten3dArrayTo(a, this.uploadValue), o.activeTexture(this.contextHandle), o.bindTexture(o.TEXTURE_2D, this.texture), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !1), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, this.textureSize[0], this.textureSize[1], 0, o.RGBA, o.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueSingleArray2DI: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./array": 40
                            }
                        ],
                        66: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelArray: p } = e("./array");
                                class d extends p {
                                    constructor(a, o){
                                        super(a, o), this.bitRatio = 4, this.setShape(a);
                                    }
                                    setShape(a) {
                                        const o = u.getDimensions(a, !0);
                                        this.textureSize = u.getMemoryOptimizedFloatTextureSize(o, this.bitRatio), this.dimensions = new Int32Array([
                                            o[1],
                                            o[2],
                                            o[3]
                                        ]), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength);
                                    }
                                    getStringValueHandler() {
                                        return u.linesToString([
                                            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
                                            `flattenTo(${this.varName}, uploadValue_${this.name})`
                                        ]);
                                    }
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                    updateValue(a) {
                                        if (a.constructor !== this.initialValueConstructor) {
                                            this.onUpdateValueMismatch(a.constructor);
                                            return;
                                        }
                                        const { context: o } = this;
                                        u.flatten4dArrayTo(a, this.uploadValue), o.activeTexture(this.contextHandle), o.bindTexture(o.TEXTURE_2D, this.texture), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !1), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, this.textureSize[0], this.textureSize[1], 0, o.RGBA, o.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueSingleArray3DI: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./array": 40
                            }
                        ],
                        67: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelArray: p } = e("./array");
                                class d extends p {
                                    constructor(a, o){
                                        super(a, o), this.bitRatio = 4;
                                        let [n, r, m] = a.size;
                                        this.dimensions = new Int32Array([
                                            n || 1,
                                            r || 1,
                                            m || 1
                                        ]), this.textureSize = u.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength);
                                    }
                                    getStringValueHandler() {
                                        return u.linesToString([
                                            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
                                            `flattenTo(${this.varName}.value, uploadValue_${this.name})`
                                        ]);
                                    }
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                    updateValue(a) {
                                        if (a.constructor !== this.initialValueConstructor) {
                                            this.onUpdateValueMismatch(a.constructor);
                                            return;
                                        }
                                        const { context: o } = this;
                                        u.flattenTo(a.value, this.uploadValue), o.activeTexture(this.contextHandle), o.bindTexture(o.TEXTURE_2D, this.texture), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !1), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, this.textureSize[0], this.textureSize[1], 0, o.RGBA, o.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueSingleInput: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./array": 40
                            }
                        ],
                        68: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelArray: p } = e("./array");
                                class d extends p {
                                    constructor(a, o){
                                        super(a, o), this.bitRatio = this.getBitRatio(a), this.dimensions = u.getDimensions(a, !0), this.textureSize = u.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]), this.TranserArrayType = this.getTransferArrayType(a), this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength), this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
                                    }
                                    getStringValueHandler() {
                                        return u.linesToString([
                                            `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
                                            `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
                                            `flattenTo(${this.varName}, preUploadValue_${this.name})`
                                        ]);
                                    }
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                    updateValue(a) {
                                        if (a.constructor !== this.initialValueConstructor) {
                                            this.onUpdateValueMismatch(a.constructor);
                                            return;
                                        }
                                        const { context: o } = this;
                                        u.flattenTo(a, this.preUploadValue), o.activeTexture(this.contextHandle), o.bindTexture(o.TEXTURE_2D, this.texture), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !1), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, this.textureSize[0], this.textureSize[1], 0, o.RGBA, o.UNSIGNED_BYTE, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueUnsignedArray: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./array": 40
                            }
                        ],
                        69: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelArray: p } = e("./array");
                                class d extends p {
                                    constructor(a, o){
                                        super(a, o), this.bitRatio = this.getBitRatio(a);
                                        const [n, r, m] = a.size;
                                        this.dimensions = new Int32Array([
                                            n || 1,
                                            r || 1,
                                            m || 1
                                        ]), this.textureSize = u.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio), this.checkSize(this.textureSize[0], this.textureSize[1]), this.TranserArrayType = this.getTransferArrayType(a.value), this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength), this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
                                    }
                                    getStringValueHandler() {
                                        return u.linesToString([
                                            `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
                                            `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
                                            `flattenTo(${this.varName}.value, preUploadValue_${this.name})`
                                        ]);
                                    }
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                    updateValue(a) {
                                        if (a.constructor !== this.initialValueConstructor) {
                                            this.onUpdateValueMismatch(value.constructor);
                                            return;
                                        }
                                        const { context: o } = this;
                                        u.flattenTo(a.value, this.preUploadValue), o.activeTexture(this.contextHandle), o.bindTexture(o.TEXTURE_2D, this.texture), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !1), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, this.textureSize[0], this.textureSize[1], 0, o.RGBA, o.UNSIGNED_BYTE, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGLKernelValueUnsignedInput: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./array": 40
                            }
                        ],
                        70: [
                            function(e, i, h) {
                                const { GLKernel: u } = e("../gl/kernel"), { FunctionBuilder: p } = e("../function-builder"), { WebGLFunctionNode: d } = e("./function-node"), { utils: l } = e("../../utils"), a = e("../../plugins/math-random-uniformly-distributed"), { fragmentShader: o } = e("./fragment-shader"), { vertexShader: n } = e("./vertex-shader"), { glKernelString: r } = e("../gl/kernel-string"), { lookupKernelValueType: m } = e("./kernel-value-maps");
                                let b = null, E = null, w = null, v = null, y = null;
                                const T = [
                                    a
                                ], _ = [], k = {};
                                class C extends u {
                                    static get isSupported() {
                                        return b !== null || (this.setupFeatureChecks(), b = this.isContextMatch(w)), b;
                                    }
                                    static setupFeatureChecks() {
                                        typeof document < "u" ? E = document.createElement("canvas") : typeof OffscreenCanvas < "u" && (E = new OffscreenCanvas(0, 0)), E && (w = E.getContext("webgl") || E.getContext("experimental-webgl"), !(!w || !w.getExtension) && (v = {
                                            OES_texture_float: w.getExtension("OES_texture_float"),
                                            OES_texture_float_linear: w.getExtension("OES_texture_float_linear"),
                                            OES_element_index_uint: w.getExtension("OES_element_index_uint"),
                                            WEBGL_draw_buffers: w.getExtension("WEBGL_draw_buffers")
                                        }, y = this.getFeatures()));
                                    }
                                    static isContextMatch(x) {
                                        return typeof WebGLRenderingContext < "u" ? x instanceof WebGLRenderingContext : !1;
                                    }
                                    static getIsTextureFloat() {
                                        return !!v.OES_texture_float;
                                    }
                                    static getIsDrawBuffers() {
                                        return !!v.WEBGL_draw_buffers;
                                    }
                                    static getChannelCount() {
                                        return v.WEBGL_draw_buffers ? w.getParameter(v.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) : 1;
                                    }
                                    static getMaxTextureSize() {
                                        return w.getParameter(w.MAX_TEXTURE_SIZE);
                                    }
                                    static lookupKernelValueType(x, g, I, A) {
                                        return m(x, g, I, A);
                                    }
                                    static get testCanvas() {
                                        return E;
                                    }
                                    static get testContext() {
                                        return w;
                                    }
                                    static get features() {
                                        return y;
                                    }
                                    static get fragmentShader() {
                                        return o;
                                    }
                                    static get vertexShader() {
                                        return n;
                                    }
                                    constructor(x, g){
                                        super(x, g), this.program = null, this.pipeline = g.pipeline, this.endianness = l.systemEndianness(), this.extensions = {}, this.argumentTextureCount = 0, this.constantTextureCount = 0, this.fragShader = null, this.vertShader = null, this.drawBuffersMap = null, this.maxTexSize = null, this.onRequestSwitchKernel = null, this.texture = null, this.mappedTextures = null, this.mergeSettings(x.settings || g), this.threadDim = null, this.framebuffer = null, this.buffer = null, this.textureCache = [], this.programUniformLocationCache = {}, this.uniform1fCache = {}, this.uniform1iCache = {}, this.uniform2fCache = {}, this.uniform2fvCache = {}, this.uniform2ivCache = {}, this.uniform3fvCache = {}, this.uniform3ivCache = {}, this.uniform4fvCache = {}, this.uniform4ivCache = {};
                                    }
                                    initCanvas() {
                                        if (typeof document < "u") {
                                            const x = document.createElement("canvas");
                                            return x.width = 2, x.height = 2, x;
                                        } else if (typeof OffscreenCanvas < "u") return new OffscreenCanvas(0, 0);
                                    }
                                    initContext() {
                                        const x = {
                                            alpha: !1,
                                            depth: !1,
                                            antialias: !1
                                        };
                                        return this.canvas.getContext("webgl", x) || this.canvas.getContext("experimental-webgl", x);
                                    }
                                    initPlugins(x) {
                                        const g = [], { source: I } = this;
                                        if (typeof I == "string") for(let A = 0; A < T.length; A++){
                                            const P = T[A];
                                            I.match(P.functionMatch) && g.push(P);
                                        }
                                        else if (typeof I == "object" && x.pluginNames) for(let A = 0; A < T.length; A++){
                                            const P = T[A];
                                            x.pluginNames.some((R)=>R === P.name) && g.push(P);
                                        }
                                        return g;
                                    }
                                    initExtensions() {
                                        this.extensions = {
                                            OES_texture_float: this.context.getExtension("OES_texture_float"),
                                            OES_texture_float_linear: this.context.getExtension("OES_texture_float_linear"),
                                            OES_element_index_uint: this.context.getExtension("OES_element_index_uint"),
                                            WEBGL_draw_buffers: this.context.getExtension("WEBGL_draw_buffers"),
                                            WEBGL_color_buffer_float: this.context.getExtension("WEBGL_color_buffer_float")
                                        };
                                    }
                                    validateSettings(x) {
                                        if (!this.validate) {
                                            this.texSize = l.getKernelTextureSize({
                                                optimizeFloatMemory: this.optimizeFloatMemory,
                                                precision: this.precision
                                            }, this.output);
                                            return;
                                        }
                                        const { features: g } = this.constructor;
                                        if (this.optimizeFloatMemory === !0 && !g.isTextureFloat) throw new Error("Float textures are not supported");
                                        if (this.precision === "single" && !g.isFloatRead) throw new Error("Single precision not supported");
                                        if (!this.graphical && this.precision === null && g.isTextureFloat && (this.precision = g.isFloatRead ? "single" : "unsigned"), this.subKernels && this.subKernels.length > 0 && !this.extensions.WEBGL_draw_buffers) throw new Error("could not instantiate draw buffers extension");
                                        if (this.fixIntegerDivisionAccuracy === null ? this.fixIntegerDivisionAccuracy = !g.isIntegerDivisionAccurate : this.fixIntegerDivisionAccuracy && g.isIntegerDivisionAccurate && (this.fixIntegerDivisionAccuracy = !1), this.checkOutput(), !this.output || this.output.length === 0) {
                                            if (x.length !== 1) throw new Error("Auto output only supported for kernels with only one input");
                                            const I = l.getVariableType(x[0], this.strictIntegers);
                                            switch(I){
                                                case "Array":
                                                    this.output = l.getDimensions(I);
                                                    break;
                                                case "NumberTexture":
                                                case "MemoryOptimizedNumberTexture":
                                                case "ArrayTexture(1)":
                                                case "ArrayTexture(2)":
                                                case "ArrayTexture(3)":
                                                case "ArrayTexture(4)":
                                                    this.output = x[0].output;
                                                    break;
                                                default:
                                                    throw new Error("Auto output not supported for input type: " + I);
                                            }
                                        }
                                        if (this.graphical) {
                                            if (this.output.length !== 2) throw new Error("Output must have 2 dimensions on graphical mode");
                                            this.precision === "precision" && (this.precision = "unsigned", console.warn("Cannot use graphical mode and single precision at the same time")), this.texSize = l.clone(this.output);
                                            return;
                                        } else this.precision === null && g.isTextureFloat && (this.precision = "single");
                                        this.texSize = l.getKernelTextureSize({
                                            optimizeFloatMemory: this.optimizeFloatMemory,
                                            precision: this.precision
                                        }, this.output), this.checkTextureSize();
                                    }
                                    updateMaxTexSize() {
                                        const { texSize: x, canvas: g } = this;
                                        if (this.maxTexSize === null) {
                                            let I = _.indexOf(g);
                                            I === -1 && (I = _.length, _.push(g), k[I] = [
                                                x[0],
                                                x[1]
                                            ]), this.maxTexSize = k[I];
                                        }
                                        this.maxTexSize[0] < x[0] && (this.maxTexSize[0] = x[0]), this.maxTexSize[1] < x[1] && (this.maxTexSize[1] = x[1]);
                                    }
                                    setupArguments(x) {
                                        this.kernelArguments = [], this.argumentTextureCount = 0;
                                        const g = this.argumentTypes === null;
                                        if (g && (this.argumentTypes = []), this.argumentSizes = [], this.argumentBitRatios = [], x.length < this.argumentNames.length) throw new Error("not enough arguments for kernel");
                                        if (x.length > this.argumentNames.length) throw new Error("too many arguments for kernel");
                                        const { context: I } = this;
                                        let A = 0;
                                        const P = ()=>this.createTexture(), O = ()=>this.constantTextureCount + A++, R = (U)=>{
                                            this.switchKernels({
                                                type: "argumentMismatch",
                                                needed: U
                                            });
                                        }, G = ()=>I.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount++;
                                        for(let U = 0; U < x.length; U++){
                                            const it = x[U], q = this.argumentNames[U];
                                            let B;
                                            g ? (B = l.getVariableType(it, this.strictIntegers), this.argumentTypes.push(B)) : B = this.argumentTypes[U];
                                            const st = this.constructor.lookupKernelValueType(B, this.dynamicArguments ? "dynamic" : "static", this.precision, x[U]);
                                            if (st === null) return this.requestFallback(x);
                                            const rt = new st(it, {
                                                name: q,
                                                type: B,
                                                tactic: this.tactic,
                                                origin: "user",
                                                context: I,
                                                checkContext: this.checkContext,
                                                kernel: this,
                                                strictIntegers: this.strictIntegers,
                                                onRequestTexture: P,
                                                onRequestIndex: O,
                                                onUpdateValueMismatch: R,
                                                onRequestContextHandle: G
                                            });
                                            this.kernelArguments.push(rt), rt.setup(), this.argumentSizes.push(rt.textureSize), this.argumentBitRatios[U] = rt.bitRatio;
                                        }
                                    }
                                    createTexture() {
                                        const x = this.context.createTexture();
                                        return this.textureCache.push(x), x;
                                    }
                                    setupConstants(x) {
                                        const { context: g } = this;
                                        this.kernelConstants = [], this.forceUploadKernelConstants = [];
                                        let I = this.constantTypes === null;
                                        I && (this.constantTypes = {}), this.constantBitRatios = {};
                                        let A = 0;
                                        for(const P in this.constants){
                                            const O = this.constants[P];
                                            let R;
                                            I ? (R = l.getVariableType(O, this.strictIntegers), this.constantTypes[P] = R) : R = this.constantTypes[P];
                                            const G = this.constructor.lookupKernelValueType(R, "static", this.precision, O);
                                            if (G === null) return this.requestFallback(x);
                                            const U = new G(O, {
                                                name: P,
                                                type: R,
                                                tactic: this.tactic,
                                                origin: "constants",
                                                context: this.context,
                                                checkContext: this.checkContext,
                                                kernel: this,
                                                strictIntegers: this.strictIntegers,
                                                onRequestTexture: ()=>this.createTexture(),
                                                onRequestIndex: ()=>A++,
                                                onRequestContextHandle: ()=>g.TEXTURE0 + this.constantTextureCount++
                                            });
                                            this.constantBitRatios[P] = U.bitRatio, this.kernelConstants.push(U), U.setup(), U.forceUploadEachRun && this.forceUploadKernelConstants.push(U);
                                        }
                                    }
                                    build() {
                                        if (this.built || (this.initExtensions(), this.validateSettings(arguments), this.setupConstants(arguments), this.fallbackRequested) || (this.setupArguments(arguments), this.fallbackRequested)) return;
                                        this.updateMaxTexSize(), this.translateSource();
                                        const x = this.pickRenderStrategy(arguments);
                                        if (x) return x;
                                        const { texSize: g, context: I, canvas: A } = this;
                                        I.enable(I.SCISSOR_TEST), this.pipeline && this.precision === "single" ? (I.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]), A.width = this.maxTexSize[0], A.height = this.maxTexSize[1]) : (I.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]), A.width = this.maxTexSize[0], A.height = this.maxTexSize[1]);
                                        const P = this.threadDim = Array.from(this.output);
                                        for(; P.length < 3;)P.push(1);
                                        const O = this.getVertexShader(arguments), R = I.createShader(I.VERTEX_SHADER);
                                        I.shaderSource(R, O), I.compileShader(R), this.vertShader = R;
                                        const G = this.getFragmentShader(arguments), U = I.createShader(I.FRAGMENT_SHADER);
                                        if (I.shaderSource(U, G), I.compileShader(U), this.fragShader = U, this.debug && (console.log("GLSL Shader Output:"), console.log(G)), !I.getShaderParameter(R, I.COMPILE_STATUS)) throw new Error("Error compiling vertex shader: " + I.getShaderInfoLog(R));
                                        if (!I.getShaderParameter(U, I.COMPILE_STATUS)) throw new Error("Error compiling fragment shader: " + I.getShaderInfoLog(U));
                                        const it = this.program = I.createProgram();
                                        I.attachShader(it, R), I.attachShader(it, U), I.linkProgram(it), this.framebuffer = I.createFramebuffer(), this.framebuffer.width = g[0], this.framebuffer.height = g[1], this.rawValueFramebuffers = {};
                                        const q = new Float32Array([
                                            -1,
                                            -1,
                                            1,
                                            -1,
                                            -1,
                                            1,
                                            1,
                                            1
                                        ]), B = new Float32Array([
                                            0,
                                            0,
                                            1,
                                            0,
                                            0,
                                            1,
                                            1,
                                            1
                                        ]), st = q.byteLength;
                                        let rt = this.buffer;
                                        rt ? I.bindBuffer(I.ARRAY_BUFFER, rt) : (rt = this.buffer = I.createBuffer(), I.bindBuffer(I.ARRAY_BUFFER, rt), I.bufferData(I.ARRAY_BUFFER, q.byteLength + B.byteLength, I.STATIC_DRAW)), I.bufferSubData(I.ARRAY_BUFFER, 0, q), I.bufferSubData(I.ARRAY_BUFFER, st, B);
                                        const mt = I.getAttribLocation(this.program, "aPos");
                                        I.enableVertexAttribArray(mt), I.vertexAttribPointer(mt, 2, I.FLOAT, !1, 0, 0);
                                        const tt = I.getAttribLocation(this.program, "aTexCoord");
                                        I.enableVertexAttribArray(tt), I.vertexAttribPointer(tt, 2, I.FLOAT, !1, 0, st), I.bindFramebuffer(I.FRAMEBUFFER, this.framebuffer);
                                        let et = 0;
                                        I.useProgram(this.program);
                                        for(let J in this.constants)this.kernelConstants[et++].updateValue(this.constants[J]);
                                        this._setupOutputTexture(), this.subKernels !== null && this.subKernels.length > 0 && (this._mappedTextureSwitched = {}, this._setupSubOutputTextures()), this.buildSignature(arguments), this.built = !0;
                                    }
                                    translateSource() {
                                        const x = p.fromKernel(this, d, {
                                            fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
                                        });
                                        this.translatedSource = x.getPrototypeString("kernel"), this.setupReturnTypes(x);
                                    }
                                    setupReturnTypes(x) {
                                        if (!this.graphical && !this.returnType && (this.returnType = x.getKernelResultType()), this.subKernels && this.subKernels.length > 0) for(let g = 0; g < this.subKernels.length; g++){
                                            const I = this.subKernels[g];
                                            I.returnType || (I.returnType = x.getSubKernelResultType(g));
                                        }
                                    }
                                    run() {
                                        const { kernelArguments: x, texSize: g, forceUploadKernelConstants: I, context: A } = this;
                                        A.useProgram(this.program), A.scissor(0, 0, g[0], g[1]), this.dynamicOutput && (this.setUniform3iv("uOutputDim", new Int32Array(this.threadDim)), this.setUniform2iv("uTexSize", g)), this.setUniform2f("ratio", g[0] / this.maxTexSize[0], g[1] / this.maxTexSize[1]);
                                        for(let P = 0; P < I.length; P++){
                                            const O = I[P];
                                            if (O.updateValue(this.constants[O.name]), this.switchingKernels) return;
                                        }
                                        for(let P = 0; P < x.length; P++)if (x[P].updateValue(arguments[P]), this.switchingKernels) return;
                                        if (this.plugins) for(let P = 0; P < this.plugins.length; P++){
                                            const O = this.plugins[P];
                                            O.onBeforeRun && O.onBeforeRun(this);
                                        }
                                        if (this.graphical) {
                                            if (this.pipeline) return A.bindRenderbuffer(A.RENDERBUFFER, null), A.bindFramebuffer(A.FRAMEBUFFER, this.framebuffer), this.immutable && this._replaceOutputTexture(), A.drawArrays(A.TRIANGLE_STRIP, 0, 4), this.immutable ? this.texture.clone() : this.texture;
                                            A.bindRenderbuffer(A.RENDERBUFFER, null), A.bindFramebuffer(A.FRAMEBUFFER, null), A.drawArrays(A.TRIANGLE_STRIP, 0, 4);
                                            return;
                                        }
                                        A.bindFramebuffer(A.FRAMEBUFFER, this.framebuffer), this.immutable && this._replaceOutputTexture(), this.subKernels !== null && (this.immutable && this._replaceSubOutputTextures(), this.drawBuffers()), A.drawArrays(A.TRIANGLE_STRIP, 0, 4);
                                    }
                                    drawBuffers() {
                                        this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap);
                                    }
                                    getInternalFormat() {
                                        return this.context.RGBA;
                                    }
                                    getTextureFormat() {
                                        const { context: x } = this;
                                        switch(this.getInternalFormat()){
                                            case x.RGBA:
                                                return x.RGBA;
                                            default:
                                                throw new Error("Unknown internal format");
                                        }
                                    }
                                    _replaceOutputTexture() {
                                        if (this.texture.beforeMutate() || this._textureSwitched) {
                                            const x = this.context;
                                            x.framebufferTexture2D(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0, x.TEXTURE_2D, this.texture.texture, 0), this._textureSwitched = !1;
                                        }
                                    }
                                    _setupOutputTexture() {
                                        const x = this.context, g = this.texSize;
                                        if (this.texture) {
                                            x.framebufferTexture2D(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0, x.TEXTURE_2D, this.texture.texture, 0);
                                            return;
                                        }
                                        const I = this.createTexture();
                                        x.activeTexture(x.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount), x.bindTexture(x.TEXTURE_2D, I), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_S, x.CLAMP_TO_EDGE), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_T, x.CLAMP_TO_EDGE), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.NEAREST), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MAG_FILTER, x.NEAREST);
                                        const A = this.getInternalFormat();
                                        this.precision === "single" ? x.texImage2D(x.TEXTURE_2D, 0, A, g[0], g[1], 0, x.RGBA, x.FLOAT, null) : x.texImage2D(x.TEXTURE_2D, 0, A, g[0], g[1], 0, A, x.UNSIGNED_BYTE, null), x.framebufferTexture2D(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0, x.TEXTURE_2D, I, 0), this.texture = new this.TextureConstructor({
                                            texture: I,
                                            size: g,
                                            dimensions: this.threadDim,
                                            output: this.output,
                                            context: this.context,
                                            internalFormat: this.getInternalFormat(),
                                            textureFormat: this.getTextureFormat(),
                                            kernel: this
                                        });
                                    }
                                    _replaceSubOutputTextures() {
                                        const x = this.context;
                                        for(let g = 0; g < this.mappedTextures.length; g++){
                                            const I = this.mappedTextures[g];
                                            (I.beforeMutate() || this._mappedTextureSwitched[g]) && (x.framebufferTexture2D(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0 + g + 1, x.TEXTURE_2D, I.texture, 0), this._mappedTextureSwitched[g] = !1);
                                        }
                                    }
                                    _setupSubOutputTextures() {
                                        const x = this.context;
                                        if (this.mappedTextures) {
                                            for(let I = 0; I < this.subKernels.length; I++)x.framebufferTexture2D(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0 + I + 1, x.TEXTURE_2D, this.mappedTextures[I].texture, 0);
                                            return;
                                        }
                                        const g = this.texSize;
                                        this.drawBuffersMap = [
                                            x.COLOR_ATTACHMENT0
                                        ], this.mappedTextures = [];
                                        for(let I = 0; I < this.subKernels.length; I++){
                                            const A = this.createTexture();
                                            this.drawBuffersMap.push(x.COLOR_ATTACHMENT0 + I + 1), x.activeTexture(x.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + I), x.bindTexture(x.TEXTURE_2D, A), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_S, x.CLAMP_TO_EDGE), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_T, x.CLAMP_TO_EDGE), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.NEAREST), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MAG_FILTER, x.NEAREST), this.precision === "single" ? x.texImage2D(x.TEXTURE_2D, 0, x.RGBA, g[0], g[1], 0, x.RGBA, x.FLOAT, null) : x.texImage2D(x.TEXTURE_2D, 0, x.RGBA, g[0], g[1], 0, x.RGBA, x.UNSIGNED_BYTE, null), x.framebufferTexture2D(x.FRAMEBUFFER, x.COLOR_ATTACHMENT0 + I + 1, x.TEXTURE_2D, A, 0), this.mappedTextures.push(new this.TextureConstructor({
                                                texture: A,
                                                size: g,
                                                dimensions: this.threadDim,
                                                output: this.output,
                                                context: this.context,
                                                internalFormat: this.getInternalFormat(),
                                                textureFormat: this.getTextureFormat(),
                                                kernel: this
                                            }));
                                        }
                                    }
                                    setUniform1f(x, g) {
                                        if (this.uniform1fCache.hasOwnProperty(x)) {
                                            const A = this.uniform1fCache[x];
                                            if (g === A) return;
                                        }
                                        this.uniform1fCache[x] = g;
                                        const I = this.getUniformLocation(x);
                                        this.context.uniform1f(I, g);
                                    }
                                    setUniform1i(x, g) {
                                        if (this.uniform1iCache.hasOwnProperty(x)) {
                                            const A = this.uniform1iCache[x];
                                            if (g === A) return;
                                        }
                                        this.uniform1iCache[x] = g;
                                        const I = this.getUniformLocation(x);
                                        this.context.uniform1i(I, g);
                                    }
                                    setUniform2f(x, g, I) {
                                        if (this.uniform2fCache.hasOwnProperty(x)) {
                                            const P = this.uniform2fCache[x];
                                            if (g === P[0] && I === P[1]) return;
                                        }
                                        this.uniform2fCache[x] = [
                                            g,
                                            I
                                        ];
                                        const A = this.getUniformLocation(x);
                                        this.context.uniform2f(A, g, I);
                                    }
                                    setUniform2fv(x, g) {
                                        if (this.uniform2fvCache.hasOwnProperty(x)) {
                                            const A = this.uniform2fvCache[x];
                                            if (g[0] === A[0] && g[1] === A[1]) return;
                                        }
                                        this.uniform2fvCache[x] = g;
                                        const I = this.getUniformLocation(x);
                                        this.context.uniform2fv(I, g);
                                    }
                                    setUniform2iv(x, g) {
                                        if (this.uniform2ivCache.hasOwnProperty(x)) {
                                            const A = this.uniform2ivCache[x];
                                            if (g[0] === A[0] && g[1] === A[1]) return;
                                        }
                                        this.uniform2ivCache[x] = g;
                                        const I = this.getUniformLocation(x);
                                        this.context.uniform2iv(I, g);
                                    }
                                    setUniform3fv(x, g) {
                                        if (this.uniform3fvCache.hasOwnProperty(x)) {
                                            const A = this.uniform3fvCache[x];
                                            if (g[0] === A[0] && g[1] === A[1] && g[2] === A[2]) return;
                                        }
                                        this.uniform3fvCache[x] = g;
                                        const I = this.getUniformLocation(x);
                                        this.context.uniform3fv(I, g);
                                    }
                                    setUniform3iv(x, g) {
                                        if (this.uniform3ivCache.hasOwnProperty(x)) {
                                            const A = this.uniform3ivCache[x];
                                            if (g[0] === A[0] && g[1] === A[1] && g[2] === A[2]) return;
                                        }
                                        this.uniform3ivCache[x] = g;
                                        const I = this.getUniformLocation(x);
                                        this.context.uniform3iv(I, g);
                                    }
                                    setUniform4fv(x, g) {
                                        if (this.uniform4fvCache.hasOwnProperty(x)) {
                                            const A = this.uniform4fvCache[x];
                                            if (g[0] === A[0] && g[1] === A[1] && g[2] === A[2] && g[3] === A[3]) return;
                                        }
                                        this.uniform4fvCache[x] = g;
                                        const I = this.getUniformLocation(x);
                                        this.context.uniform4fv(I, g);
                                    }
                                    setUniform4iv(x, g) {
                                        if (this.uniform4ivCache.hasOwnProperty(x)) {
                                            const A = this.uniform4ivCache[x];
                                            if (g[0] === A[0] && g[1] === A[1] && g[2] === A[2] && g[3] === A[3]) return;
                                        }
                                        this.uniform4ivCache[x] = g;
                                        const I = this.getUniformLocation(x);
                                        this.context.uniform4iv(I, g);
                                    }
                                    getUniformLocation(x) {
                                        return this.programUniformLocationCache.hasOwnProperty(x) ? this.programUniformLocationCache[x] : this.programUniformLocationCache[x] = this.context.getUniformLocation(this.program, x);
                                    }
                                    _getFragShaderArtifactMap(x) {
                                        return {
                                            HEADER: this._getHeaderString(),
                                            LOOP_MAX: this._getLoopMaxString(),
                                            PLUGINS: this._getPluginsString(),
                                            CONSTANTS: this._getConstantsString(),
                                            DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),
                                            ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),
                                            DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),
                                            INJECTED_NATIVE: this._getInjectedNative(),
                                            MAIN_CONSTANTS: this._getMainConstantsString(),
                                            MAIN_ARGUMENTS: this._getMainArgumentsString(x),
                                            KERNEL: this.getKernelString(),
                                            MAIN_RESULT: this.getMainResultString(),
                                            FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
                                            INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
                                            SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
                                            SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration()
                                        };
                                    }
                                    _getVertShaderArtifactMap(x) {
                                        return {
                                            FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
                                            INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
                                            SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
                                            SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration()
                                        };
                                    }
                                    _getHeaderString() {
                                        return this.subKernels !== null ? `#extension GL_EXT_draw_buffers : require
` : "";
                                    }
                                    _getLoopMaxString() {
                                        return this.loopMaxIterations ? ` ${parseInt(this.loopMaxIterations)};
` : ` 1000;
`;
                                    }
                                    _getPluginsString() {
                                        return this.plugins ? this.plugins.map((x)=>x.source && this.source.match(x.functionMatch) ? x.source : "").join(`
`) : `
`;
                                    }
                                    _getConstantsString() {
                                        const x = [], { threadDim: g, texSize: I } = this;
                                        return this.dynamicOutput ? x.push("uniform ivec3 uOutputDim", "uniform ivec2 uTexSize") : x.push(`ivec3 uOutputDim = ivec3(${g[0]}, ${g[1]}, ${g[2]})`, `ivec2 uTexSize = ivec2(${I[0]}, ${I[1]})`), l.linesToString(x);
                                    }
                                    _getTextureCoordinate() {
                                        const x = this.subKernels;
                                        return x === null || x.length < 1 ? `varying vec2 vTexCoord;
` : `out vec2 vTexCoord;
`;
                                    }
                                    _getDecode32EndiannessString() {
                                        return this.endianness === "LE" ? "" : `  texel.rgba = texel.abgr;
`;
                                    }
                                    _getEncode32EndiannessString() {
                                        return this.endianness === "LE" ? "" : `  texel.rgba = texel.abgr;
`;
                                    }
                                    _getDivideWithIntegerCheckString() {
                                        return this.fixIntegerDivisionAccuracy ? `float divWithIntCheck(float x, float y) {
  if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {
    return float(int(x) / int(y));
  }
  return x / y;
}

float integerCorrectionModulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -(number - (divisor * floor(divWithIntCheck(number, divisor))));
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return number - (divisor * floor(divWithIntCheck(number, divisor)));
}` : "";
                                    }
                                    _getMainArgumentsString(x) {
                                        const g = [], { argumentNames: I } = this;
                                        for(let A = 0; A < I.length; A++)g.push(this.kernelArguments[A].getSource(x[A]));
                                        return g.join("");
                                    }
                                    _getInjectedNative() {
                                        return this.injectedNative || "";
                                    }
                                    _getMainConstantsString() {
                                        const x = [], { constants: g } = this;
                                        if (g) {
                                            let I = 0;
                                            for(const A in g)this.constants.hasOwnProperty(A) && x.push(this.kernelConstants[I++].getSource(this.constants[A]));
                                        }
                                        return x.join("");
                                    }
                                    getRawValueFramebuffer(x, g) {
                                        if (this.rawValueFramebuffers[x] || (this.rawValueFramebuffers[x] = {}), !this.rawValueFramebuffers[x][g]) {
                                            const I = this.context.createFramebuffer();
                                            I.width = x, I.height = g, this.rawValueFramebuffers[x][g] = I;
                                        }
                                        return this.rawValueFramebuffers[x][g];
                                    }
                                    getKernelResultDeclaration() {
                                        switch(this.returnType){
                                            case "Array(2)":
                                                return "vec2 kernelResult";
                                            case "Array(3)":
                                                return "vec3 kernelResult";
                                            case "Array(4)":
                                                return "vec4 kernelResult";
                                            case "LiteralInteger":
                                            case "Float":
                                            case "Number":
                                            case "Integer":
                                                return "float kernelResult";
                                            default:
                                                if (this.graphical) return "float kernelResult";
                                                throw new Error(`unrecognized output type "${this.returnType}"`);
                                        }
                                    }
                                    getKernelString() {
                                        const x = [
                                            this.getKernelResultDeclaration()
                                        ], { subKernels: g } = this;
                                        if (g !== null) switch(this.returnType){
                                            case "Number":
                                            case "Float":
                                            case "Integer":
                                                for(let I = 0; I < g.length; I++){
                                                    const A = g[I];
                                                    x.push(A.returnType === "Integer" ? `int subKernelResult_${A.name} = 0` : `float subKernelResult_${A.name} = 0.0`);
                                                }
                                                break;
                                            case "Array(2)":
                                                for(let I = 0; I < g.length; I++)x.push(`vec2 subKernelResult_${g[I].name}`);
                                                break;
                                            case "Array(3)":
                                                for(let I = 0; I < g.length; I++)x.push(`vec3 subKernelResult_${g[I].name}`);
                                                break;
                                            case "Array(4)":
                                                for(let I = 0; I < g.length; I++)x.push(`vec4 subKernelResult_${g[I].name}`);
                                                break;
                                        }
                                        return l.linesToString(x) + this.translatedSource;
                                    }
                                    getMainResultGraphical() {
                                        return l.linesToString([
                                            "  threadId = indexTo3D(index, uOutputDim)",
                                            "  kernel()",
                                            "  gl_FragColor = actualColor"
                                        ]);
                                    }
                                    getMainResultPackedPixels() {
                                        switch(this.returnType){
                                            case "LiteralInteger":
                                            case "Number":
                                            case "Integer":
                                            case "Float":
                                                return this.getMainResultKernelPackedPixels() + this.getMainResultSubKernelPackedPixels();
                                            default:
                                                throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
                                        }
                                    }
                                    getMainResultKernelPackedPixels() {
                                        return l.linesToString([
                                            "  threadId = indexTo3D(index, uOutputDim)",
                                            "  kernel()",
                                            `  gl_FragData[0] = ${this.useLegacyEncoder ? "legacyEncode32" : "encode32"}(kernelResult)`
                                        ]);
                                    }
                                    getMainResultSubKernelPackedPixels() {
                                        const x = [];
                                        if (!this.subKernels) return "";
                                        for(let g = 0; g < this.subKernels.length; g++)this.subKernels[g].returnType === "Integer" ? x.push(`  gl_FragData[${g + 1}] = ${this.useLegacyEncoder ? "legacyEncode32" : "encode32"}(float(subKernelResult_${this.subKernels[g].name}))`) : x.push(`  gl_FragData[${g + 1}] = ${this.useLegacyEncoder ? "legacyEncode32" : "encode32"}(subKernelResult_${this.subKernels[g].name})`);
                                        return l.linesToString(x);
                                    }
                                    getMainResultMemoryOptimizedFloats() {
                                        const x = [
                                            "  index *= 4"
                                        ];
                                        switch(this.returnType){
                                            case "Number":
                                            case "Integer":
                                            case "Float":
                                                const g = [
                                                    "r",
                                                    "g",
                                                    "b",
                                                    "a"
                                                ];
                                                for(let I = 0; I < g.length; I++){
                                                    const A = g[I];
                                                    this.getMainResultKernelMemoryOptimizedFloats(x, A), this.getMainResultSubKernelMemoryOptimizedFloats(x, A), I + 1 < g.length && x.push("  index += 1");
                                                }
                                                break;
                                            default:
                                                throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`);
                                        }
                                        return l.linesToString(x);
                                    }
                                    getMainResultKernelMemoryOptimizedFloats(x, g) {
                                        x.push("  threadId = indexTo3D(index, uOutputDim)", "  kernel()", `  gl_FragData[0].${g} = kernelResult`);
                                    }
                                    getMainResultSubKernelMemoryOptimizedFloats(x, g) {
                                        if (!this.subKernels) return x;
                                        for(let I = 0; I < this.subKernels.length; I++)this.subKernels[I].returnType === "Integer" ? x.push(`  gl_FragData[${I + 1}].${g} = float(subKernelResult_${this.subKernels[I].name})`) : x.push(`  gl_FragData[${I + 1}].${g} = subKernelResult_${this.subKernels[I].name}`);
                                    }
                                    getMainResultKernelNumberTexture() {
                                        return [
                                            "  threadId = indexTo3D(index, uOutputDim)",
                                            "  kernel()",
                                            "  gl_FragData[0][0] = kernelResult"
                                        ];
                                    }
                                    getMainResultSubKernelNumberTexture() {
                                        const x = [];
                                        if (!this.subKernels) return x;
                                        for(let g = 0; g < this.subKernels.length; ++g){
                                            const I = this.subKernels[g];
                                            I.returnType === "Integer" ? x.push(`  gl_FragData[${g + 1}][0] = float(subKernelResult_${I.name})`) : x.push(`  gl_FragData[${g + 1}][0] = subKernelResult_${I.name}`);
                                        }
                                        return x;
                                    }
                                    getMainResultKernelArray2Texture() {
                                        return [
                                            "  threadId = indexTo3D(index, uOutputDim)",
                                            "  kernel()",
                                            "  gl_FragData[0][0] = kernelResult[0]",
                                            "  gl_FragData[0][1] = kernelResult[1]"
                                        ];
                                    }
                                    getMainResultSubKernelArray2Texture() {
                                        const x = [];
                                        if (!this.subKernels) return x;
                                        for(let g = 0; g < this.subKernels.length; ++g)x.push(`  gl_FragData[${g + 1}][0] = subKernelResult_${this.subKernels[g].name}[0]`, `  gl_FragData[${g + 1}][1] = subKernelResult_${this.subKernels[g].name}[1]`);
                                        return x;
                                    }
                                    getMainResultKernelArray3Texture() {
                                        return [
                                            "  threadId = indexTo3D(index, uOutputDim)",
                                            "  kernel()",
                                            "  gl_FragData[0][0] = kernelResult[0]",
                                            "  gl_FragData[0][1] = kernelResult[1]",
                                            "  gl_FragData[0][2] = kernelResult[2]"
                                        ];
                                    }
                                    getMainResultSubKernelArray3Texture() {
                                        const x = [];
                                        if (!this.subKernels) return x;
                                        for(let g = 0; g < this.subKernels.length; ++g)x.push(`  gl_FragData[${g + 1}][0] = subKernelResult_${this.subKernels[g].name}[0]`, `  gl_FragData[${g + 1}][1] = subKernelResult_${this.subKernels[g].name}[1]`, `  gl_FragData[${g + 1}][2] = subKernelResult_${this.subKernels[g].name}[2]`);
                                        return x;
                                    }
                                    getMainResultKernelArray4Texture() {
                                        return [
                                            "  threadId = indexTo3D(index, uOutputDim)",
                                            "  kernel()",
                                            "  gl_FragData[0] = kernelResult"
                                        ];
                                    }
                                    getMainResultSubKernelArray4Texture() {
                                        const x = [];
                                        if (!this.subKernels) return x;
                                        switch(this.returnType){
                                            case "Number":
                                            case "Float":
                                            case "Integer":
                                                for(let g = 0; g < this.subKernels.length; ++g)this.subKernels[g].returnType === "Integer" ? x.push(`  gl_FragData[${g + 1}] = float(subKernelResult_${this.subKernels[g].name})`) : x.push(`  gl_FragData[${g + 1}] = subKernelResult_${this.subKernels[g].name}`);
                                                break;
                                            case "Array(2)":
                                                for(let g = 0; g < this.subKernels.length; ++g)x.push(`  gl_FragData[${g + 1}][0] = subKernelResult_${this.subKernels[g].name}[0]`, `  gl_FragData[${g + 1}][1] = subKernelResult_${this.subKernels[g].name}[1]`);
                                                break;
                                            case "Array(3)":
                                                for(let g = 0; g < this.subKernels.length; ++g)x.push(`  gl_FragData[${g + 1}][0] = subKernelResult_${this.subKernels[g].name}[0]`, `  gl_FragData[${g + 1}][1] = subKernelResult_${this.subKernels[g].name}[1]`, `  gl_FragData[${g + 1}][2] = subKernelResult_${this.subKernels[g].name}[2]`);
                                                break;
                                            case "Array(4)":
                                                for(let g = 0; g < this.subKernels.length; ++g)x.push(`  gl_FragData[${g + 1}][0] = subKernelResult_${this.subKernels[g].name}[0]`, `  gl_FragData[${g + 1}][1] = subKernelResult_${this.subKernels[g].name}[1]`, `  gl_FragData[${g + 1}][2] = subKernelResult_${this.subKernels[g].name}[2]`, `  gl_FragData[${g + 1}][3] = subKernelResult_${this.subKernels[g].name}[3]`);
                                                break;
                                        }
                                        return x;
                                    }
                                    replaceArtifacts(x, g) {
                                        return x.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\n/g, (I, A)=>{
                                            if (g.hasOwnProperty(A)) return g[A];
                                            throw `unhandled artifact ${A}`;
                                        });
                                    }
                                    getFragmentShader(x) {
                                        return this.compiledFragmentShader !== null ? this.compiledFragmentShader : this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(x));
                                    }
                                    getVertexShader(x) {
                                        return this.compiledVertexShader !== null ? this.compiledVertexShader : this.compiledVertexShader = this.replaceArtifacts(this.constructor.vertexShader, this._getVertShaderArtifactMap(x));
                                    }
                                    toString() {
                                        const x = l.linesToString([
                                            "const gl = context"
                                        ]);
                                        return r(this.constructor, arguments, this, x);
                                    }
                                    destroy(x) {
                                        if (!this.context) return;
                                        this.buffer && this.context.deleteBuffer(this.buffer), this.framebuffer && this.context.deleteFramebuffer(this.framebuffer);
                                        for(const I in this.rawValueFramebuffers){
                                            for(const A in this.rawValueFramebuffers[I])this.context.deleteFramebuffer(this.rawValueFramebuffers[I][A]), delete this.rawValueFramebuffers[I][A];
                                            delete this.rawValueFramebuffers[I];
                                        }
                                        if (this.vertShader && this.context.deleteShader(this.vertShader), this.fragShader && this.context.deleteShader(this.fragShader), this.program && this.context.deleteProgram(this.program), this.texture) {
                                            this.texture.delete();
                                            const I = this.textureCache.indexOf(this.texture.texture);
                                            I > -1 && this.textureCache.splice(I, 1), this.texture = null;
                                        }
                                        if (this.mappedTextures && this.mappedTextures.length) {
                                            for(let I = 0; I < this.mappedTextures.length; I++){
                                                const A = this.mappedTextures[I];
                                                A.delete();
                                                const P = this.textureCache.indexOf(A.texture);
                                                P > -1 && this.textureCache.splice(P, 1);
                                            }
                                            this.mappedTextures = null;
                                        }
                                        if (this.kernelArguments) for(let I = 0; I < this.kernelArguments.length; I++)this.kernelArguments[I].destroy();
                                        if (this.kernelConstants) for(let I = 0; I < this.kernelConstants.length; I++)this.kernelConstants[I].destroy();
                                        for(; this.textureCache.length > 0;){
                                            const I = this.textureCache.pop();
                                            this.context.deleteTexture(I);
                                        }
                                        if (x) {
                                            const I = _.indexOf(this.canvas);
                                            I >= 0 && (_[I] = null, k[I] = null);
                                        }
                                        if (this.destroyExtensions(), delete this.context, delete this.canvas, !this.gpu) return;
                                        const g = this.gpu.kernels.indexOf(this);
                                        g !== -1 && this.gpu.kernels.splice(g, 1);
                                    }
                                    destroyExtensions() {
                                        this.extensions.OES_texture_float = null, this.extensions.OES_texture_float_linear = null, this.extensions.OES_element_index_uint = null, this.extensions.WEBGL_draw_buffers = null;
                                    }
                                    static destroyContext(x) {
                                        const g = x.getExtension("WEBGL_lose_context");
                                        g && g.loseContext();
                                    }
                                    toJSON() {
                                        const x = super.toJSON();
                                        return x.functionNodes = p.fromKernel(this, d).toJSON(), x.settings.threadDim = this.threadDim, x;
                                    }
                                }
                                i.exports = {
                                    WebGLKernel: C
                                };
                            },
                            {
                                "../../plugins/math-random-uniformly-distributed": 112,
                                "../../utils": 114,
                                "../function-builder": 9,
                                "../gl/kernel": 13,
                                "../gl/kernel-string": 12,
                                "./fragment-shader": 37,
                                "./function-node": 38,
                                "./kernel-value-maps": 39,
                                "./vertex-shader": 71
                            }
                        ],
                        71: [
                            function(e, i, h) {
                                const u = `__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

attribute vec2 aPos;
attribute vec2 aTexCoord;

varying vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;
                                i.exports = {
                                    vertexShader: u
                                };
                            },
                            {}
                        ],
                        72: [
                            function(e, i, h) {
                                const u = `#version 300 es
__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;
__SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

in vec2 vTexCoord;

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float _round(float x) {
  return floor(x + 0.5);
}


const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x/y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  return texel[channel] * 255.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  index = index / 4;
  vec4 texel = texture(tex, st / vec2(texSize));
  return texel[channel];
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, st / vec2(texSize));
}

vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, vec3(st / vec2(texSize), z));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));

  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;
                                i.exports = {
                                    fragmentShader: u
                                };
                            },
                            {}
                        ],
                        73: [
                            function(e, i, h) {
                                const { utils: u } = e("../../utils"), { WebGLFunctionNode: p } = e("../web-gl/function-node");
                                class d extends p {
                                    astIdentifierExpression(a, o) {
                                        if (a.type !== "Identifier") throw this.astErrorOutput("IdentifierExpression - not an Identifier", a);
                                        const n = this.getType(a), r = u.sanitizeName(a.name);
                                        return a.name === "Infinity" ? o.push("intBitsToFloat(2139095039)") : n === "Boolean" ? this.argumentNames.indexOf(r) > -1 ? o.push(`bool(user_${r})`) : o.push(`user_${r}`) : o.push(`user_${r}`), o;
                                    }
                                }
                                i.exports = {
                                    WebGL2FunctionNode: d
                                };
                            },
                            {
                                "../../utils": 114,
                                "../web-gl/function-node": 38
                            }
                        ],
                        74: [
                            function(e, i, h) {
                                const { WebGL2KernelValueBoolean: u } = e("./kernel-value/boolean"), { WebGL2KernelValueFloat: p } = e("./kernel-value/float"), { WebGL2KernelValueInteger: d } = e("./kernel-value/integer"), { WebGL2KernelValueHTMLImage: l } = e("./kernel-value/html-image"), { WebGL2KernelValueDynamicHTMLImage: a } = e("./kernel-value/dynamic-html-image"), { WebGL2KernelValueHTMLImageArray: o } = e("./kernel-value/html-image-array"), { WebGL2KernelValueDynamicHTMLImageArray: n } = e("./kernel-value/dynamic-html-image-array"), { WebGL2KernelValueHTMLVideo: r } = e("./kernel-value/html-video"), { WebGL2KernelValueDynamicHTMLVideo: m } = e("./kernel-value/dynamic-html-video"), { WebGL2KernelValueSingleInput: b } = e("./kernel-value/single-input"), { WebGL2KernelValueDynamicSingleInput: E } = e("./kernel-value/dynamic-single-input"), { WebGL2KernelValueUnsignedInput: w } = e("./kernel-value/unsigned-input"), { WebGL2KernelValueDynamicUnsignedInput: v } = e("./kernel-value/dynamic-unsigned-input"), { WebGL2KernelValueMemoryOptimizedNumberTexture: y } = e("./kernel-value/memory-optimized-number-texture"), { WebGL2KernelValueDynamicMemoryOptimizedNumberTexture: T } = e("./kernel-value/dynamic-memory-optimized-number-texture"), { WebGL2KernelValueNumberTexture: _ } = e("./kernel-value/number-texture"), { WebGL2KernelValueDynamicNumberTexture: k } = e("./kernel-value/dynamic-number-texture"), { WebGL2KernelValueSingleArray: C } = e("./kernel-value/single-array"), { WebGL2KernelValueDynamicSingleArray: M } = e("./kernel-value/dynamic-single-array"), { WebGL2KernelValueSingleArray1DI: x } = e("./kernel-value/single-array1d-i"), { WebGL2KernelValueDynamicSingleArray1DI: g } = e("./kernel-value/dynamic-single-array1d-i"), { WebGL2KernelValueSingleArray2DI: I } = e("./kernel-value/single-array2d-i"), { WebGL2KernelValueDynamicSingleArray2DI: A } = e("./kernel-value/dynamic-single-array2d-i"), { WebGL2KernelValueSingleArray3DI: P } = e("./kernel-value/single-array3d-i"), { WebGL2KernelValueDynamicSingleArray3DI: O } = e("./kernel-value/dynamic-single-array3d-i"), { WebGL2KernelValueArray2: R } = e("./kernel-value/array2"), { WebGL2KernelValueArray3: G } = e("./kernel-value/array3"), { WebGL2KernelValueArray4: U } = e("./kernel-value/array4"), { WebGL2KernelValueUnsignedArray: it } = e("./kernel-value/unsigned-array"), { WebGL2KernelValueDynamicUnsignedArray: q } = e("./kernel-value/dynamic-unsigned-array"), B = {
                                    unsigned: {
                                        dynamic: {
                                            Boolean: u,
                                            Integer: d,
                                            Float: p,
                                            Array: q,
                                            "Array(2)": R,
                                            "Array(3)": G,
                                            "Array(4)": U,
                                            "Array1D(2)": !1,
                                            "Array1D(3)": !1,
                                            "Array1D(4)": !1,
                                            "Array2D(2)": !1,
                                            "Array2D(3)": !1,
                                            "Array2D(4)": !1,
                                            "Array3D(2)": !1,
                                            "Array3D(3)": !1,
                                            "Array3D(4)": !1,
                                            Input: v,
                                            NumberTexture: k,
                                            "ArrayTexture(1)": k,
                                            "ArrayTexture(2)": k,
                                            "ArrayTexture(3)": k,
                                            "ArrayTexture(4)": k,
                                            MemoryOptimizedNumberTexture: T,
                                            HTMLCanvas: a,
                                            OffscreenCanvas: a,
                                            HTMLImage: a,
                                            ImageBitmap: a,
                                            ImageData: a,
                                            HTMLImageArray: n,
                                            HTMLVideo: m
                                        },
                                        static: {
                                            Boolean: u,
                                            Float: p,
                                            Integer: d,
                                            Array: it,
                                            "Array(2)": R,
                                            "Array(3)": G,
                                            "Array(4)": U,
                                            "Array1D(2)": !1,
                                            "Array1D(3)": !1,
                                            "Array1D(4)": !1,
                                            "Array2D(2)": !1,
                                            "Array2D(3)": !1,
                                            "Array2D(4)": !1,
                                            "Array3D(2)": !1,
                                            "Array3D(3)": !1,
                                            "Array3D(4)": !1,
                                            Input: w,
                                            NumberTexture: _,
                                            "ArrayTexture(1)": _,
                                            "ArrayTexture(2)": _,
                                            "ArrayTexture(3)": _,
                                            "ArrayTexture(4)": _,
                                            MemoryOptimizedNumberTexture: T,
                                            HTMLCanvas: l,
                                            OffscreenCanvas: l,
                                            HTMLImage: l,
                                            ImageBitmap: l,
                                            ImageData: l,
                                            HTMLImageArray: o,
                                            HTMLVideo: r
                                        }
                                    },
                                    single: {
                                        dynamic: {
                                            Boolean: u,
                                            Integer: d,
                                            Float: p,
                                            Array: M,
                                            "Array(2)": R,
                                            "Array(3)": G,
                                            "Array(4)": U,
                                            "Array1D(2)": g,
                                            "Array1D(3)": g,
                                            "Array1D(4)": g,
                                            "Array2D(2)": A,
                                            "Array2D(3)": A,
                                            "Array2D(4)": A,
                                            "Array3D(2)": O,
                                            "Array3D(3)": O,
                                            "Array3D(4)": O,
                                            Input: E,
                                            NumberTexture: k,
                                            "ArrayTexture(1)": k,
                                            "ArrayTexture(2)": k,
                                            "ArrayTexture(3)": k,
                                            "ArrayTexture(4)": k,
                                            MemoryOptimizedNumberTexture: T,
                                            HTMLCanvas: a,
                                            OffscreenCanvas: a,
                                            HTMLImage: a,
                                            ImageBitmap: a,
                                            ImageData: a,
                                            HTMLImageArray: n,
                                            HTMLVideo: m
                                        },
                                        static: {
                                            Boolean: u,
                                            Float: p,
                                            Integer: d,
                                            Array: C,
                                            "Array(2)": R,
                                            "Array(3)": G,
                                            "Array(4)": U,
                                            "Array1D(2)": x,
                                            "Array1D(3)": x,
                                            "Array1D(4)": x,
                                            "Array2D(2)": I,
                                            "Array2D(3)": I,
                                            "Array2D(4)": I,
                                            "Array3D(2)": P,
                                            "Array3D(3)": P,
                                            "Array3D(4)": P,
                                            Input: b,
                                            NumberTexture: _,
                                            "ArrayTexture(1)": _,
                                            "ArrayTexture(2)": _,
                                            "ArrayTexture(3)": _,
                                            "ArrayTexture(4)": _,
                                            MemoryOptimizedNumberTexture: y,
                                            HTMLCanvas: l,
                                            OffscreenCanvas: l,
                                            HTMLImage: l,
                                            ImageBitmap: l,
                                            ImageData: l,
                                            HTMLImageArray: o,
                                            HTMLVideo: r
                                        }
                                    }
                                };
                                function st(rt, mt, tt, et) {
                                    if (!rt) throw new Error("type missing");
                                    if (!mt) throw new Error("dynamic missing");
                                    if (!tt) throw new Error("precision missing");
                                    et.type && (rt = et.type);
                                    const J = B[tt][mt];
                                    if (J[rt] === !1) return null;
                                    if (J[rt] === void 0) throw new Error(`Could not find a KernelValue for ${rt}`);
                                    return J[rt];
                                }
                                i.exports = {
                                    kernelValueMaps: B,
                                    lookupKernelValueType: st
                                };
                            },
                            {
                                "./kernel-value/array2": 75,
                                "./kernel-value/array3": 76,
                                "./kernel-value/array4": 77,
                                "./kernel-value/boolean": 78,
                                "./kernel-value/dynamic-html-image": 80,
                                "./kernel-value/dynamic-html-image-array": 79,
                                "./kernel-value/dynamic-html-video": 81,
                                "./kernel-value/dynamic-memory-optimized-number-texture": 82,
                                "./kernel-value/dynamic-number-texture": 83,
                                "./kernel-value/dynamic-single-array": 84,
                                "./kernel-value/dynamic-single-array1d-i": 85,
                                "./kernel-value/dynamic-single-array2d-i": 86,
                                "./kernel-value/dynamic-single-array3d-i": 87,
                                "./kernel-value/dynamic-single-input": 88,
                                "./kernel-value/dynamic-unsigned-array": 89,
                                "./kernel-value/dynamic-unsigned-input": 90,
                                "./kernel-value/float": 91,
                                "./kernel-value/html-image": 93,
                                "./kernel-value/html-image-array": 92,
                                "./kernel-value/html-video": 94,
                                "./kernel-value/integer": 95,
                                "./kernel-value/memory-optimized-number-texture": 96,
                                "./kernel-value/number-texture": 97,
                                "./kernel-value/single-array": 98,
                                "./kernel-value/single-array1d-i": 99,
                                "./kernel-value/single-array2d-i": 100,
                                "./kernel-value/single-array3d-i": 101,
                                "./kernel-value/single-input": 102,
                                "./kernel-value/unsigned-array": 103,
                                "./kernel-value/unsigned-input": 104
                            }
                        ],
                        75: [
                            function(e, i, h) {
                                const { WebGLKernelValueArray2: u } = e("../../web-gl/kernel-value/array2");
                                class p extends u {
                                }
                                i.exports = {
                                    WebGL2KernelValueArray2: p
                                };
                            },
                            {
                                "../../web-gl/kernel-value/array2": 41
                            }
                        ],
                        76: [
                            function(e, i, h) {
                                const { WebGLKernelValueArray3: u } = e("../../web-gl/kernel-value/array3");
                                class p extends u {
                                }
                                i.exports = {
                                    WebGL2KernelValueArray3: p
                                };
                            },
                            {
                                "../../web-gl/kernel-value/array3": 42
                            }
                        ],
                        77: [
                            function(e, i, h) {
                                const { WebGLKernelValueArray4: u } = e("../../web-gl/kernel-value/array4");
                                class p extends u {
                                }
                                i.exports = {
                                    WebGL2KernelValueArray4: p
                                };
                            },
                            {
                                "../../web-gl/kernel-value/array4": 43
                            }
                        ],
                        78: [
                            function(e, i, h) {
                                const { WebGLKernelValueBoolean: u } = e("../../web-gl/kernel-value/boolean");
                                class p extends u {
                                }
                                i.exports = {
                                    WebGL2KernelValueBoolean: p
                                };
                            },
                            {
                                "../../web-gl/kernel-value/boolean": 44
                            }
                        ],
                        79: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGL2KernelValueHTMLImageArray: p } = e("./html-image-array");
                                class d extends p {
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2DArray ${this.id}`,
                                            `uniform ${a} ivec2 ${this.sizeId}`,
                                            `uniform ${a} ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        const { width: o, height: n } = a[0];
                                        this.checkSize(o, n), this.dimensions = [
                                            o,
                                            n,
                                            a.length
                                        ], this.textureSize = [
                                            o,
                                            n
                                        ], this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueDynamicHTMLImageArray: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./html-image-array": 92
                            }
                        ],
                        80: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueDynamicHTMLImage: p } = e("../../web-gl/kernel-value/dynamic-html-image");
                                class d extends p {
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2D ${this.id}`,
                                            `uniform ${a} ivec2 ${this.sizeId}`,
                                            `uniform ${a} ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueDynamicHTMLImage: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/dynamic-html-image": 45
                            }
                        ],
                        81: [
                            function(e, i, h) {
                                e("../../../utils");
                                const { WebGL2KernelValueDynamicHTMLImage: u } = e("./dynamic-html-image");
                                class p extends u {
                                }
                                i.exports = {
                                    WebGL2KernelValueDynamicHTMLVideo: p
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./dynamic-html-image": 80
                            }
                        ],
                        82: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueDynamicMemoryOptimizedNumberTexture: p } = e("../../web-gl/kernel-value/dynamic-memory-optimized-number-texture");
                                class d extends p {
                                    getSource() {
                                        return u.linesToString([
                                            `uniform sampler2D ${this.id}`,
                                            `uniform ivec2 ${this.sizeId}`,
                                            `uniform ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueDynamicMemoryOptimizedNumberTexture: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/dynamic-memory-optimized-number-texture": 47
                            }
                        ],
                        83: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueDynamicNumberTexture: p } = e("../../web-gl/kernel-value/dynamic-number-texture");
                                class d extends p {
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2D ${this.id}`,
                                            `uniform ${a} ivec2 ${this.sizeId}`,
                                            `uniform ${a} ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueDynamicNumberTexture: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/dynamic-number-texture": 48
                            }
                        ],
                        84: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGL2KernelValueSingleArray: p } = e("../../web-gl2/kernel-value/single-array");
                                class d extends p {
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2D ${this.id}`,
                                            `uniform ${a} ivec2 ${this.sizeId}`,
                                            `uniform ${a} ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        this.dimensions = u.getDimensions(a, !0), this.textureSize = u.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueDynamicSingleArray: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl2/kernel-value/single-array": 98
                            }
                        ],
                        85: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGL2KernelValueSingleArray1DI: p } = e("../../web-gl2/kernel-value/single-array1d-i");
                                class d extends p {
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2D ${this.id}`,
                                            `uniform ${a} ivec2 ${this.sizeId}`,
                                            `uniform ${a} ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        this.setShape(a), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueDynamicSingleArray1DI: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl2/kernel-value/single-array1d-i": 99
                            }
                        ],
                        86: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGL2KernelValueSingleArray2DI: p } = e("../../web-gl2/kernel-value/single-array2d-i");
                                class d extends p {
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2D ${this.id}`,
                                            `uniform ${a} ivec2 ${this.sizeId}`,
                                            `uniform ${a} ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        this.setShape(a), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueDynamicSingleArray2DI: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl2/kernel-value/single-array2d-i": 100
                            }
                        ],
                        87: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGL2KernelValueSingleArray3DI: p } = e("../../web-gl2/kernel-value/single-array3d-i");
                                class d extends p {
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2D ${this.id}`,
                                            `uniform ${a} ivec2 ${this.sizeId}`,
                                            `uniform ${a} ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        this.setShape(a), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueDynamicSingleArray3DI: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl2/kernel-value/single-array3d-i": 101
                            }
                        ],
                        88: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGL2KernelValueSingleInput: p } = e("../../web-gl2/kernel-value/single-input");
                                class d extends p {
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2D ${this.id}`,
                                            `uniform ${a} ivec2 ${this.sizeId}`,
                                            `uniform ${a} ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                    updateValue(a) {
                                        let [o, n, r] = a.size;
                                        this.dimensions = new Int32Array([
                                            o || 1,
                                            n || 1,
                                            r || 1
                                        ]), this.textureSize = u.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio), this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio, this.checkSize(this.textureSize[0], this.textureSize[1]), this.uploadValue = new Float32Array(this.uploadArrayLength), this.kernel.setUniform3iv(this.dimensionsId, this.dimensions), this.kernel.setUniform2iv(this.sizeId, this.textureSize), super.updateValue(a);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueDynamicSingleInput: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl2/kernel-value/single-input": 102
                            }
                        ],
                        89: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueDynamicUnsignedArray: p } = e("../../web-gl/kernel-value/dynamic-unsigned-array");
                                class d extends p {
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2D ${this.id}`,
                                            `uniform ${a} ivec2 ${this.sizeId}`,
                                            `uniform ${a} ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueDynamicUnsignedArray: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/dynamic-unsigned-array": 54
                            }
                        ],
                        90: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueDynamicUnsignedInput: p } = e("../../web-gl/kernel-value/dynamic-unsigned-input");
                                class d extends p {
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2D ${this.id}`,
                                            `uniform ${a} ivec2 ${this.sizeId}`,
                                            `uniform ${a} ivec3 ${this.dimensionsId}`
                                        ]);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueDynamicUnsignedInput: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/dynamic-unsigned-input": 55
                            }
                        ],
                        91: [
                            function(e, i, h) {
                                e("../../../utils");
                                const { WebGLKernelValueFloat: u } = e("../../web-gl/kernel-value/float");
                                class p extends u {
                                }
                                i.exports = {
                                    WebGL2KernelValueFloat: p
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/float": 56
                            }
                        ],
                        92: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelArray: p } = e("../../web-gl/kernel-value/array");
                                class d extends p {
                                    constructor(a, o){
                                        super(a, o), this.checkSize(a[0].width, a[0].height), this.dimensions = [
                                            a[0].width,
                                            a[0].height,
                                            a.length
                                        ], this.textureSize = [
                                            a[0].width,
                                            a[0].height
                                        ];
                                    }
                                    defineTexture() {
                                        const { context: a } = this;
                                        a.activeTexture(this.contextHandle), a.bindTexture(a.TEXTURE_2D_ARRAY, this.texture), a.texParameteri(a.TEXTURE_2D_ARRAY, a.TEXTURE_MAG_FILTER, a.NEAREST), a.texParameteri(a.TEXTURE_2D_ARRAY, a.TEXTURE_MIN_FILTER, a.NEAREST);
                                    }
                                    getStringValueHandler() {
                                        return `const uploadValue_${this.name} = ${this.varName};
`;
                                    }
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2DArray ${this.id}`,
                                            `${a} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `${a} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                    updateValue(a) {
                                        const { context: o } = this;
                                        o.activeTexture(this.contextHandle), o.bindTexture(o.TEXTURE_2D_ARRAY, this.texture), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !0), o.texImage3D(o.TEXTURE_2D_ARRAY, 0, o.RGBA, a[0].width, a[0].height, a.length, 0, o.RGBA, o.UNSIGNED_BYTE, null);
                                        for(let n = 0; n < a.length; n++)o.texSubImage3D(o.TEXTURE_2D_ARRAY, 0, 0, 0, n, a[n].width, a[n].height, 1, o.RGBA, o.UNSIGNED_BYTE, this.uploadValue = a[n]);
                                        this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueHTMLImageArray: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/array": 40
                            }
                        ],
                        93: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueHTMLImage: p } = e("../../web-gl/kernel-value/html-image");
                                class d extends p {
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2D ${this.id}`,
                                            `${a} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `${a} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueHTMLImage: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/html-image": 57
                            }
                        ],
                        94: [
                            function(e, i, h) {
                                e("../../../utils");
                                const { WebGL2KernelValueHTMLImage: u } = e("./html-image");
                                class p extends u {
                                }
                                i.exports = {
                                    WebGL2KernelValueHTMLVideo: p
                                };
                            },
                            {
                                "../../../utils": 114,
                                "./html-image": 93
                            }
                        ],
                        95: [
                            function(e, i, h) {
                                const { WebGLKernelValueInteger: u } = e("../../web-gl/kernel-value/integer");
                                class p extends u {
                                    getSource(l) {
                                        const a = this.getVariablePrecisionString();
                                        return this.origin === "constants" ? `const ${a} int ${this.id} = ${parseInt(l)};
` : `uniform ${a} int ${this.id};
`;
                                    }
                                    updateValue(l) {
                                        this.origin !== "constants" && this.kernel.setUniform1i(this.id, this.uploadValue = l);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueInteger: p
                                };
                            },
                            {
                                "../../web-gl/kernel-value/integer": 60
                            }
                        ],
                        96: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueMemoryOptimizedNumberTexture: p } = e("../../web-gl/kernel-value/memory-optimized-number-texture");
                                class d extends p {
                                    getSource() {
                                        const { id: a, sizeId: o, textureSize: n, dimensionsId: r, dimensions: m } = this, b = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform sampler2D ${a}`,
                                            `${b} ivec2 ${o} = ivec2(${n[0]}, ${n[1]})`,
                                            `${b} ivec3 ${r} = ivec3(${m[0]}, ${m[1]}, ${m[2]})`
                                        ]);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueMemoryOptimizedNumberTexture: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/memory-optimized-number-texture": 61
                            }
                        ],
                        97: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueNumberTexture: p } = e("../../web-gl/kernel-value/number-texture");
                                class d extends p {
                                    getSource() {
                                        const { id: a, sizeId: o, textureSize: n, dimensionsId: r, dimensions: m } = this, b = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${b} sampler2D ${a}`,
                                            `${b} ivec2 ${o} = ivec2(${n[0]}, ${n[1]})`,
                                            `${b} ivec3 ${r} = ivec3(${m[0]}, ${m[1]}, ${m[2]})`
                                        ]);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueNumberTexture: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/number-texture": 62
                            }
                        ],
                        98: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueSingleArray: p } = e("../../web-gl/kernel-value/single-array");
                                class d extends p {
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2D ${this.id}`,
                                            `${a} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `${a} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                    updateValue(a) {
                                        if (a.constructor !== this.initialValueConstructor) {
                                            this.onUpdateValueMismatch(a.constructor);
                                            return;
                                        }
                                        const { context: o } = this;
                                        u.flattenTo(a, this.uploadValue), o.activeTexture(this.contextHandle), o.bindTexture(o.TEXTURE_2D, this.texture), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !1), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA32F, this.textureSize[0], this.textureSize[1], 0, o.RGBA, o.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueSingleArray: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/single-array": 63
                            }
                        ],
                        99: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueSingleArray1DI: p } = e("../../web-gl/kernel-value/single-array1d-i");
                                class d extends p {
                                    updateValue(a) {
                                        if (a.constructor !== this.initialValueConstructor) {
                                            this.onUpdateValueMismatch(a.constructor);
                                            return;
                                        }
                                        const { context: o } = this;
                                        u.flattenTo(a, this.uploadValue), o.activeTexture(this.contextHandle), o.bindTexture(o.TEXTURE_2D, this.texture), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !1), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA32F, this.textureSize[0], this.textureSize[1], 0, o.RGBA, o.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueSingleArray1DI: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/single-array1d-i": 64
                            }
                        ],
                        100: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueSingleArray2DI: p } = e("../../web-gl/kernel-value/single-array2d-i");
                                class d extends p {
                                    updateValue(a) {
                                        if (a.constructor !== this.initialValueConstructor) {
                                            this.onUpdateValueMismatch(a.constructor);
                                            return;
                                        }
                                        const { context: o } = this;
                                        u.flattenTo(a, this.uploadValue), o.activeTexture(this.contextHandle), o.bindTexture(o.TEXTURE_2D, this.texture), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !1), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA32F, this.textureSize[0], this.textureSize[1], 0, o.RGBA, o.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueSingleArray2DI: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/single-array2d-i": 65
                            }
                        ],
                        101: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueSingleArray3DI: p } = e("../../web-gl/kernel-value/single-array3d-i");
                                class d extends p {
                                    updateValue(a) {
                                        if (a.constructor !== this.initialValueConstructor) {
                                            this.onUpdateValueMismatch(a.constructor);
                                            return;
                                        }
                                        const { context: o } = this;
                                        u.flattenTo(a, this.uploadValue), o.activeTexture(this.contextHandle), o.bindTexture(o.TEXTURE_2D, this.texture), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !1), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA32F, this.textureSize[0], this.textureSize[1], 0, o.RGBA, o.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueSingleArray3DI: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/single-array3d-i": 66
                            }
                        ],
                        102: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueSingleInput: p } = e("../../web-gl/kernel-value/single-input");
                                class d extends p {
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2D ${this.id}`,
                                            `${a} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `${a} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                    updateValue(a) {
                                        const { context: o } = this;
                                        u.flattenTo(a.value, this.uploadValue), o.activeTexture(this.contextHandle), o.bindTexture(o.TEXTURE_2D, this.texture), o.pixelStorei(o.UNPACK_FLIP_Y_WEBGL, !1), o.texImage2D(o.TEXTURE_2D, 0, o.RGBA32F, this.textureSize[0], this.textureSize[1], 0, o.RGBA, o.FLOAT, this.uploadValue), this.kernel.setUniform1i(this.id, this.index);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueSingleInput: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/single-input": 67
                            }
                        ],
                        103: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueUnsignedArray: p } = e("../../web-gl/kernel-value/unsigned-array");
                                class d extends p {
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2D ${this.id}`,
                                            `${a} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `${a} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueUnsignedArray: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/unsigned-array": 68
                            }
                        ],
                        104: [
                            function(e, i, h) {
                                const { utils: u } = e("../../../utils"), { WebGLKernelValueUnsignedInput: p } = e("../../web-gl/kernel-value/unsigned-input");
                                class d extends p {
                                    getSource() {
                                        const a = this.getVariablePrecisionString();
                                        return u.linesToString([
                                            `uniform ${a} sampler2D ${this.id}`,
                                            `${a} ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
                                            `${a} ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`
                                        ]);
                                    }
                                }
                                i.exports = {
                                    WebGL2KernelValueUnsignedInput: d
                                };
                            },
                            {
                                "../../../utils": 114,
                                "../../web-gl/kernel-value/unsigned-input": 69
                            }
                        ],
                        105: [
                            function(e, i, h) {
                                const { WebGLKernel: u } = e("../web-gl/kernel"), { WebGL2FunctionNode: p } = e("./function-node"), { FunctionBuilder: d } = e("../function-builder"), { utils: l } = e("../../utils"), { fragmentShader: a } = e("./fragment-shader"), { vertexShader: o } = e("./vertex-shader"), { lookupKernelValueType: n } = e("./kernel-value-maps");
                                let r = null, m = null, b = null, E = null;
                                class w extends u {
                                    static get isSupported() {
                                        return r !== null || (this.setupFeatureChecks(), r = this.isContextMatch(b)), r;
                                    }
                                    static setupFeatureChecks() {
                                        typeof document < "u" ? m = document.createElement("canvas") : typeof OffscreenCanvas < "u" && (m = new OffscreenCanvas(0, 0)), m && (b = m.getContext("webgl2"), !(!b || !b.getExtension) && (b.getExtension("EXT_color_buffer_float"), b.getExtension("OES_texture_float_linear"), E = this.getFeatures()));
                                    }
                                    static isContextMatch(y) {
                                        return typeof WebGL2RenderingContext < "u" ? y instanceof WebGL2RenderingContext : !1;
                                    }
                                    static getFeatures() {
                                        const y = this.testContext;
                                        return Object.freeze({
                                            isFloatRead: this.getIsFloatRead(),
                                            isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
                                            isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
                                            kernelMap: !0,
                                            isTextureFloat: !0,
                                            isDrawBuffers: !0,
                                            channelCount: this.getChannelCount(),
                                            maxTextureSize: this.getMaxTextureSize(),
                                            lowIntPrecision: y.getShaderPrecisionFormat(y.FRAGMENT_SHADER, y.LOW_INT),
                                            lowFloatPrecision: y.getShaderPrecisionFormat(y.FRAGMENT_SHADER, y.LOW_FLOAT),
                                            mediumIntPrecision: y.getShaderPrecisionFormat(y.FRAGMENT_SHADER, y.MEDIUM_INT),
                                            mediumFloatPrecision: y.getShaderPrecisionFormat(y.FRAGMENT_SHADER, y.MEDIUM_FLOAT),
                                            highIntPrecision: y.getShaderPrecisionFormat(y.FRAGMENT_SHADER, y.HIGH_INT),
                                            highFloatPrecision: y.getShaderPrecisionFormat(y.FRAGMENT_SHADER, y.HIGH_FLOAT)
                                        });
                                    }
                                    static getIsTextureFloat() {
                                        return !0;
                                    }
                                    static getChannelCount() {
                                        return b.getParameter(b.MAX_DRAW_BUFFERS);
                                    }
                                    static getMaxTextureSize() {
                                        return b.getParameter(b.MAX_TEXTURE_SIZE);
                                    }
                                    static lookupKernelValueType(y, T, _, k) {
                                        return n(y, T, _, k);
                                    }
                                    static get testCanvas() {
                                        return m;
                                    }
                                    static get testContext() {
                                        return b;
                                    }
                                    static get features() {
                                        return E;
                                    }
                                    static get fragmentShader() {
                                        return a;
                                    }
                                    static get vertexShader() {
                                        return o;
                                    }
                                    initContext() {
                                        const y = {
                                            alpha: !1,
                                            depth: !1,
                                            antialias: !1
                                        };
                                        return this.canvas.getContext("webgl2", y);
                                    }
                                    initExtensions() {
                                        this.extensions = {
                                            EXT_color_buffer_float: this.context.getExtension("EXT_color_buffer_float"),
                                            OES_texture_float_linear: this.context.getExtension("OES_texture_float_linear")
                                        };
                                    }
                                    validateSettings(y) {
                                        if (!this.validate) {
                                            this.texSize = l.getKernelTextureSize({
                                                optimizeFloatMemory: this.optimizeFloatMemory,
                                                precision: this.precision
                                            }, this.output);
                                            return;
                                        }
                                        const { features: T } = this.constructor;
                                        if (this.precision === "single" && !T.isFloatRead) throw new Error("Float texture outputs are not supported");
                                        if (!this.graphical && this.precision === null && (this.precision = T.isFloatRead ? "single" : "unsigned"), this.fixIntegerDivisionAccuracy === null ? this.fixIntegerDivisionAccuracy = !T.isIntegerDivisionAccurate : this.fixIntegerDivisionAccuracy && T.isIntegerDivisionAccurate && (this.fixIntegerDivisionAccuracy = !1), this.checkOutput(), !this.output || this.output.length === 0) {
                                            if (y.length !== 1) throw new Error("Auto output only supported for kernels with only one input");
                                            const _ = l.getVariableType(y[0], this.strictIntegers);
                                            switch(_){
                                                case "Array":
                                                    this.output = l.getDimensions(_);
                                                    break;
                                                case "NumberTexture":
                                                case "MemoryOptimizedNumberTexture":
                                                case "ArrayTexture(1)":
                                                case "ArrayTexture(2)":
                                                case "ArrayTexture(3)":
                                                case "ArrayTexture(4)":
                                                    this.output = y[0].output;
                                                    break;
                                                default:
                                                    throw new Error("Auto output not supported for input type: " + _);
                                            }
                                        }
                                        if (this.graphical) {
                                            if (this.output.length !== 2) throw new Error("Output must have 2 dimensions on graphical mode");
                                            this.precision === "single" && (console.warn("Cannot use graphical mode and single precision at the same time"), this.precision = "unsigned"), this.texSize = l.clone(this.output);
                                            return;
                                        } else !this.graphical && this.precision === null && T.isTextureFloat && (this.precision = "single");
                                        this.texSize = l.getKernelTextureSize({
                                            optimizeFloatMemory: this.optimizeFloatMemory,
                                            precision: this.precision
                                        }, this.output), this.checkTextureSize();
                                    }
                                    translateSource() {
                                        const y = d.fromKernel(this, p, {
                                            fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
                                        });
                                        this.translatedSource = y.getPrototypeString("kernel"), this.setupReturnTypes(y);
                                    }
                                    drawBuffers() {
                                        this.context.drawBuffers(this.drawBuffersMap);
                                    }
                                    getTextureFormat() {
                                        const { context: y } = this;
                                        switch(this.getInternalFormat()){
                                            case y.R32F:
                                                return y.RED;
                                            case y.RG32F:
                                                return y.RG;
                                            case y.RGBA32F:
                                                return y.RGBA;
                                            case y.RGBA:
                                                return y.RGBA;
                                            default:
                                                throw new Error("Unknown internal format");
                                        }
                                    }
                                    getInternalFormat() {
                                        const { context: y } = this;
                                        if (this.precision === "single") {
                                            if (this.pipeline) switch(this.returnType){
                                                case "Number":
                                                case "Float":
                                                case "Integer":
                                                    return this.optimizeFloatMemory ? y.RGBA32F : y.R32F;
                                                case "Array(2)":
                                                    return y.RG32F;
                                                case "Array(3)":
                                                case "Array(4)":
                                                    return y.RGBA32F;
                                                default:
                                                    throw new Error("Unhandled return type");
                                            }
                                            return y.RGBA32F;
                                        }
                                        return y.RGBA;
                                    }
                                    _setupOutputTexture() {
                                        const y = this.context;
                                        if (this.texture) {
                                            y.framebufferTexture2D(y.FRAMEBUFFER, y.COLOR_ATTACHMENT0, y.TEXTURE_2D, this.texture.texture, 0);
                                            return;
                                        }
                                        y.bindFramebuffer(y.FRAMEBUFFER, this.framebuffer);
                                        const T = y.createTexture(), _ = this.texSize;
                                        y.activeTexture(y.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount), y.bindTexture(y.TEXTURE_2D, T), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_S, y.REPEAT), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_T, y.REPEAT), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MIN_FILTER, y.NEAREST), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MAG_FILTER, y.NEAREST);
                                        const k = this.getInternalFormat();
                                        this.precision === "single" ? y.texStorage2D(y.TEXTURE_2D, 1, k, _[0], _[1]) : y.texImage2D(y.TEXTURE_2D, 0, k, _[0], _[1], 0, k, y.UNSIGNED_BYTE, null), y.framebufferTexture2D(y.FRAMEBUFFER, y.COLOR_ATTACHMENT0, y.TEXTURE_2D, T, 0), this.texture = new this.TextureConstructor({
                                            texture: T,
                                            size: _,
                                            dimensions: this.threadDim,
                                            output: this.output,
                                            context: this.context,
                                            internalFormat: this.getInternalFormat(),
                                            textureFormat: this.getTextureFormat(),
                                            kernel: this
                                        });
                                    }
                                    _setupSubOutputTextures() {
                                        const y = this.context;
                                        if (this.mappedTextures) {
                                            for(let _ = 0; _ < this.subKernels.length; _++)y.framebufferTexture2D(y.FRAMEBUFFER, y.COLOR_ATTACHMENT0 + _ + 1, y.TEXTURE_2D, this.mappedTextures[_].texture, 0);
                                            return;
                                        }
                                        const T = this.texSize;
                                        this.drawBuffersMap = [
                                            y.COLOR_ATTACHMENT0
                                        ], this.mappedTextures = [];
                                        for(let _ = 0; _ < this.subKernels.length; _++){
                                            const k = this.createTexture();
                                            this.drawBuffersMap.push(y.COLOR_ATTACHMENT0 + _ + 1), y.activeTexture(y.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + _), y.bindTexture(y.TEXTURE_2D, k), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_S, y.CLAMP_TO_EDGE), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_T, y.CLAMP_TO_EDGE), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MIN_FILTER, y.NEAREST), y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MAG_FILTER, y.NEAREST);
                                            const C = this.getInternalFormat();
                                            this.precision === "single" ? y.texStorage2D(y.TEXTURE_2D, 1, C, T[0], T[1]) : y.texImage2D(y.TEXTURE_2D, 0, y.RGBA, T[0], T[1], 0, y.RGBA, y.UNSIGNED_BYTE, null), y.framebufferTexture2D(y.FRAMEBUFFER, y.COLOR_ATTACHMENT0 + _ + 1, y.TEXTURE_2D, k, 0), this.mappedTextures.push(new this.TextureConstructor({
                                                texture: k,
                                                size: T,
                                                dimensions: this.threadDim,
                                                output: this.output,
                                                context: this.context,
                                                internalFormat: this.getInternalFormat(),
                                                textureFormat: this.getTextureFormat(),
                                                kernel: this
                                            }));
                                        }
                                    }
                                    _getHeaderString() {
                                        return "";
                                    }
                                    _getTextureCoordinate() {
                                        const y = this.subKernels, T = this.getVariablePrecisionString(this.texSize, this.tactic);
                                        return y === null || y.length < 1 ? `in ${T} vec2 vTexCoord;
` : `out ${T} vec2 vTexCoord;
`;
                                    }
                                    _getMainArgumentsString(y) {
                                        const T = [], _ = this.argumentNames;
                                        for(let k = 0; k < _.length; k++)T.push(this.kernelArguments[k].getSource(y[k]));
                                        return T.join("");
                                    }
                                    getKernelString() {
                                        const y = [
                                            this.getKernelResultDeclaration()
                                        ], T = this.subKernels;
                                        if (T !== null) switch(y.push("layout(location = 0) out vec4 data0"), this.returnType){
                                            case "Number":
                                            case "Float":
                                            case "Integer":
                                                for(let _ = 0; _ < T.length; _++){
                                                    const k = T[_];
                                                    y.push(k.returnType === "Integer" ? `int subKernelResult_${k.name} = 0` : `float subKernelResult_${k.name} = 0.0`, `layout(location = ${_ + 1}) out vec4 data${_ + 1}`);
                                                }
                                                break;
                                            case "Array(2)":
                                                for(let _ = 0; _ < T.length; _++)y.push(`vec2 subKernelResult_${T[_].name}`, `layout(location = ${_ + 1}) out vec4 data${_ + 1}`);
                                                break;
                                            case "Array(3)":
                                                for(let _ = 0; _ < T.length; _++)y.push(`vec3 subKernelResult_${T[_].name}`, `layout(location = ${_ + 1}) out vec4 data${_ + 1}`);
                                                break;
                                            case "Array(4)":
                                                for(let _ = 0; _ < T.length; _++)y.push(`vec4 subKernelResult_${T[_].name}`, `layout(location = ${_ + 1}) out vec4 data${_ + 1}`);
                                                break;
                                        }
                                        else y.push("out vec4 data0");
                                        return l.linesToString(y) + this.translatedSource;
                                    }
                                    getMainResultGraphical() {
                                        return l.linesToString([
                                            "  threadId = indexTo3D(index, uOutputDim)",
                                            "  kernel()",
                                            "  data0 = actualColor"
                                        ]);
                                    }
                                    getMainResultPackedPixels() {
                                        switch(this.returnType){
                                            case "LiteralInteger":
                                            case "Number":
                                            case "Integer":
                                            case "Float":
                                                return this.getMainResultKernelPackedPixels() + this.getMainResultSubKernelPackedPixels();
                                            default:
                                                throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
                                        }
                                    }
                                    getMainResultKernelPackedPixels() {
                                        return l.linesToString([
                                            "  threadId = indexTo3D(index, uOutputDim)",
                                            "  kernel()",
                                            `  data0 = ${this.useLegacyEncoder ? "legacyEncode32" : "encode32"}(kernelResult)`
                                        ]);
                                    }
                                    getMainResultSubKernelPackedPixels() {
                                        const y = [];
                                        if (!this.subKernels) return "";
                                        for(let T = 0; T < this.subKernels.length; T++)this.subKernels[T].returnType === "Integer" ? y.push(`  data${T + 1} = ${this.useLegacyEncoder ? "legacyEncode32" : "encode32"}(float(subKernelResult_${this.subKernels[T].name}))`) : y.push(`  data${T + 1} = ${this.useLegacyEncoder ? "legacyEncode32" : "encode32"}(subKernelResult_${this.subKernels[T].name})`);
                                        return l.linesToString(y);
                                    }
                                    getMainResultKernelMemoryOptimizedFloats(y, T) {
                                        y.push("  threadId = indexTo3D(index, uOutputDim)", "  kernel()", `  data0.${T} = kernelResult`);
                                    }
                                    getMainResultSubKernelMemoryOptimizedFloats(y, T) {
                                        if (!this.subKernels) return y;
                                        for(let _ = 0; _ < this.subKernels.length; _++){
                                            const k = this.subKernels[_];
                                            k.returnType === "Integer" ? y.push(`  data${_ + 1}.${T} = float(subKernelResult_${k.name})`) : y.push(`  data${_ + 1}.${T} = subKernelResult_${k.name}`);
                                        }
                                    }
                                    getMainResultKernelNumberTexture() {
                                        return [
                                            "  threadId = indexTo3D(index, uOutputDim)",
                                            "  kernel()",
                                            "  data0[0] = kernelResult"
                                        ];
                                    }
                                    getMainResultSubKernelNumberTexture() {
                                        const y = [];
                                        if (!this.subKernels) return y;
                                        for(let T = 0; T < this.subKernels.length; ++T){
                                            const _ = this.subKernels[T];
                                            _.returnType === "Integer" ? y.push(`  data${T + 1}[0] = float(subKernelResult_${_.name})`) : y.push(`  data${T + 1}[0] = subKernelResult_${_.name}`);
                                        }
                                        return y;
                                    }
                                    getMainResultKernelArray2Texture() {
                                        return [
                                            "  threadId = indexTo3D(index, uOutputDim)",
                                            "  kernel()",
                                            "  data0[0] = kernelResult[0]",
                                            "  data0[1] = kernelResult[1]"
                                        ];
                                    }
                                    getMainResultSubKernelArray2Texture() {
                                        const y = [];
                                        if (!this.subKernels) return y;
                                        for(let T = 0; T < this.subKernels.length; ++T){
                                            const _ = this.subKernels[T];
                                            y.push(`  data${T + 1}[0] = subKernelResult_${_.name}[0]`, `  data${T + 1}[1] = subKernelResult_${_.name}[1]`);
                                        }
                                        return y;
                                    }
                                    getMainResultKernelArray3Texture() {
                                        return [
                                            "  threadId = indexTo3D(index, uOutputDim)",
                                            "  kernel()",
                                            "  data0[0] = kernelResult[0]",
                                            "  data0[1] = kernelResult[1]",
                                            "  data0[2] = kernelResult[2]"
                                        ];
                                    }
                                    getMainResultSubKernelArray3Texture() {
                                        const y = [];
                                        if (!this.subKernels) return y;
                                        for(let T = 0; T < this.subKernels.length; ++T){
                                            const _ = this.subKernels[T];
                                            y.push(`  data${T + 1}[0] = subKernelResult_${_.name}[0]`, `  data${T + 1}[1] = subKernelResult_${_.name}[1]`, `  data${T + 1}[2] = subKernelResult_${_.name}[2]`);
                                        }
                                        return y;
                                    }
                                    getMainResultKernelArray4Texture() {
                                        return [
                                            "  threadId = indexTo3D(index, uOutputDim)",
                                            "  kernel()",
                                            "  data0 = kernelResult"
                                        ];
                                    }
                                    getMainResultSubKernelArray4Texture() {
                                        const y = [];
                                        if (!this.subKernels) return y;
                                        for(let T = 0; T < this.subKernels.length; ++T)y.push(`  data${T + 1} = subKernelResult_${this.subKernels[T].name}`);
                                        return y;
                                    }
                                    destroyExtensions() {
                                        this.extensions.EXT_color_buffer_float = null, this.extensions.OES_texture_float_linear = null;
                                    }
                                    toJSON() {
                                        const y = super.toJSON();
                                        return y.functionNodes = d.fromKernel(this, p).toJSON(), y.settings.threadDim = this.threadDim, y;
                                    }
                                }
                                i.exports = {
                                    WebGL2Kernel: w
                                };
                            },
                            {
                                "../../utils": 114,
                                "../function-builder": 9,
                                "../web-gl/kernel": 70,
                                "./fragment-shader": 72,
                                "./function-node": 73,
                                "./kernel-value-maps": 74,
                                "./vertex-shader": 106
                            }
                        ],
                        106: [
                            function(e, i, h) {
                                const u = `#version 300 es
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

in vec2 aPos;
in vec2 aTexCoord;

out vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;
                                i.exports = {
                                    vertexShader: u
                                };
                            },
                            {}
                        ],
                        107: [
                            function(e, i, h) {
                                const u = e("./index"), p = u.GPU;
                                for(const l in u)u.hasOwnProperty(l) && l !== "GPU" && (p[l] = u[l]);
                                typeof window < "u" && d(window), typeof self < "u" && d(self);
                                function d(l) {
                                    l.GPU || Object.defineProperty(l, "GPU", {
                                        get () {
                                            return p;
                                        }
                                    });
                                }
                                i.exports = u;
                            },
                            {
                                "./index": 109
                            }
                        ],
                        108: [
                            function(e, i, h) {
                                const { gpuMock: u } = e("gpu-mock.js"), { utils: p } = e("./utils");
                                e("./backend/kernel");
                                const { CPUKernel: d } = e("./backend/cpu/kernel"), { HeadlessGLKernel: l } = e("./backend/headless-gl/kernel"), { WebGL2Kernel: a } = e("./backend/web-gl2/kernel"), { WebGLKernel: o } = e("./backend/web-gl/kernel"), { kernelRunShortcut: n } = e("./kernel-run-shortcut"), r = [
                                    l,
                                    a,
                                    o
                                ], m = [
                                    "gpu",
                                    "cpu"
                                ], b = {
                                    headlessgl: l,
                                    webgl2: a,
                                    webgl: o
                                };
                                let E = !0;
                                class w {
                                    static disableValidation() {
                                        E = !1;
                                    }
                                    static enableValidation() {
                                        E = !0;
                                    }
                                    static get isGPUSupported() {
                                        return r.some((T)=>T.isSupported);
                                    }
                                    static get isKernelMapSupported() {
                                        return r.some((T)=>T.isSupported && T.features.kernelMap);
                                    }
                                    static get isOffscreenCanvasSupported() {
                                        return typeof Worker < "u" && typeof OffscreenCanvas < "u" || typeof importScripts < "u";
                                    }
                                    static get isWebGLSupported() {
                                        return o.isSupported;
                                    }
                                    static get isWebGL2Supported() {
                                        return a.isSupported;
                                    }
                                    static get isHeadlessGLSupported() {
                                        return l.isSupported;
                                    }
                                    static get isCanvasSupported() {
                                        return typeof HTMLCanvasElement < "u";
                                    }
                                    static get isGPUHTMLImageArraySupported() {
                                        return a.isSupported;
                                    }
                                    static get isSinglePrecisionSupported() {
                                        return r.some((T)=>T.isSupported && T.features.isFloatRead && T.features.isTextureFloat);
                                    }
                                    constructor(T){
                                        if (T = T || {}, this.canvas = T.canvas || null, this.context = T.context || null, this.mode = T.mode, this.Kernel = null, this.kernels = [], this.functions = [], this.nativeFunctions = [], this.injectedNative = null, this.mode !== "dev") {
                                            if (this.chooseKernel(), T.functions) for(let _ = 0; _ < T.functions.length; _++)this.addFunction(T.functions[_]);
                                            if (T.nativeFunctions) for(const _ in T.nativeFunctions){
                                                if (!T.nativeFunctions.hasOwnProperty(_)) continue;
                                                const k = T.nativeFunctions[_], { name: C, source: M } = k;
                                                this.addNativeFunction(C, M, k);
                                            }
                                        }
                                    }
                                    chooseKernel() {
                                        if (this.Kernel) return;
                                        let T = null;
                                        if (this.context) {
                                            for(let _ = 0; _ < r.length; _++){
                                                const k = r[_];
                                                if (k.isContextMatch(this.context)) {
                                                    if (!k.isSupported) throw new Error(`Kernel type ${k.name} not supported`);
                                                    T = k;
                                                    break;
                                                }
                                            }
                                            if (T === null) throw new Error("unknown Context");
                                        } else if (this.mode) {
                                            if (this.mode in b) (!E || b[this.mode].isSupported) && (T = b[this.mode]);
                                            else if (this.mode === "gpu") {
                                                for(let _ = 0; _ < r.length; _++)if (r[_].isSupported) {
                                                    T = r[_];
                                                    break;
                                                }
                                            } else this.mode === "cpu" && (T = d);
                                            if (!T) throw new Error(`A requested mode of "${this.mode}" and is not supported`);
                                        } else {
                                            for(let _ = 0; _ < r.length; _++)if (r[_].isSupported) {
                                                T = r[_];
                                                break;
                                            }
                                            T || (T = d);
                                        }
                                        this.mode || (this.mode = T.mode), this.Kernel = T;
                                    }
                                    createKernel(T, _) {
                                        if (typeof T > "u") throw new Error("Missing source parameter");
                                        if (typeof T != "object" && !p.isFunction(T) && typeof T != "string") throw new Error("source parameter not a function");
                                        const k = this.kernels;
                                        if (this.mode === "dev") {
                                            const O = u(T, v(_));
                                            return k.push(O), O;
                                        }
                                        T = typeof T == "function" ? T.toString() : T;
                                        const C = {}, M = v(_) || {};
                                        _ && typeof _.argumentTypes == "object" && (M.argumentTypes = Object.keys(_.argumentTypes).map((O)=>_.argumentTypes[O]));
                                        function x(O) {
                                            console.warn("Falling back to CPU");
                                            const R = new d(T, {
                                                argumentTypes: P.argumentTypes,
                                                constantTypes: P.constantTypes,
                                                graphical: P.graphical,
                                                loopMaxIterations: P.loopMaxIterations,
                                                constants: P.constants,
                                                dynamicOutput: P.dynamicOutput,
                                                dynamicArgument: P.dynamicArguments,
                                                output: P.output,
                                                precision: P.precision,
                                                pipeline: P.pipeline,
                                                immutable: P.immutable,
                                                optimizeFloatMemory: P.optimizeFloatMemory,
                                                fixIntegerDivisionAccuracy: P.fixIntegerDivisionAccuracy,
                                                functions: P.functions,
                                                nativeFunctions: P.nativeFunctions,
                                                injectedNative: P.injectedNative,
                                                subKernels: P.subKernels,
                                                strictIntegers: P.strictIntegers,
                                                debug: P.debug
                                            });
                                            R.build.apply(R, O);
                                            const G = R.run.apply(R, O);
                                            return P.replaceKernel(R), G;
                                        }
                                        function g(O, R, G) {
                                            G.debug && console.warn("Switching kernels");
                                            let U = null;
                                            if (G.signature && !C[G.signature] && (C[G.signature] = G), G.dynamicOutput) for(let mt = O.length - 1; mt >= 0; mt--){
                                                const tt = O[mt];
                                                tt.type === "outputPrecisionMismatch" && (U = tt.needed);
                                            }
                                            const it = G.constructor, q = it.getArgumentTypes(G, R), B = it.getSignature(G, q), st = C[B];
                                            if (st) return st.onActivate(G), st;
                                            const rt = C[B] = new it(T, {
                                                argumentTypes: q,
                                                constantTypes: G.constantTypes,
                                                graphical: G.graphical,
                                                loopMaxIterations: G.loopMaxIterations,
                                                constants: G.constants,
                                                dynamicOutput: G.dynamicOutput,
                                                dynamicArgument: G.dynamicArguments,
                                                context: G.context,
                                                canvas: G.canvas,
                                                output: U || G.output,
                                                precision: G.precision,
                                                pipeline: G.pipeline,
                                                immutable: G.immutable,
                                                optimizeFloatMemory: G.optimizeFloatMemory,
                                                fixIntegerDivisionAccuracy: G.fixIntegerDivisionAccuracy,
                                                functions: G.functions,
                                                nativeFunctions: G.nativeFunctions,
                                                injectedNative: G.injectedNative,
                                                subKernels: G.subKernels,
                                                strictIntegers: G.strictIntegers,
                                                debug: G.debug,
                                                gpu: G.gpu,
                                                validate: E,
                                                returnType: G.returnType,
                                                tactic: G.tactic,
                                                onRequestFallback: x,
                                                onRequestSwitchKernel: g,
                                                texture: G.texture,
                                                mappedTextures: G.mappedTextures,
                                                drawBuffersMap: G.drawBuffersMap
                                            });
                                            return rt.build.apply(rt, R), P.replaceKernel(rt), k.push(rt), rt;
                                        }
                                        const I = Object.assign({
                                            context: this.context,
                                            canvas: this.canvas,
                                            functions: this.functions,
                                            nativeFunctions: this.nativeFunctions,
                                            injectedNative: this.injectedNative,
                                            gpu: this,
                                            validate: E,
                                            onRequestFallback: x,
                                            onRequestSwitchKernel: g
                                        }, M), A = new this.Kernel(T, I), P = n(A);
                                        return this.canvas || (this.canvas = A.canvas), this.context || (this.context = A.context), k.push(A), P;
                                    }
                                    createKernelMap() {
                                        let T, _;
                                        const k = typeof arguments[arguments.length - 2];
                                        if (k === "function" || k === "string" ? (T = arguments[arguments.length - 2], _ = arguments[arguments.length - 1]) : T = arguments[arguments.length - 1], this.mode !== "dev" && (!this.Kernel.isSupported || !this.Kernel.features.kernelMap) && this.mode && m.indexOf(this.mode) < 0) throw new Error(`kernelMap not supported on ${this.Kernel.name}`);
                                        const C = v(_);
                                        if (_ && typeof _.argumentTypes == "object" && (C.argumentTypes = Object.keys(_.argumentTypes).map((M)=>_.argumentTypes[M])), Array.isArray(arguments[0])) {
                                            C.subKernels = [];
                                            const M = arguments[0];
                                            for(let x = 0; x < M.length; x++){
                                                const g = M[x].toString(), I = p.getFunctionNameFromString(g);
                                                C.subKernels.push({
                                                    name: I,
                                                    source: g,
                                                    property: x
                                                });
                                            }
                                        } else {
                                            C.subKernels = [];
                                            const M = arguments[0];
                                            for(let x in M){
                                                if (!M.hasOwnProperty(x)) continue;
                                                const g = M[x].toString(), I = p.getFunctionNameFromString(g);
                                                C.subKernels.push({
                                                    name: I || x,
                                                    source: g,
                                                    property: x
                                                });
                                            }
                                        }
                                        return this.createKernel(T, C);
                                    }
                                    combineKernels() {
                                        const T = arguments[0], _ = arguments[arguments.length - 1];
                                        if (T.kernel.constructor.mode === "cpu") return _;
                                        const k = arguments[0].canvas, C = arguments[0].context, M = arguments.length - 1;
                                        for(let x = 0; x < M; x++)arguments[x].setCanvas(k).setContext(C).setPipeline(!0);
                                        return function() {
                                            const x = _.apply(this, arguments);
                                            return x.toArray ? x.toArray() : x;
                                        };
                                    }
                                    setFunctions(T) {
                                        return this.functions = T, this;
                                    }
                                    setNativeFunctions(T) {
                                        return this.nativeFunctions = T, this;
                                    }
                                    addFunction(T, _) {
                                        return this.functions.push({
                                            source: T,
                                            settings: _
                                        }), this;
                                    }
                                    addNativeFunction(T, _, k) {
                                        if (this.kernels.length > 0) throw new Error('Cannot call "addNativeFunction" after "createKernels" has been called.');
                                        return this.nativeFunctions.push(Object.assign({
                                            name: T,
                                            source: _
                                        }, k)), this;
                                    }
                                    injectNative(T) {
                                        return this.injectedNative = T, this;
                                    }
                                    destroy() {
                                        return new Promise((T, _)=>{
                                            this.kernels || T(), setTimeout(()=>{
                                                try {
                                                    for(let C = 0; C < this.kernels.length; C++)this.kernels[C].destroy(!0);
                                                    let k = this.kernels[0];
                                                    k && (k.kernel && (k = k.kernel), k.constructor.destroyContext && k.constructor.destroyContext(this.context));
                                                } catch (k) {
                                                    _(k);
                                                }
                                                T();
                                            }, 0);
                                        });
                                    }
                                }
                                function v(y) {
                                    if (!y) return {};
                                    const T = Object.assign({}, y);
                                    return y.hasOwnProperty("floatOutput") && (p.warnDeprecated("setting", "floatOutput", "precision"), T.precision = y.floatOutput ? "single" : "unsigned"), y.hasOwnProperty("outputToTexture") && (p.warnDeprecated("setting", "outputToTexture", "pipeline"), T.pipeline = !!y.outputToTexture), y.hasOwnProperty("outputImmutable") && (p.warnDeprecated("setting", "outputImmutable", "immutable"), T.immutable = !!y.outputImmutable), y.hasOwnProperty("floatTextures") && (p.warnDeprecated("setting", "floatTextures", "optimizeFloatMemory"), T.optimizeFloatMemory = !!y.floatTextures), T;
                                }
                                i.exports = {
                                    GPU: w,
                                    kernelOrder: r,
                                    kernelTypes: m
                                };
                            },
                            {
                                "./backend/cpu/kernel": 8,
                                "./backend/headless-gl/kernel": 34,
                                "./backend/kernel": 36,
                                "./backend/web-gl/kernel": 70,
                                "./backend/web-gl2/kernel": 105,
                                "./kernel-run-shortcut": 111,
                                "./utils": 114,
                                "gpu-mock.js": 4
                            }
                        ],
                        109: [
                            function(e, i, h) {
                                const { GPU: u } = e("./gpu"), { alias: p } = e("./alias"), { utils: d } = e("./utils"), { Input: l, input: a } = e("./input"), { Texture: o } = e("./texture"), { FunctionBuilder: n } = e("./backend/function-builder"), { FunctionNode: r } = e("./backend/function-node"), { CPUFunctionNode: m } = e("./backend/cpu/function-node"), { CPUKernel: b } = e("./backend/cpu/kernel"), { HeadlessGLKernel: E } = e("./backend/headless-gl/kernel"), { WebGLFunctionNode: w } = e("./backend/web-gl/function-node"), { WebGLKernel: v } = e("./backend/web-gl/kernel"), { kernelValueMaps: y } = e("./backend/web-gl/kernel-value-maps"), { WebGL2FunctionNode: T } = e("./backend/web-gl2/function-node"), { WebGL2Kernel: _ } = e("./backend/web-gl2/kernel"), { kernelValueMaps: k } = e("./backend/web-gl2/kernel-value-maps"), { GLKernel: C } = e("./backend/gl/kernel"), { Kernel: M } = e("./backend/kernel"), { FunctionTracer: x } = e("./backend/function-tracer"), g = e("./plugins/math-random-uniformly-distributed");
                                i.exports = {
                                    alias: p,
                                    CPUFunctionNode: m,
                                    CPUKernel: b,
                                    GPU: u,
                                    FunctionBuilder: n,
                                    FunctionNode: r,
                                    HeadlessGLKernel: E,
                                    Input: l,
                                    input: a,
                                    Texture: o,
                                    utils: d,
                                    WebGL2FunctionNode: T,
                                    WebGL2Kernel: _,
                                    webGL2KernelValueMaps: k,
                                    WebGLFunctionNode: w,
                                    WebGLKernel: v,
                                    webGLKernelValueMaps: y,
                                    GLKernel: C,
                                    Kernel: M,
                                    FunctionTracer: x,
                                    plugins: {
                                        mathRandom: g
                                    }
                                };
                            },
                            {
                                "./alias": 5,
                                "./backend/cpu/function-node": 6,
                                "./backend/cpu/kernel": 8,
                                "./backend/function-builder": 9,
                                "./backend/function-node": 10,
                                "./backend/function-tracer": 11,
                                "./backend/gl/kernel": 13,
                                "./backend/headless-gl/kernel": 34,
                                "./backend/kernel": 36,
                                "./backend/web-gl/function-node": 38,
                                "./backend/web-gl/kernel": 70,
                                "./backend/web-gl/kernel-value-maps": 39,
                                "./backend/web-gl2/function-node": 73,
                                "./backend/web-gl2/kernel": 105,
                                "./backend/web-gl2/kernel-value-maps": 74,
                                "./gpu": 108,
                                "./input": 110,
                                "./plugins/math-random-uniformly-distributed": 112,
                                "./texture": 113,
                                "./utils": 114
                            }
                        ],
                        110: [
                            function(e, i, h) {
                                class u {
                                    constructor(l, a){
                                        this.value = l, Array.isArray(a) ? this.size = a : (this.size = new Int32Array(3), a.z ? this.size = new Int32Array([
                                            a.x,
                                            a.y,
                                            a.z
                                        ]) : a.y ? this.size = new Int32Array([
                                            a.x,
                                            a.y
                                        ]) : this.size = new Int32Array([
                                            a.x
                                        ]));
                                        const [o, n, r] = this.size;
                                        if (r) {
                                            if (this.value.length !== o * n * r) throw new Error(`Input size ${this.value.length} does not match ${o} * ${n} * ${r} = ${n * o * r}`);
                                        } else if (n) {
                                            if (this.value.length !== o * n) throw new Error(`Input size ${this.value.length} does not match ${o} * ${n} = ${n * o}`);
                                        } else if (this.value.length !== o) throw new Error(`Input size ${this.value.length} does not match ${o}`);
                                    }
                                    toArray() {
                                        const { utils: l } = e("./utils"), [a, o, n] = this.size;
                                        return n ? l.erectMemoryOptimized3DFloat(this.value.subarray ? this.value : new Float32Array(this.value), a, o, n) : o ? l.erectMemoryOptimized2DFloat(this.value.subarray ? this.value : new Float32Array(this.value), a, o) : this.value;
                                    }
                                }
                                function p(d, l) {
                                    return new u(d, l);
                                }
                                i.exports = {
                                    Input: u,
                                    input: p
                                };
                            },
                            {
                                "./utils": 114
                            }
                        ],
                        111: [
                            function(e, i, h) {
                                const { utils: u } = e("./utils");
                                function p(l) {
                                    let a = function() {
                                        return l.build.apply(l, arguments), a = function() {
                                            let n = l.run.apply(l, arguments);
                                            if (l.switchingKernels) {
                                                const r = l.resetSwitchingKernels(), m = l.onRequestSwitchKernel(r, arguments, l);
                                                o.kernel = l = m, n = m.run.apply(m, arguments);
                                            }
                                            return l.renderKernels ? l.renderKernels() : l.renderOutput ? l.renderOutput() : n;
                                        }, a.apply(l, arguments);
                                    };
                                    const o = function() {
                                        return a.apply(l, arguments);
                                    };
                                    return o.exec = function() {
                                        return new Promise((n, r)=>{
                                            try {
                                                n(a.apply(this, arguments));
                                            } catch (m) {
                                                r(m);
                                            }
                                        });
                                    }, o.replaceKernel = function(n) {
                                        l = n, d(l, o);
                                    }, d(l, o), o;
                                }
                                function d(l, a) {
                                    if (a.kernel) {
                                        a.kernel = l;
                                        return;
                                    }
                                    const o = u.allPropertiesOf(l);
                                    for(let n = 0; n < o.length; n++){
                                        const r = o[n];
                                        r[0] === "_" && r[1] === "_" || (typeof l[r] == "function" ? r.substring(0, 3) === "add" || r.substring(0, 3) === "set" ? a[r] = function() {
                                            return a.kernel[r].apply(a.kernel, arguments), a;
                                        } : a[r] = function() {
                                            return a.kernel[r].apply(a.kernel, arguments);
                                        } : (a.__defineGetter__(r, ()=>a.kernel[r]), a.__defineSetter__(r, (m)=>{
                                            a.kernel[r] = m;
                                        })));
                                    }
                                    a.kernel = l;
                                }
                                i.exports = {
                                    kernelRunShortcut: p
                                };
                            },
                            {
                                "./utils": 114
                            }
                        ],
                        112: [
                            function(e, i, h) {
                                const n = {
                                    name: "math-random-uniformly-distributed",
                                    onBeforeRun: (r)=>{
                                        r.setUniform1f("randomSeed1", Math.random()), r.setUniform1f("randomSeed2", Math.random());
                                    },
                                    functionMatch: "Math.random()",
                                    functionReplace: "nrand(vTexCoord)",
                                    functionReturnType: "Number",
                                    source: `// https://www.shadertoy.com/view/4t2SDh
//note: uniformly distributed, normalized rand, [0,1]
highp float randomSeedShift = 1.0;
highp float slide = 1.0;
uniform highp float randomSeed1;
uniform highp float randomSeed2;

highp float nrand(highp vec2 n) {
  highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);
  randomSeedShift = result;
  if (randomSeedShift > 0.5) {
    slide += 0.00009; 
  } else {
    slide += 0.0009;
  }
  return result;
}`
                                };
                                i.exports = n;
                            },
                            {}
                        ],
                        113: [
                            function(e, i, h) {
                                class u {
                                    constructor(d){
                                        const { texture: l, size: a, dimensions: o, output: n, context: r, type: m = "NumberTexture", kernel: b, internalFormat: E, textureFormat: w } = d;
                                        if (!n) throw new Error('settings property "output" required.');
                                        if (!r) throw new Error('settings property "context" required.');
                                        if (!l) throw new Error('settings property "texture" required.');
                                        if (!b) throw new Error('settings property "kernel" required.');
                                        this.texture = l, l._refs ? l._refs++ : l._refs = 1, this.size = a, this.dimensions = o, this.output = n, this.context = r, this.kernel = b, this.type = m, this._deleted = !1, this.internalFormat = E, this.textureFormat = w;
                                    }
                                    toArray() {
                                        throw new Error(`Not implemented on ${this.constructor.name}`);
                                    }
                                    clone() {
                                        throw new Error(`Not implemented on ${this.constructor.name}`);
                                    }
                                    delete() {
                                        throw new Error(`Not implemented on ${this.constructor.name}`);
                                    }
                                    clear() {
                                        throw new Error(`Not implemented on ${this.constructor.name}`);
                                    }
                                }
                                i.exports = {
                                    Texture: u
                                };
                            },
                            {}
                        ],
                        114: [
                            function(e, i, h) {
                                const u = e("acorn"), { Input: p } = e("./input"), { Texture: d } = e("./texture"), l = /function ([^(]*)/, a = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg, o = /([^\s,]+)/g, n = {
                                    systemEndianness () {
                                        return E;
                                    },
                                    getSystemEndianness () {
                                        const w = new ArrayBuffer(4), v = new Uint32Array(w), y = new Uint8Array(w);
                                        if (v[0] = 3735928559, y[0] === 239) return "LE";
                                        if (y[0] === 222) return "BE";
                                        throw new Error("unknown endianness");
                                    },
                                    isFunction (w) {
                                        return typeof w == "function";
                                    },
                                    isFunctionString (w) {
                                        return typeof w == "string" ? w.slice(0, 8).toLowerCase() === "function" : !1;
                                    },
                                    getFunctionNameFromString (w) {
                                        const v = l.exec(w);
                                        return !v || v.length === 0 ? null : v[1].trim();
                                    },
                                    getFunctionBodyFromString (w) {
                                        return w.substring(w.indexOf("{") + 1, w.lastIndexOf("}"));
                                    },
                                    getArgumentNamesFromString (w) {
                                        const v = w.replace(a, "");
                                        let y = v.slice(v.indexOf("(") + 1, v.indexOf(")")).match(o);
                                        return y === null && (y = []), y;
                                    },
                                    clone (w) {
                                        if (w === null || typeof w != "object" || w.hasOwnProperty("isActiveClone")) return w;
                                        const v = w.constructor();
                                        for(let y in w)Object.prototype.hasOwnProperty.call(w, y) && (w.isActiveClone = null, v[y] = n.clone(w[y]), delete w.isActiveClone);
                                        return v;
                                    },
                                    isArray (w) {
                                        return !isNaN(w.length);
                                    },
                                    getVariableType (w, v) {
                                        if (n.isArray(w)) return w.length > 0 && w[0].nodeName === "IMG" ? "HTMLImageArray" : "Array";
                                        switch(w.constructor){
                                            case Boolean:
                                                return "Boolean";
                                            case Number:
                                                return v && Number.isInteger(w) ? "Integer" : "Float";
                                            case d:
                                                return w.type;
                                            case p:
                                                return "Input";
                                        }
                                        if ("nodeName" in w) switch(w.nodeName){
                                            case "IMG":
                                                return "HTMLImage";
                                            case "CANVAS":
                                                return "HTMLImage";
                                            case "VIDEO":
                                                return "HTMLVideo";
                                        }
                                        else {
                                            if (w.hasOwnProperty("type")) return w.type;
                                            if (typeof OffscreenCanvas < "u" && w instanceof OffscreenCanvas) return "OffscreenCanvas";
                                            if (typeof ImageBitmap < "u" && w instanceof ImageBitmap) return "ImageBitmap";
                                            if (typeof ImageData < "u" && w instanceof ImageData) return "ImageData";
                                        }
                                        return "Unknown";
                                    },
                                    getKernelTextureSize (w, v) {
                                        let [y, T, _] = v, k = (y || 1) * (T || 1) * (_ || 1);
                                        return w.optimizeFloatMemory && w.precision === "single" && (y = k = Math.ceil(k / 4)), T > 1 && y * T === k ? new Int32Array([
                                            y,
                                            T
                                        ]) : n.closestSquareDimensions(k);
                                    },
                                    closestSquareDimensions (w) {
                                        const v = Math.sqrt(w);
                                        let y = Math.ceil(v), T = Math.floor(v);
                                        for(; y * T < w;)y--, T = Math.ceil(w / y);
                                        return new Int32Array([
                                            T,
                                            Math.ceil(w / T)
                                        ]);
                                    },
                                    getMemoryOptimizedFloatTextureSize (w, v) {
                                        const T = n.roundTo((w[0] || 1) * (w[1] || 1) * (w[2] || 1) * (w[3] || 1), 4) / v;
                                        return n.closestSquareDimensions(T);
                                    },
                                    getMemoryOptimizedPackedTextureSize (w, v) {
                                        const [y, T, _] = w, C = n.roundTo((y || 1) * (T || 1) * (_ || 1), 4) / (4 / v);
                                        return n.closestSquareDimensions(C);
                                    },
                                    roundTo (w, v) {
                                        return Math.floor((w + v - 1) / v) * v;
                                    },
                                    getDimensions (w, v) {
                                        let y;
                                        if (n.isArray(w)) {
                                            const T = [];
                                            let _ = w;
                                            for(; n.isArray(_);)T.push(_.length), _ = _[0];
                                            y = T.reverse();
                                        } else if (w instanceof d) y = w.output;
                                        else if (w instanceof p) y = w.size;
                                        else throw new Error(`Unknown dimensions of ${w}`);
                                        if (v) for(y = Array.from(y); y.length < 3;)y.push(1);
                                        return new Int32Array(y);
                                    },
                                    flatten2dArrayTo (w, v) {
                                        let y = 0;
                                        for(let T = 0; T < w.length; T++)v.set(w[T], y), y += w[T].length;
                                    },
                                    flatten3dArrayTo (w, v) {
                                        let y = 0;
                                        for(let T = 0; T < w.length; T++)for(let _ = 0; _ < w[T].length; _++)v.set(w[T][_], y), y += w[T][_].length;
                                    },
                                    flatten4dArrayTo (w, v) {
                                        let y = 0;
                                        for(let T = 0; T < w.length; T++)for(let _ = 0; _ < w[T].length; _++)for(let k = 0; k < w[T][_].length; k++)v.set(w[T][_][k], y), y += w[T][_][k].length;
                                    },
                                    flattenTo (w, v) {
                                        n.isArray(w[0]) ? n.isArray(w[0][0]) ? n.isArray(w[0][0][0]) ? n.flatten4dArrayTo(w, v) : n.flatten3dArrayTo(w, v) : n.flatten2dArrayTo(w, v) : v.set(w);
                                    },
                                    splitArray (w, v) {
                                        const y = [];
                                        for(let T = 0; T < w.length; T += v)y.push(new w.constructor(w.buffer, T * 4 + w.byteOffset, v));
                                        return y;
                                    },
                                    getAstString (w, v) {
                                        const y = Array.isArray(w) ? w : w.split(/\r?\n/g), T = v.loc.start, _ = v.loc.end, k = [];
                                        if (T.line === _.line) k.push(y[T.line - 1].substring(T.column, _.column));
                                        else {
                                            k.push(y[T.line - 1].slice(T.column));
                                            for(let C = T.line; C < _.line; C++)k.push(y[C]);
                                            k.push(y[_.line - 1].slice(0, _.column));
                                        }
                                        return k.join(`
`);
                                    },
                                    allPropertiesOf (w) {
                                        const v = [];
                                        do v.push.apply(v, Object.getOwnPropertyNames(w));
                                        while (w = Object.getPrototypeOf(w));
                                        return v;
                                    },
                                    linesToString (w) {
                                        return w.length > 0 ? w.join(`;
`) + `;
` : `
`;
                                    },
                                    warnDeprecated (w, v, y) {
                                        console.warn(y ? `You are using a deprecated ${w} "${v}". It has been replaced with "${y}". Fixing, but please upgrade as it will soon be removed.` : `You are using a deprecated ${w} "${v}". It has been removed. Fixing, but please upgrade as it will soon be removed.`);
                                    },
                                    flipPixels: (w, v, y)=>{
                                        const T = y / 2 | 0, _ = v * 4, k = new Uint8ClampedArray(v * 4), C = w.slice(0);
                                        for(let M = 0; M < T; ++M){
                                            const x = M * _, g = (y - M - 1) * _;
                                            k.set(C.subarray(x, x + _)), C.copyWithin(x, g, g + _), C.set(k, g);
                                        }
                                        return C;
                                    },
                                    erectPackedFloat: (w, v)=>w.subarray(0, v),
                                    erect2DPackedFloat: (w, v, y)=>{
                                        const T = new Array(y);
                                        for(let _ = 0; _ < y; _++){
                                            const k = _ * v, C = k + v;
                                            T[_] = w.subarray(k, C);
                                        }
                                        return T;
                                    },
                                    erect3DPackedFloat: (w, v, y, T)=>{
                                        const _ = new Array(T);
                                        for(let k = 0; k < T; k++){
                                            const C = new Array(y);
                                            for(let M = 0; M < y; M++){
                                                const x = k * y * v + M * v, g = x + v;
                                                C[M] = w.subarray(x, g);
                                            }
                                            _[k] = C;
                                        }
                                        return _;
                                    },
                                    erectMemoryOptimizedFloat: (w, v)=>w.subarray(0, v),
                                    erectMemoryOptimized2DFloat: (w, v, y)=>{
                                        const T = new Array(y);
                                        for(let _ = 0; _ < y; _++){
                                            const k = _ * v;
                                            T[_] = w.subarray(k, k + v);
                                        }
                                        return T;
                                    },
                                    erectMemoryOptimized3DFloat: (w, v, y, T)=>{
                                        const _ = new Array(T);
                                        for(let k = 0; k < T; k++){
                                            const C = new Array(y);
                                            for(let M = 0; M < y; M++){
                                                const x = k * y * v + M * v;
                                                C[M] = w.subarray(x, x + v);
                                            }
                                            _[k] = C;
                                        }
                                        return _;
                                    },
                                    erectFloat: (w, v)=>{
                                        const y = new Float32Array(v);
                                        let T = 0;
                                        for(let _ = 0; _ < v; _++)y[_] = w[T], T += 4;
                                        return y;
                                    },
                                    erect2DFloat: (w, v, y)=>{
                                        const T = new Array(y);
                                        let _ = 0;
                                        for(let k = 0; k < y; k++){
                                            const C = new Float32Array(v);
                                            for(let M = 0; M < v; M++)C[M] = w[_], _ += 4;
                                            T[k] = C;
                                        }
                                        return T;
                                    },
                                    erect3DFloat: (w, v, y, T)=>{
                                        const _ = new Array(T);
                                        let k = 0;
                                        for(let C = 0; C < T; C++){
                                            const M = new Array(y);
                                            for(let x = 0; x < y; x++){
                                                const g = new Float32Array(v);
                                                for(let I = 0; I < v; I++)g[I] = w[k], k += 4;
                                                M[x] = g;
                                            }
                                            _[C] = M;
                                        }
                                        return _;
                                    },
                                    erectArray2: (w, v)=>{
                                        const y = new Array(v), T = v * 4;
                                        let _ = 0;
                                        for(let k = 0; k < T; k += 4)y[_++] = w.subarray(k, k + 2);
                                        return y;
                                    },
                                    erect2DArray2: (w, v, y)=>{
                                        const T = new Array(y), _ = v * 4;
                                        for(let k = 0; k < y; k++){
                                            const C = new Array(v), M = k * _;
                                            let x = 0;
                                            for(let g = 0; g < _; g += 4)C[x++] = w.subarray(g + M, g + M + 2);
                                            T[k] = C;
                                        }
                                        return T;
                                    },
                                    erect3DArray2: (w, v, y, T)=>{
                                        const _ = v * 4, k = new Array(T);
                                        for(let C = 0; C < T; C++){
                                            const M = new Array(y);
                                            for(let x = 0; x < y; x++){
                                                const g = new Array(v), I = C * _ * y + x * _;
                                                let A = 0;
                                                for(let P = 0; P < _; P += 4)g[A++] = w.subarray(P + I, P + I + 2);
                                                M[x] = g;
                                            }
                                            k[C] = M;
                                        }
                                        return k;
                                    },
                                    erectArray3: (w, v)=>{
                                        const y = new Array(v), T = v * 4;
                                        let _ = 0;
                                        for(let k = 0; k < T; k += 4)y[_++] = w.subarray(k, k + 3);
                                        return y;
                                    },
                                    erect2DArray3: (w, v, y)=>{
                                        const T = v * 4, _ = new Array(y);
                                        for(let k = 0; k < y; k++){
                                            const C = new Array(v), M = k * T;
                                            let x = 0;
                                            for(let g = 0; g < T; g += 4)C[x++] = w.subarray(g + M, g + M + 3);
                                            _[k] = C;
                                        }
                                        return _;
                                    },
                                    erect3DArray3: (w, v, y, T)=>{
                                        const _ = v * 4, k = new Array(T);
                                        for(let C = 0; C < T; C++){
                                            const M = new Array(y);
                                            for(let x = 0; x < y; x++){
                                                const g = new Array(v), I = C * _ * y + x * _;
                                                let A = 0;
                                                for(let P = 0; P < _; P += 4)g[A++] = w.subarray(P + I, P + I + 3);
                                                M[x] = g;
                                            }
                                            k[C] = M;
                                        }
                                        return k;
                                    },
                                    erectArray4: (w, v)=>{
                                        const y = new Array(w), T = v * 4;
                                        let _ = 0;
                                        for(let k = 0; k < T; k += 4)y[_++] = w.subarray(k, k + 4);
                                        return y;
                                    },
                                    erect2DArray4: (w, v, y)=>{
                                        const T = v * 4, _ = new Array(y);
                                        for(let k = 0; k < y; k++){
                                            const C = new Array(v), M = k * T;
                                            let x = 0;
                                            for(let g = 0; g < T; g += 4)C[x++] = w.subarray(g + M, g + M + 4);
                                            _[k] = C;
                                        }
                                        return _;
                                    },
                                    erect3DArray4: (w, v, y, T)=>{
                                        const _ = v * 4, k = new Array(T);
                                        for(let C = 0; C < T; C++){
                                            const M = new Array(y);
                                            for(let x = 0; x < y; x++){
                                                const g = new Array(v), I = C * _ * y + x * _;
                                                let A = 0;
                                                for(let P = 0; P < _; P += 4)g[A++] = w.subarray(P + I, P + I + 4);
                                                M[x] = g;
                                            }
                                            k[C] = M;
                                        }
                                        return k;
                                    },
                                    flattenFunctionToString: (w, v)=>{
                                        const { findDependency: y, thisLookup: T, doNotDefine: _ } = v;
                                        let k = v.flattened;
                                        k || (k = v.flattened = {});
                                        const C = u.parse(w), M = [];
                                        let x = 0;
                                        function g(A) {
                                            if (Array.isArray(A)) {
                                                const P = [];
                                                for(let O = 0; O < A.length; O++)P.push(g(A[O]));
                                                return P.join("");
                                            }
                                            switch(A.type){
                                                case "Program":
                                                    return g(A.body) + (A.body[0].type === "VariableDeclaration" ? ";" : "");
                                                case "FunctionDeclaration":
                                                    return `function ${A.id.name}(${A.params.map(g).join(", ")}) ${g(A.body)}`;
                                                case "BlockStatement":
                                                    {
                                                        const O = [];
                                                        x += 2;
                                                        for(let R = 0; R < A.body.length; R++){
                                                            const G = g(A.body[R]);
                                                            G && O.push(" ".repeat(x) + G, `;
`);
                                                        }
                                                        return x -= 2, `{
${O.join("")}}`;
                                                    }
                                                case "VariableDeclaration":
                                                    const P = n.normalizeDeclarations(A).map(g).filter((O)=>O !== null);
                                                    return P.length < 1 ? "" : `${A.kind} ${P.join(",")}`;
                                                case "VariableDeclarator":
                                                    return A.init.object && A.init.object.type === "ThisExpression" ? T(A.init.property.name, !0) ? `${A.id.name} = ${g(A.init)}` : null : `${A.id.name} = ${g(A.init)}`;
                                                case "CallExpression":
                                                    {
                                                        if (A.callee.property.name === "subarray") return `${g(A.callee.object)}.${g(A.callee.property)}(${A.arguments.map((O)=>g(O)).join(", ")})`;
                                                        if (A.callee.object.name === "gl" || A.callee.object.name === "context") return `${g(A.callee.object)}.${g(A.callee.property)}(${A.arguments.map((O)=>g(O)).join(", ")})`;
                                                        if (A.callee.object.type === "ThisExpression") return M.push(y("this", A.callee.property.name)), `${A.callee.property.name}(${A.arguments.map((O)=>g(O)).join(", ")})`;
                                                        if (A.callee.object.name) {
                                                            const O = y(A.callee.object.name, A.callee.property.name);
                                                            return O === null ? `${A.callee.object.name}.${A.callee.property.name}(${A.arguments.map((R)=>g(R)).join(", ")})` : (M.push(O), `${A.callee.property.name}(${A.arguments.map((R)=>g(R)).join(", ")})`);
                                                        } else {
                                                            if (A.callee.object.type === "MemberExpression") return `${g(A.callee.object)}.${A.callee.property.name}(${A.arguments.map((O)=>g(O)).join(", ")})`;
                                                            throw new Error("unknown ast.callee");
                                                        }
                                                    }
                                                case "ReturnStatement":
                                                    return `return ${g(A.argument)}`;
                                                case "BinaryExpression":
                                                    return `(${g(A.left)}${A.operator}${g(A.right)})`;
                                                case "UnaryExpression":
                                                    return A.prefix ? `${A.operator} ${g(A.argument)}` : `${g(A.argument)} ${A.operator}`;
                                                case "ExpressionStatement":
                                                    return `${g(A.expression)}`;
                                                case "SequenceExpression":
                                                    return `(${g(A.expressions)})`;
                                                case "ArrowFunctionExpression":
                                                    return `(${A.params.map(g).join(", ")}) => ${g(A.body)}`;
                                                case "Literal":
                                                    return A.raw;
                                                case "Identifier":
                                                    return A.name;
                                                case "MemberExpression":
                                                    return A.object.type === "ThisExpression" ? T(A.property.name) : A.computed ? `${g(A.object)}[${g(A.property)}]` : g(A.object) + "." + g(A.property);
                                                case "ThisExpression":
                                                    return "this";
                                                case "NewExpression":
                                                    return `new ${g(A.callee)}(${A.arguments.map((O)=>g(O)).join(", ")})`;
                                                case "ForStatement":
                                                    return `for (${g(A.init)};${g(A.test)};${g(A.update)}) ${g(A.body)}`;
                                                case "AssignmentExpression":
                                                    return `${g(A.left)}${A.operator}${g(A.right)}`;
                                                case "UpdateExpression":
                                                    return `${g(A.argument)}${A.operator}`;
                                                case "IfStatement":
                                                    return `if (${g(A.test)}) ${g(A.consequent)}`;
                                                case "ThrowStatement":
                                                    return `throw ${g(A.argument)}`;
                                                case "ObjectPattern":
                                                    return A.properties.map(g).join(", ");
                                                case "ArrayPattern":
                                                    return A.elements.map(g).join(", ");
                                                case "DebuggerStatement":
                                                    return "debugger;";
                                                case "ConditionalExpression":
                                                    return `${g(A.test)}?${g(A.consequent)}:${g(A.alternate)}`;
                                                case "Property":
                                                    if (A.kind === "init") return g(A.key);
                                            }
                                            throw new Error(`unhandled ast.type of ${A.type}`);
                                        }
                                        const I = g(C);
                                        if (M.length > 0) {
                                            const A = [];
                                            for(let P = 0; P < M.length; P++){
                                                const O = M[P];
                                                k[O] || (k[O] = !0), O && A.push(n.flattenFunctionToString(O, v) + `
`);
                                            }
                                            return A.join("") + I;
                                        }
                                        return I;
                                    },
                                    normalizeDeclarations: (w)=>{
                                        if (w.type !== "VariableDeclaration") throw new Error('Ast is not of type "VariableDeclaration"');
                                        const v = [];
                                        for(let y = 0; y < w.declarations.length; y++){
                                            const T = w.declarations[y];
                                            if (T.id && T.id.type === "ObjectPattern" && T.id.properties) {
                                                const { properties: _ } = T.id;
                                                for(let k = 0; k < _.length; k++){
                                                    const C = _[k];
                                                    if (C.value.type === "ObjectPattern" && C.value.properties) for(let M = 0; M < C.value.properties.length; M++){
                                                        const x = C.value.properties[M];
                                                        if (x.type === "Property") v.push({
                                                            type: "VariableDeclarator",
                                                            id: {
                                                                type: "Identifier",
                                                                name: x.key.name
                                                            },
                                                            init: {
                                                                type: "MemberExpression",
                                                                object: {
                                                                    type: "MemberExpression",
                                                                    object: T.init,
                                                                    property: {
                                                                        type: "Identifier",
                                                                        name: C.key.name
                                                                    },
                                                                    computed: !1
                                                                },
                                                                property: {
                                                                    type: "Identifier",
                                                                    name: x.key.name
                                                                },
                                                                computed: !1
                                                            }
                                                        });
                                                        else throw new Error("unexpected state");
                                                    }
                                                    else if (C.value.type === "Identifier") v.push({
                                                        type: "VariableDeclarator",
                                                        id: {
                                                            type: "Identifier",
                                                            name: C.value && C.value.name ? C.value.name : C.key.name
                                                        },
                                                        init: {
                                                            type: "MemberExpression",
                                                            object: T.init,
                                                            property: {
                                                                type: "Identifier",
                                                                name: C.key.name
                                                            },
                                                            computed: !1
                                                        }
                                                    });
                                                    else throw new Error("unexpected state");
                                                }
                                            } else if (T.id && T.id.type === "ArrayPattern" && T.id.elements) {
                                                const { elements: _ } = T.id;
                                                for(let k = 0; k < _.length; k++){
                                                    const C = _[k];
                                                    if (C.type === "Identifier") v.push({
                                                        type: "VariableDeclarator",
                                                        id: {
                                                            type: "Identifier",
                                                            name: C.name
                                                        },
                                                        init: {
                                                            type: "MemberExpression",
                                                            object: T.init,
                                                            property: {
                                                                type: "Literal",
                                                                value: k,
                                                                raw: k.toString(),
                                                                start: C.start,
                                                                end: C.end
                                                            },
                                                            computed: !0
                                                        }
                                                    });
                                                    else throw new Error("unexpected state");
                                                }
                                            } else v.push(T);
                                        }
                                        return v;
                                    },
                                    splitHTMLImageToRGB: (w, v)=>{
                                        const y = w.createKernel(function(M) {
                                            return M[this.thread.y][this.thread.x].r * 255;
                                        }, {
                                            output: [
                                                v.width,
                                                v.height
                                            ],
                                            precision: "unsigned",
                                            argumentTypes: {
                                                a: "HTMLImage"
                                            }
                                        }), T = w.createKernel(function(M) {
                                            return M[this.thread.y][this.thread.x].g * 255;
                                        }, {
                                            output: [
                                                v.width,
                                                v.height
                                            ],
                                            precision: "unsigned",
                                            argumentTypes: {
                                                a: "HTMLImage"
                                            }
                                        }), _ = w.createKernel(function(M) {
                                            return M[this.thread.y][this.thread.x].b * 255;
                                        }, {
                                            output: [
                                                v.width,
                                                v.height
                                            ],
                                            precision: "unsigned",
                                            argumentTypes: {
                                                a: "HTMLImage"
                                            }
                                        }), k = w.createKernel(function(M) {
                                            return M[this.thread.y][this.thread.x].a * 255;
                                        }, {
                                            output: [
                                                v.width,
                                                v.height
                                            ],
                                            precision: "unsigned",
                                            argumentTypes: {
                                                a: "HTMLImage"
                                            }
                                        }), C = [
                                            y(v),
                                            T(v),
                                            _(v),
                                            k(v)
                                        ];
                                        return C.rKernel = y, C.gKernel = T, C.bKernel = _, C.aKernel = k, C.gpu = w, C;
                                    },
                                    splitRGBAToCanvases: (w, v, y, T)=>{
                                        const _ = w.createKernel(function(x) {
                                            const g = x[this.thread.y][this.thread.x];
                                            this.color(g.r / 255, 0, 0, 255);
                                        }, {
                                            output: [
                                                y,
                                                T
                                            ],
                                            graphical: !0,
                                            argumentTypes: {
                                                v: "Array2D(4)"
                                            }
                                        });
                                        _(v);
                                        const k = w.createKernel(function(x) {
                                            const g = x[this.thread.y][this.thread.x];
                                            this.color(0, g.g / 255, 0, 255);
                                        }, {
                                            output: [
                                                y,
                                                T
                                            ],
                                            graphical: !0,
                                            argumentTypes: {
                                                v: "Array2D(4)"
                                            }
                                        });
                                        k(v);
                                        const C = w.createKernel(function(x) {
                                            const g = x[this.thread.y][this.thread.x];
                                            this.color(0, 0, g.b / 255, 255);
                                        }, {
                                            output: [
                                                y,
                                                T
                                            ],
                                            graphical: !0,
                                            argumentTypes: {
                                                v: "Array2D(4)"
                                            }
                                        });
                                        C(v);
                                        const M = w.createKernel(function(x) {
                                            const g = x[this.thread.y][this.thread.x];
                                            this.color(255, 255, 255, g.a / 255);
                                        }, {
                                            output: [
                                                y,
                                                T
                                            ],
                                            graphical: !0,
                                            argumentTypes: {
                                                v: "Array2D(4)"
                                            }
                                        });
                                        return M(v), [
                                            _.canvas,
                                            k.canvas,
                                            C.canvas,
                                            M.canvas
                                        ];
                                    },
                                    getMinifySafeName: (w)=>{
                                        try {
                                            const v = u.parse(`const value = ${w.toString()}`), { init: y } = v.body[0].declarations[0];
                                            return y.body.name || y.body.body[0].argument.name;
                                        } catch  {
                                            throw new Error("Unrecognized function type.  Please use `() => yourFunctionVariableHere` or function() { return yourFunctionVariableHere; }");
                                        }
                                    },
                                    sanitizeName: function(w) {
                                        return r.test(w) && (w = w.replace(r, "S_S")), m.test(w) ? w = w.replace(m, "U_U") : b.test(w) && (w = w.replace(b, "u_u")), w;
                                    }
                                }, r = /\$/, m = /__/, b = /_/, E = n.getSystemEndianness();
                                i.exports = {
                                    utils: n
                                };
                            },
                            {
                                "./input": 110,
                                "./texture": 113,
                                acorn: 1
                            }
                        ]
                    }, {}, [
                        107
                    ])(107);
                });
            });
            const dt = {
                toTable (c) {
                    const t = c.reduce((e, i)=>Object.assign(e, i), {});
                    return dt.toHash(t);
                },
                toTable2D (c) {
                    const t = {};
                    let e = 0;
                    for(let i = 0; i < c.length; i++){
                        const h = c[i];
                        for(let u = 0; u < h.length; u++){
                            const p = h[u];
                            for(const d in p)p.hasOwnProperty(d) && !t.hasOwnProperty(d) && (t[d] = e++);
                        }
                    }
                    return t;
                },
                toInputTable2D (c) {
                    const t = {};
                    let e = 0;
                    for(let i = 0; i < c.length; i++){
                        const h = c[i].input;
                        for(let u = 0; u < h.length; u++){
                            const p = h[u];
                            for(const d in p)p.hasOwnProperty(d) && (t.hasOwnProperty(d) || (t[d] = e++));
                        }
                    }
                    return t;
                },
                toOutputTable2D (c) {
                    const t = {};
                    let e = 0;
                    for(let i = 0; i < c.length; i++){
                        const h = c[i].output;
                        for(let u = 0; u < h.length; u++){
                            const p = h[u];
                            for(const d in p)p.hasOwnProperty(d) && (t.hasOwnProperty(d) || (t[d] = e++));
                        }
                    }
                    return t;
                },
                toHash (c) {
                    const t = {};
                    let e = 0;
                    const i = Object.keys(c);
                    for(let h = 0; h < i.length; h++)t[i[h]] = e++;
                    return t;
                },
                toArray (c, t, e) {
                    const i = new Float32Array(e);
                    for(const h in c)c.hasOwnProperty(h) && (i[c[h]] = t.hasOwnProperty(h) ? t[h] : 0);
                    return i;
                },
                toArrayShort (c, t) {
                    const e = [];
                    for(const i in c)if (c.hasOwnProperty(i)) {
                        if (!t.hasOwnProperty(i)) break;
                        e[c[i]] = t[i];
                    }
                    return Float32Array.from(e);
                },
                toArrays (c, t, e) {
                    const i = [];
                    for(let h = 0; h < t.length; h++)i.push(this.toArray(c, t[h], e));
                    return i;
                },
                toObject (c, t) {
                    const e = {};
                    for(const i in c)c.hasOwnProperty(i) && (e[i] = t[c[i]]);
                    return e;
                },
                toObjectPartial (c, t, e = 0, i = 0) {
                    const h = {};
                    let u = 0;
                    for(const p in c)c.hasOwnProperty(p) && (e > 0 && u++ < e || i > 0 && u++ >= i || (h[p] = t[c[p] - e]));
                    return h;
                },
                dataShape (c) {
                    const t = [];
                    let e;
                    c.hasOwnProperty("input") ? (t.push("datum"), e = c.input) : Array.isArray(c) ? c[0] && c[0].input ? (t.push("array", "datum"), e = c[0].input) : Array.isArray(c[0]) ? (t.push("array"), e = c[0]) : e = c : e = c;
                    let i;
                    for(; e;)if (i = Object.keys(e)[0], Array.isArray(e) || typeof e.buffer == "object") {
                        t.push("array");
                        const h = e[parseInt(i)];
                        if (typeof h == "number") {
                            t.push("number");
                            break;
                        } else e = h;
                    } else if (typeof e == "object" && typeof e.buffer != "object") {
                        t.push("object");
                        const h = e[i];
                        if (typeof h == "number") {
                            t.push("number");
                            break;
                        } else e = h;
                    } else throw new Error("unhandled signature");
                    return t;
                },
                addKeys (c, t) {
                    if (Array.isArray(c)) return t;
                    let e = Object.keys(t).length;
                    for(const i in c)c.hasOwnProperty(i) && (t.hasOwnProperty(i) || (t[i] = e++));
                    return t;
                }
            };
            var oe = Kt(function(c, t) {
                var e = vt && vt.__assign || function() {
                    return e = Object.assign || function(p) {
                        for(var d, l = 1, a = arguments.length; l < a; l++){
                            d = arguments[l];
                            for(var o in d)Object.prototype.hasOwnProperty.call(d, o) && (p[o] = d[o]);
                        }
                        return p;
                    }, e.apply(this, arguments);
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.thaw = t.Block = t.Thaw = void 0;
                var i = function() {
                    function p(d, l) {
                        var a = this;
                        l === void 0 && (l = {});
                        var o = e(e({}, p.defaultSettings), l), n = o.each, r = o.done;
                        this.i = 0, this.isStopped = !1, this.items = d, this.options = l, this.tick = function() {
                            if (!a.isStopped && (a.timeout = setTimeout(a.tick, 0), !p.thawing)) {
                                var m = a.items[a.i];
                                if (a.i >= a.items.length) {
                                    r !== null && (p.thawing = !0, r(), p.thawing = !1), a.isStopped = !0, clearTimeout(a.timeout);
                                    return;
                                }
                                n !== null ? (p.thawing = !0, n(m, a.i), p.thawing = !1) : m !== void 0 && m(), a.i++;
                            }
                        }, p.thaws.push(this), l.delay || this.tick();
                    }
                    return Object.defineProperty(p, "isThawing", {
                        get: function() {
                            return p.thawing;
                        },
                        enumerable: !1,
                        configurable: !0
                    }), p.stopAll = function() {
                        for(var d = 0; d < p.thaws.length; d++)p.thaws[d].stop();
                    }, p.prototype.makeReady = function() {
                        return this.isStopped ? (this.isStopped = !1, !0) : !1;
                    }, p.prototype.add = function(d) {
                        return this.items.push(d), this.makeReady() && this.tick(), this;
                    }, p.prototype.insert = function(d) {
                        return this.items.splice(this.i, 0, d), this.makeReady() && this.tick(), this;
                    }, p.prototype.addArray = function(d) {
                        return this.items = this.items.concat(d), this.makeReady() && this.tick(), this;
                    }, p.prototype.insertArray = function(d) {
                        var l = this.items.splice(0, this.i), a = this.items;
                        return this.items = l.concat(d, a), this.makeReady() && this.tick(), this;
                    }, p.prototype.stop = function() {
                        return this.isStopped = !0, clearTimeout(this.timeout), this.options.done && this.options.done(), this;
                    }, p.thawing = !1, p.thaws = [], p.defaultSettings = {
                        each: null,
                        done: null
                    }, p;
                }();
                t.Thaw = i;
                function h(p, d) {
                    return new i(p, d);
                }
                t.thaw = h;
                var u = function() {
                    function p(d, l) {
                        l === void 0 && (l = 200), this.index = 0, this.thaws = [], this.count = l, this.options = d;
                    }
                    return p.prototype.add = function(d) {
                        var l = this.next();
                        return l.add(d), this;
                    }, p.prototype.addArray = function(d) {
                        var l = this.next();
                        return l.addArray(d), this;
                    }, p.prototype.insert = function(d) {
                        var l = this.next();
                        return l.insert(d), this;
                    }, p.prototype.insertArray = function(d) {
                        var l = this.next();
                        return l.insertArray(d), this;
                    }, p.prototype.stop = function() {
                        for(var d = 0; d < this.thaws.length; d++)this.thaws[d].stop();
                        return this;
                    }, p.prototype.next = function() {
                        var d, l = this.thaws;
                        return l.length < this.count ? (d = new i([], this.options), l.push(d)) : d = l[this.index] || null, this.index++, this.index >= this.count && (this.index = 0), d;
                    }, p;
                }();
                t.Block = u, typeof window < "u" && (window.Thaw = i, window.thaw = h, window.Thaw.Block = u);
            });
            function fe(c) {
                const t = [];
                for(let e = 0; e < c.length; e++)t.push(Float32Array.from(c[e]));
                return t;
            }
            function Qt(c, t) {
                const e = [];
                for(let i = 0; i < c.length; i++)e.push(Float32Array.from(c[i]));
                for(let i = 0; i < t.length; i++)e.push(Float32Array.from(t[i]));
                return e;
            }
            function Pe(c) {
                const t = [];
                for(let e = 0; e < c.length; e++)t.push(Float32Array.from([
                    c[e]
                ]));
                return t;
            }
            function Ne(c, t) {
                const e = [];
                for(let i = 0; i < c.length; i++)e.push(Float32Array.from([
                    c[i]
                ]));
                for(let i = 0; i < t.length; i++)e.push(Float32Array.from([
                    t[i]
                ]));
                return e;
            }
            function Ve(c) {
                return Float32Array.from(c);
            }
            function xe(c, t, e, i, h, u) {
                const p = [];
                for(let d = 0; d < c.length; d++){
                    const l = c[d], a = new Float32Array(h);
                    for(const o in l)l.hasOwnProperty(o) && (a[e[o]] = l[o]);
                    p.push(a);
                }
                for(let d = 0; d < t.length; d++){
                    const l = t[d], a = new Float32Array(u);
                    for(const o in l)l.hasOwnProperty(o) && (a[i[o]] = l[o]);
                    p.push(a);
                }
                return p;
            }
            function ai(c) {
                const t = [];
                for(const e in c)c.hasOwnProperty(e) && t.push(Float32Array.from([
                    c[e]
                ]));
                return t;
            }
            function hn(c, t) {
                const e = [];
                for(const i in c)c.hasOwnProperty(i) && e.push(Float32Array.from([
                    c[i]
                ]));
                for(const i in t)t.hasOwnProperty(i) && e.push(Float32Array.from([
                    t[i]
                ]));
                return e;
            }
            function Di(c, t, e) {
                const i = new Float32Array(e);
                for(const h in c)c.hasOwnProperty(h) && (i[t[h]] = c[h]);
                return i;
            }
            class te {
                constructor(t, e){
                    this.prop = null, this.table = {}, this.length = 0;
                    const i = this.table;
                    if (e) {
                        this.prop = e;
                        for(let h = 0; h < t.length; h++){
                            const p = t[h][e];
                            for(const d in p)p.hasOwnProperty(d) && (i.hasOwnProperty(d) || (i[d] = this.length++));
                        }
                    } else if (Array.isArray(t) && Array.isArray(t[0])) for(let h = 0; h < t.length; h++){
                        const u = t[h];
                        for(let p = 0; p < u.length; p++){
                            const d = u[p];
                            for(const l in d)d.hasOwnProperty(l) && (i.hasOwnProperty(l) || (i[l] = this.length++));
                        }
                    }
                    else for(let h = 0; h < t.length; h++){
                        const u = t[h];
                        for(const p in u)u.hasOwnProperty(p) && (i.hasOwnProperty(p) || (i[p] = this.length++));
                    }
                }
            }
            function oi(c) {
                return Array.isArray(c) || c instanceof Float32Array ? Math.max(...c) : Math.max(...Object.values(c));
            }
            function Ke(c) {
                let t = 0;
                for(let e = 0; e < c.length; e++)t += c[e] ** 2;
                return t / c.length;
            }
            function $i() {
                return Math.random() * .4 - .2;
            }
            function be(c, t) {
                return Math.random() * (t - c) + c;
            }
            function Zt() {
                if (Zt.returnV) return Zt.returnV = !1, Zt.vVal;
                const c = 2 * Math.random() - 1, t = 2 * Math.random() - 1, e = c * c + t * t;
                if (e === 0 || e > 1) return Zt();
                const i = Math.sqrt(-2 * Math.log(e) / e);
                return Zt.vVal = t * i, Zt.returnV = !0, c * i;
            }
            function ln(c, t) {
                return Math.floor(Math.random() * (t - c) + c);
            }
            function cn(c, t) {
                return c + Zt() * t;
            }
            Zt.returnV = !1, Zt.vVal = 0;
            var pn = Object.freeze({
                __proto__: null,
                randomFloat: be,
                gaussRandom: Zt,
                randomInteger: ln,
                randomN: cn
            });
            function we(c, t = null) {
                const e = new Float32Array(c);
                if (t === null) for(let i = 0; i < c; i++)e[i] = $i();
                else for(let i = 0; i < c; i++)e[i] = be(-t, t);
                return e;
            }
            function Ee(c, t, e) {
                const i = new Array(t);
                for(let h = 0; h < t; h++)i[h] = we(c, e);
                return i;
            }
            function ke(c, t, e, i) {
                const h = new Array(e);
                for(let u = 0; u < e; u++)h[u] = Ee(c, t, i);
                return h;
            }
            function Vt(c) {
                return new Float32Array(c);
            }
            function Oi(c, t) {
                if (c.buffer instanceof ArrayBuffer) return null;
                if (Array.isArray(c)) return Ve;
                if (!t) throw new Error("table is not Object");
                const { length: e } = Object.keys(t);
                return (i)=>{
                    const h = new Float32Array(e);
                    for(const u in t)t.hasOwnProperty(u) && typeof i[u] == "number" && (h[t[u]] = i[u] || 0);
                    return h;
                };
            }
            function Ci() {
                return {
                    inputSize: 0,
                    outputSize: 0,
                    binaryThresh: .5
                };
            }
            function fn() {
                return {
                    activation: "sigmoid",
                    iterations: 2e4,
                    errorThresh: .005,
                    log: !1,
                    logPeriod: 10,
                    leakyReluAlpha: .01,
                    learningRate: .3,
                    momentum: .1,
                    callbackPeriod: 10,
                    timeout: 1 / 0,
                    beta1: .9,
                    beta2: .999,
                    epsilon: 1e-8
                };
            }
            class ui {
                constructor(t = {}){
                    this.options = Ci(), this.trainOpts = fn(), this.sizes = [], this.outputLayer = -1, this.biases = [], this.weights = [], this.outputs = [], this.deltas = [], this.changes = [], this.errors = [], this.errorCheckInterval = 1, this.inputLookup = null, this.inputLookupLength = 0, this.outputLookup = null, this.outputLookupLength = 0, this._formatInput = null, this._formatOutput = null, this.runInput = (u)=>(this.setActivation(), this.runInput(u)), this.calculateDeltas = (u)=>(this.setActivation(), this.calculateDeltas(u)), this.biasChangesLow = [], this.biasChangesHigh = [], this.changesLow = [], this.changesHigh = [], this.iterations = 0, this.options = {
                        ...this.options,
                        ...t
                    }, this.updateTrainingOptions(t);
                    const { inputSize: e, hiddenLayers: i, outputSize: h } = this.options;
                    e && h && (this.sizes = [
                        e
                    ].concat(i ?? []).concat([
                        h
                    ]));
                }
                initialize() {
                    if (!this.sizes.length) throw new Error("Sizes must be set before initializing");
                    this.outputLayer = this.sizes.length - 1, this.biases = new Array(this.outputLayer), this.weights = new Array(this.outputLayer), this.outputs = new Array(this.outputLayer), this.deltas = new Array(this.outputLayer), this.changes = new Array(this.outputLayer), this.errors = new Array(this.outputLayer);
                    for(let t = 0; t <= this.outputLayer; t++){
                        const e = this.sizes[t];
                        if (this.deltas[t] = Vt(e), this.errors[t] = Vt(e), this.outputs[t] = Vt(e), t > 0) {
                            this.biases[t] = we(e), this.weights[t] = new Array(e), this.changes[t] = new Array(e);
                            for(let i = 0; i < e; i++){
                                const h = this.sizes[t - 1];
                                this.weights[t][i] = we(h), this.changes[t][i] = Vt(h);
                            }
                        }
                    }
                    this.setActivation(), this.trainOpts.praxis === "adam" && this._setupAdam();
                }
                setActivation(t) {
                    const e = t ?? this.trainOpts.activation;
                    switch(e){
                        case "sigmoid":
                            this.runInput = this._runInputSigmoid, this.calculateDeltas = this._calculateDeltasSigmoid;
                            break;
                        case "relu":
                            this.runInput = this._runInputRelu, this.calculateDeltas = this._calculateDeltasRelu;
                            break;
                        case "leaky-relu":
                            this.runInput = this._runInputLeakyRelu, this.calculateDeltas = this._calculateDeltasLeakyRelu;
                            break;
                        case "tanh":
                            this.runInput = this._runInputTanh, this.calculateDeltas = this._calculateDeltasTanh;
                            break;
                        default:
                            throw new Error(`Unknown activation ${e}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`);
                    }
                }
                get isRunnable() {
                    return this.sizes.length > 0;
                }
                run(t) {
                    if (!this.isRunnable) throw new Error("network not runnable");
                    let e;
                    this.inputLookup ? e = dt.toArray(this.inputLookup, t, this.inputLookupLength) : e = t, this.validateInput(e);
                    const i = this.runInput(e).slice(0);
                    return this.outputLookup ? dt.toObject(this.outputLookup, i) : i;
                }
                _runInputSigmoid(t) {
                    this.outputs[0] = t;
                    let e = null;
                    for(let i = 1; i <= this.outputLayer; i++){
                        const h = this.sizes[i], u = this.weights[i], p = this.biases[i], d = this.outputs[i];
                        for(let l = 0; l < h; l++){
                            const a = u[l];
                            let o = p[l];
                            for(let n = 0; n < a.length; n++)o += a[n] * t[n];
                            d[l] = 1 / (1 + Math.exp(-o));
                        }
                        e = t = d;
                    }
                    if (!e) throw new Error("output was empty");
                    return e;
                }
                _runInputRelu(t) {
                    this.outputs[0] = t;
                    let e = null;
                    for(let i = 1; i <= this.outputLayer; i++){
                        const h = this.sizes[i], u = this.weights[i], p = this.biases[i], d = this.outputs[i];
                        for(let l = 0; l < h; l++){
                            const a = u[l];
                            let o = p[l];
                            for(let n = 0; n < a.length; n++)o += a[n] * t[n];
                            d[l] = o < 0 ? 0 : o;
                        }
                        e = t = d;
                    }
                    if (!e) throw new Error("output was empty");
                    return e;
                }
                _runInputLeakyRelu(t) {
                    this.outputs[0] = t;
                    const { leakyReluAlpha: e } = this.trainOpts;
                    let i = null;
                    for(let h = 1; h <= this.outputLayer; h++){
                        const u = this.sizes[h], p = this.weights[h], d = this.biases[h], l = this.outputs[h];
                        for(let a = 0; a < u; a++){
                            const o = p[a];
                            let n = d[a];
                            for(let r = 0; r < o.length; r++)n += o[r] * t[r];
                            l[a] = Math.max(n, e * n);
                        }
                        i = t = l;
                    }
                    if (!i) throw new Error("output was empty");
                    return i;
                }
                _runInputTanh(t) {
                    this.outputs[0] = t;
                    let e = null;
                    for(let i = 1; i <= this.outputLayer; i++){
                        const h = this.sizes[i], u = this.weights[i], p = this.biases[i], d = this.outputs[i];
                        for(let l = 0; l < h; l++){
                            const a = u[l];
                            let o = p[l];
                            for(let n = 0; n < a.length; n++)o += a[n] * t[n];
                            d[l] = Math.tanh(o);
                        }
                        e = t = d;
                    }
                    if (!e) throw new Error("output was empty");
                    return e;
                }
                verifyIsInitialized(t) {
                    this.sizes.length && this.outputLayer > 0 || (this.sizes = [], this.sizes.push(t[0].input.length), this.options.hiddenLayers ? this.options.hiddenLayers.forEach((e)=>{
                        this.sizes.push(e);
                    }) : this.sizes.push(Math.max(3, Math.floor(t[0].input.length / 2))), this.sizes.push(t[0].output.length), this.initialize());
                }
                updateTrainingOptions(t) {
                    const e = {
                        ...this.trainOpts,
                        ...t
                    };
                    this.validateTrainingOptions(e), this.trainOpts = e, this.setLogMethod(this.trainOpts.log);
                }
                validateTrainingOptions(t) {
                    const e = {
                        activation: ()=>[
                                "sigmoid",
                                "relu",
                                "leaky-relu",
                                "tanh"
                            ].includes(t.activation),
                        iterations: ()=>{
                            const i = t.iterations;
                            return typeof i == "number" && i > 0;
                        },
                        errorThresh: ()=>{
                            const i = t.errorThresh;
                            return typeof i == "number" && i > 0 && i < 1;
                        },
                        log: ()=>{
                            const i = t.log;
                            return typeof i == "function" || typeof i == "boolean";
                        },
                        logPeriod: ()=>{
                            const i = t.logPeriod;
                            return typeof i == "number" && i > 0;
                        },
                        leakyReluAlpha: ()=>{
                            const i = t.leakyReluAlpha;
                            return typeof i == "number" && i > 0 && i < 1;
                        },
                        learningRate: ()=>{
                            const i = t.learningRate;
                            return typeof i == "number" && i > 0 && i < 1;
                        },
                        momentum: ()=>{
                            const i = t.momentum;
                            return typeof i == "number" && i > 0 && i < 1;
                        },
                        callback: ()=>{
                            const i = t.callback;
                            return typeof i == "function" || i === void 0;
                        },
                        callbackPeriod: ()=>{
                            const i = t.callbackPeriod;
                            return typeof i == "number" && i > 0;
                        },
                        timeout: ()=>{
                            const i = t.timeout;
                            return typeof i == "number" && i > 0;
                        },
                        praxis: ()=>{
                            const i = t.praxis;
                            return !i || i === "adam";
                        },
                        beta1: ()=>{
                            const i = t.beta1;
                            return i > 0 && i < 1;
                        },
                        beta2: ()=>{
                            const i = t.beta2;
                            return i > 0 && i < 1;
                        },
                        epsilon: ()=>{
                            const i = t.epsilon;
                            return i > 0 && i < 1;
                        }
                    };
                    for(const i in e){
                        const h = t;
                        if (!e[i]()) throw new Error(`[${i}, ${h[i]}] is out of normal training range, your network will probably not train.`);
                    }
                }
                getTrainOptsJSON() {
                    const { activation: t, iterations: e, errorThresh: i, log: h, logPeriod: u, leakyReluAlpha: p, learningRate: d, momentum: l, callbackPeriod: a, timeout: o, praxis: n, beta1: r, beta2: m, epsilon: b } = this.trainOpts;
                    return {
                        activation: t,
                        iterations: e,
                        errorThresh: i,
                        log: typeof h == "function" ? !0 : typeof h == "boolean" ? h : !1,
                        logPeriod: u,
                        leakyReluAlpha: p,
                        learningRate: d,
                        momentum: l,
                        callbackPeriod: a,
                        timeout: o === 1 / 0 ? "Infinity" : o,
                        praxis: n,
                        beta1: r,
                        beta2: m,
                        epsilon: b
                    };
                }
                setLogMethod(t) {
                    typeof t == "function" ? this.trainOpts.log = t : t ? this.trainOpts.log = this.logTrainingStatus : this.trainOpts.log = !1;
                }
                logTrainingStatus(t) {
                    console.log(`iterations: ${t.iterations}, training error: ${t.error}`);
                }
                calculateTrainingError(t) {
                    let e = 0;
                    for(let i = 0; i < t.length; ++i)e += this.trainPattern(t[i], !0);
                    return e / t.length;
                }
                trainPatterns(t) {
                    for(let e = 0; e < t.length; ++e)this.trainPattern(t[e]);
                }
                trainingTick(t, e, i) {
                    const { callback: h, callbackPeriod: u, errorThresh: p, iterations: d, log: l, logPeriod: a } = this.trainOpts;
                    return e.iterations >= d || e.error <= p || Date.now() >= i ? !1 : (e.iterations++, l && e.iterations % a === 0 ? (e.error = this.calculateTrainingError(t), l(e)) : e.iterations % this.errorCheckInterval === 0 ? e.error = this.calculateTrainingError(t) : this.trainPatterns(t), h && e.iterations % u === 0 && h({
                        iterations: e.iterations,
                        error: e.error
                    }), !0);
                }
                prepTraining(t, e = {}) {
                    this.updateTrainingOptions(e);
                    const i = this.formatData(t), h = Date.now() + this.trainOpts.timeout, u = {
                        error: 1,
                        iterations: 0
                    };
                    return this.verifyIsInitialized(i), this.validateData(i), {
                        preparedData: i,
                        status: u,
                        endTime: h
                    };
                }
                train(t, e = {}) {
                    const { preparedData: i, status: h, endTime: u } = this.prepTraining(t, e);
                    for(; this.trainingTick(i, h, u););
                    return h;
                }
                async trainAsync(t, e = {}) {
                    const { preparedData: i, status: h, endTime: u } = this.prepTraining(t, e);
                    return await new Promise((p, d)=>{
                        try {
                            const l = new oe.Thaw(new Array(this.trainOpts.iterations), {
                                delay: !0,
                                each: ()=>this.trainingTick(i, h, u) || l.stop(),
                                done: ()=>p(h)
                            });
                            l.tick();
                        } catch (l) {
                            d(l);
                        }
                    });
                }
                trainPattern(t, e) {
                    return this.runInput(t.input), this.calculateDeltas(t.output), this.adjustWeights(), e ? Ke(this.errors[this.outputLayer]) : null;
                }
                _calculateDeltasSigmoid(t) {
                    for(let e = this.outputLayer; e >= 0; e--){
                        const i = this.sizes[e], h = this.outputs[e], u = this.errors[e], p = this.deltas[e], d = this.weights[e + 1];
                        for(let l = 0; l < i; l++){
                            const a = h[l];
                            let o = 0;
                            if (e === this.outputLayer) o = t[l] - a;
                            else {
                                const n = this.deltas[e + 1];
                                for(let r = 0; r < n.length; r++)o += n[r] * d[r][l];
                            }
                            u[l] = o, p[l] = o * a * (1 - a);
                        }
                    }
                }
                _calculateDeltasRelu(t) {
                    for(let e = this.outputLayer; e >= 0; e--){
                        const i = this.sizes[e], h = this.outputs[e], u = this.weights[e + 1], p = this.deltas[e + 1], d = this.errors[e], l = this.deltas[e];
                        for(let a = 0; a < i; a++){
                            const o = h[a];
                            let n = 0;
                            if (e === this.outputLayer) n = t[a] - o;
                            else for(let r = 0; r < p.length; r++)n += p[r] * u[r][a];
                            d[a] = n, l[a] = o > 0 ? n : 0;
                        }
                    }
                }
                _calculateDeltasLeakyRelu(t) {
                    const e = this.trainOpts.leakyReluAlpha;
                    for(let i = this.outputLayer; i >= 0; i--){
                        const h = this.sizes[i], u = this.outputs[i], p = this.deltas[i + 1], d = this.weights[i + 1], l = this.errors[i], a = this.deltas[i];
                        for(let o = 0; o < h; o++){
                            const n = u[o];
                            let r = 0;
                            if (i === this.outputLayer) r = t[o] - n;
                            else for(let m = 0; m < p.length; m++)r += p[m] * d[m][o];
                            l[o] = r, a[o] = n > 0 ? r : e * r;
                        }
                    }
                }
                _calculateDeltasTanh(t) {
                    for(let e = this.outputLayer; e >= 0; e--){
                        const i = this.sizes[e], h = this.outputs[e], u = this.deltas[e + 1], p = this.weights[e + 1], d = this.errors[e], l = this.deltas[e];
                        for(let a = 0; a < i; a++){
                            const o = h[a];
                            let n = 0;
                            if (e === this.outputLayer) n = t[a] - o;
                            else for(let r = 0; r < u.length; r++)n += u[r] * p[r][a];
                            d[a] = n, l[a] = (1 - o * o) * n;
                        }
                    }
                }
                adjustWeights() {
                    const { learningRate: t, momentum: e } = this.trainOpts;
                    for(let i = 1; i <= this.outputLayer; i++){
                        const h = this.outputs[i - 1], u = this.sizes[i], p = this.deltas[i], d = this.changes[i], l = this.weights[i], a = this.biases[i];
                        for(let o = 0; o < u; o++){
                            const n = p[o];
                            for(let r = 0; r < h.length; r++){
                                let m = d[o][r];
                                m = t * n * h[r] + e * m, d[o][r] = m, l[o][r] += m;
                            }
                            a[o] += t * n;
                        }
                    }
                }
                _setupAdam() {
                    this.biasChangesLow = [], this.biasChangesHigh = [], this.changesLow = [], this.changesHigh = [], this.iterations = 0;
                    for(let t = 0; t <= this.outputLayer; t++){
                        const e = this.sizes[t];
                        if (t > 0) {
                            this.biasChangesLow[t] = Vt(e), this.biasChangesHigh[t] = Vt(e), this.changesLow[t] = new Array(e), this.changesHigh[t] = new Array(e);
                            for(let i = 0; i < e; i++){
                                const h = this.sizes[t - 1];
                                this.changesLow[t][i] = Vt(h), this.changesHigh[t][i] = Vt(h);
                            }
                        }
                    }
                    this.adjustWeights = this._adjustWeightsAdam;
                }
                _adjustWeightsAdam() {
                    this.iterations++;
                    const { iterations: t } = this, { beta1: e, beta2: i, epsilon: h, learningRate: u } = this.trainOpts;
                    for(let p = 1; p <= this.outputLayer; p++){
                        const d = this.outputs[p - 1], l = this.sizes[p], a = this.deltas[p], o = this.changesLow[p], n = this.changesHigh[p], r = this.weights[p], m = this.biases[p], b = this.biasChangesLow[p], E = this.biasChangesHigh[p];
                        for(let w = 0; w < l; w++){
                            const v = a[w];
                            for(let M = 0; M < d.length; M++){
                                const x = v * d[M], g = o[w][M] * e + (1 - e) * x, I = n[w][M] * i + (1 - i) * x * x, A = g / (1 - Math.pow(e, t)), P = I / (1 - Math.pow(i, t));
                                o[w][M] = g, n[w][M] = I, r[w][M] += u * A / (Math.sqrt(P) + h);
                            }
                            const y = a[w], T = b[w] * e + (1 - e) * y, _ = E[w] * i + (1 - i) * y * y, k = b[w] / (1 - Math.pow(e, t)), C = E[w] / (1 - Math.pow(i, t));
                            b[w] = T, E[w] = _, m[w] += u * k / (Math.sqrt(C) + h);
                        }
                    }
                }
                validateData(t) {
                    const e = this.sizes[0], i = this.sizes[this.sizes.length - 1], { length: h } = t;
                    for(let u = 0; u < h; u++){
                        const { input: p, output: d } = t[u];
                        if (p.length !== e) throw new Error(`input at index ${u} length ${p.length} must be ${e}`);
                        if (t[u].output.length !== i) throw new Error(`output at index ${u} length ${d.length} must be ${i}`);
                    }
                }
                validateInput(t) {
                    const e = this.sizes[0];
                    if (t.length !== e) throw new Error(`input length ${t.length} must match options.inputSize of ${e}`);
                }
                formatData(t) {
                    if (!Array.isArray(t[0].input)) if (this.inputLookup) this.inputLookupLength = Object.keys(this.inputLookup).length;
                    else {
                        const e = new te(t, "input");
                        this.inputLookup = e.table, this.inputLookupLength = e.length;
                    }
                    if (!Array.isArray(t[0].output)) if (this.outputLookup) this.outputLookupLength = Object.keys(this.outputLookup).length;
                    else {
                        const e = new te(t, "output");
                        this.outputLookup = e.table, this.outputLookupLength = e.length;
                    }
                    if (this._formatInput || (this._formatInput = Oi(t[0].input, this.inputLookup)), this._formatOutput || (this._formatOutput = Oi(t[0].output, this.outputLookup)), this._formatInput && this._formatOutput) {
                        const e = [];
                        for(let i = 0; i < t.length; i++)e.push({
                            input: this._formatInput(t[i].input),
                            output: this._formatOutput(t[i].output)
                        });
                        return e;
                    }
                    if (this._formatInput) {
                        const e = [];
                        for(let i = 0; i < t.length; i++)e.push({
                            input: this._formatInput(t[i].input),
                            output: t[i].output
                        });
                        return e;
                    }
                    if (this._formatOutput) {
                        const e = [];
                        for(let i = 0; i < t.length; i++)e.push({
                            input: t[i].input,
                            output: this._formatOutput(t[i].output)
                        });
                        return e;
                    }
                    return t;
                }
                addFormat(t) {
                    var e, i;
                    (!Array.isArray(t.input) || typeof t.input[0] != "number") && (this.inputLookup = dt.addKeys(t.input, (e = this.inputLookup) !== null && e !== void 0 ? e : {}), this.inputLookup && (this.inputLookupLength = Object.keys(this.inputLookup).length)), (!Array.isArray(t.output) || typeof t.output[0] != "number") && (this.outputLookup = dt.addKeys(t.output, (i = this.outputLookup) !== null && i !== void 0 ? i : {}), this.outputLookup && (this.outputLookupLength = Object.keys(this.outputLookup).length));
                }
                test(t) {
                    const { preparedData: e } = this.prepTraining(t), i = e[0].output.length === 1, h = [];
                    let u = 0;
                    if (i) {
                        let p = 0, d = 0, l = 0, a = 0;
                        for(let o = 0; o < e.length; o++){
                            const n = this.runInput(e[o].input), r = e[o].output, m = n[0] > this.options.binaryThresh ? 1 : 0, b = r[0];
                            if (m !== b) {
                                const E = e[o];
                                h.push({
                                    input: E.input,
                                    output: E.output,
                                    actual: m,
                                    expected: b
                                });
                            }
                            m === 0 && b === 0 ? a++ : m === 1 && b === 1 ? l++ : m === 0 && b === 1 ? d++ : m === 1 && b === 0 && p++, u += Ke(n.map((E, w)=>r[w] - E));
                        }
                        return {
                            error: u / e.length,
                            misclasses: h,
                            total: e.length,
                            trueNeg: a,
                            truePos: l,
                            falseNeg: d,
                            falsePos: p,
                            precision: l > 0 ? l / (l + p) : 0,
                            recall: l > 0 ? l / (l + d) : 0,
                            accuracy: (a + l) / e.length
                        };
                    }
                    for(let p = 0; p < e.length; p++){
                        const d = this.runInput(e[p].input), l = e[p].output, a = d.indexOf(oi(d)), o = l.indexOf(oi(l));
                        if (a !== o) {
                            const n = e[p];
                            h.push({
                                input: n.input,
                                output: n.output,
                                actual: a,
                                expected: o
                            });
                        }
                        u += Ke(d.map((n, r)=>l[r] - n));
                    }
                    return {
                        error: u / e.length,
                        misclasses: h,
                        total: e.length
                    };
                }
                toJSON() {
                    var t, e;
                    this.isRunnable || this.initialize();
                    const i = this.weights.map((d)=>d.map((l)=>Array.from(l))), h = this.biases.map((d)=>Array.from(d)), u = [], p = this.sizes.length - 1;
                    for(let d = 0; d <= p; d++)u.push({
                        weights: (t = i[d]) !== null && t !== void 0 ? t : [],
                        biases: (e = h[d]) !== null && e !== void 0 ? e : []
                    });
                    return {
                        type: "NeuralNetwork",
                        sizes: [
                            ...this.sizes
                        ],
                        layers: u,
                        inputLookup: this.inputLookup ? {
                            ...this.inputLookup
                        } : null,
                        inputLookupLength: this.inputLookupLength,
                        outputLookup: this.outputLookup ? {
                            ...this.outputLookup
                        } : null,
                        outputLookupLength: this.outputLookupLength,
                        options: {
                            ...this.options
                        },
                        trainOpts: this.getTrainOptsJSON()
                    };
                }
                fromJSON(t) {
                    if (this.options = {
                        ...Ci(),
                        ...t.options
                    }, t.hasOwnProperty("trainOpts")) {
                        const u = {
                            ...t.trainOpts,
                            timeout: t.trainOpts.timeout === "Infinity" ? 1 / 0 : t.trainOpts.timeout
                        };
                        this.updateTrainingOptions(u);
                    }
                    this.sizes = t.sizes, this.initialize(), this.inputLookup = t.inputLookup ? {
                        ...t.inputLookup
                    } : null, this.inputLookupLength = t.inputLookupLength, this.outputLookup = t.outputLookup ? {
                        ...t.outputLookup
                    } : null, this.outputLookupLength = t.outputLookupLength;
                    const e = t.layers, i = this.weights.map((u, p)=>e[p].weights.map((d)=>Float32Array.from(d))), h = this.biases.map((u, p)=>Float32Array.from(e[p].biases));
                    for(let u = 0; u <= this.outputLayer; u++)this.weights[u] = i[u] || [], this.biases[u] = h[u] || [];
                    return this;
                }
                toFunction(t) {
                    const { activation: e, leakyReluAlpha: i } = this.trainOpts;
                    let h = !1;
                    const u = (n, r)=>{
                        if (n === 0) return `(input[${r}]||0)`;
                        const m = this.weights[n][r], b = this.biases[n][r];
                        if (!m) throw new Error(`weights at layerIndex ${n} & nodeIndex ${r} not found`);
                        if (!b) throw new Error(`bias as layerIndex ${n} & nodeIndex ${r} not found`);
                        const E = [];
                        m.forEach((v, y)=>{
                            v < 0 ? E.push(`${v}*${u(n - 1, y)}`) : E.push(`+${v}*${u(n - 1, y)}`);
                        });
                        const w = `(${b.toString()}${E.join("")})`;
                        switch(e){
                            case "sigmoid":
                                return `1/(1+1/Math.exp(${w}))`;
                            case "relu":
                                return h = !0, `((v=${w})<0?0:v)`;
                            case "leaky-relu":
                                return h = !0, `Math.max((v=${w}),${i}*v)`;
                            case "tanh":
                                return `Math.tanh(${w})`;
                            default:
                                throw new Error(`Unknown activation ${e}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`);
                        }
                    };
                    function p(n) {
                        if (n.find((r)=>r.includes('"'))) throw new Error(`key contains '"', which is not compatible`);
                    }
                    const d = [];
                    let l, a = "";
                    if (this.inputLookup) {
                        const n = Object.keys(this.inputLookup);
                        p(n), a = `input = new Float32Array([${Object.keys(this.inputLookup).map((r)=>`input["${r}"]`).join(",")}]);`;
                    }
                    if (this.sizes.length < 1) throw new Error("No layers");
                    for(let n = 0; n < this.sizes[this.outputLayer]; n++)d.push(u(this.outputLayer, n));
                    if (this.outputLookup) {
                        const n = Object.keys(this.outputLookup);
                        p(n), l = `{${n.map((m, b)=>`"${m}":${d[b]}`).join(",")}}`;
                    } else l = `[${d.join(",")}]`;
                    const o = `${a}${h ? "var v;" : ""}return ${l};`;
                    return new Function("input", t ? t(o) : o);
                }
            }
            let hi = null;
            function Ri(c) {
                hi = c;
            }
            function Z(c, t) {
                let e = hi;
                return e === null && (e = new wt.GPU({
                    mode: "gpu"
                }), Ri(e)), e.createKernel(c, t).setPipeline(!0);
            }
            function Le(c, t, e) {
                let i = hi;
                return i === null && (i = new wt.GPU({
                    mode: "gpu"
                }), Ri(i)), i.createKernelMap(c, t, e).setPipeline(!0);
            }
            function dn(c, t) {
                return new wt.Input(c, t);
            }
            function X(c) {
                c instanceof wt.Texture && c.delete();
            }
            function gn(c) {
                if (c instanceof wt.Texture) {
                    c.clear();
                    return;
                }
                if (Array.isArray(c)) {
                    if (typeof c[0] == "number") c.fill(0);
                    else if (typeof c[0][0] == "number") {
                        for(let t = 0; t < c.length; t++)c[t].fill(0);
                        return;
                    } else if (typeof c[0][0][0] == "number") {
                        for(let t = 0; t < c.length; t++){
                            const e = c[t];
                            for(let i = 0; i < e.length; i++)e[i].fill(0);
                        }
                        return;
                    }
                }
                if (c instanceof Float32Array) {
                    c.fill(0);
                    return;
                }
                throw new Error("unhandled value");
            }
            function Xt(c) {
                if (c instanceof wt.Texture) return c.clone();
                if (c instanceof Float32Array) return c.slice(0);
                if (Array.isArray(c)) {
                    if (typeof c[0] == "number") return c.slice(0);
                    if (typeof c[0][0] == "number") {
                        const t = new Array(c.length);
                        for(let e = 0; e < c.length; e++)t[e] = c[e].slice(0);
                        return t;
                    } else if (typeof c[0][0][0] == "number") {
                        const t = new Array(c.length);
                        for(let e = 0; e < c.length; e++){
                            const i = c[e], h = new Array(i.length);
                            for(let u = 0; u < i.length; u++)h[u] = i[u].slice(0);
                        }
                        return t;
                    }
                }
                throw new Error("unhandled value");
            }
            function mn(c, t, e) {
                let i = t[this.thread.x];
                for(let h = 0; h < this.constants.size; h++)i += c[this.thread.x][h] * e[h];
                return 1 / (1 + Math.exp(-i));
            }
            function yn(c, t, e) {
                let i = t[this.thread.x];
                for(let h = 0; h < this.constants.size; h++)i += c[this.thread.x][h] * e[h];
                return i < 0 ? 0 : i;
            }
            function xn(c, t, e) {
                let i = t[this.thread.x];
                for(let h = 0; h < this.constants.size; h++)i += c[this.thread.x][h] * e[h];
                return i < 0 ? 0 : .01 * i;
            }
            function bn(c, t, e) {
                let i = t[this.thread.x];
                for(let h = 0; h < this.constants.size; h++)i += c[this.thread.x][h] * e[h];
                return Math.tanh(i);
            }
            function Fi(c, t) {
                return t - c;
            }
            function wn(c, t) {
                return c * t * (1 - t);
            }
            function Tn(c, t) {
                return t > 0 ? c : 0;
            }
            function Sn(c, t) {
                return t > 0 ? c : .01 * c;
            }
            function vn(c, t) {
                return (1 - t * t) * c;
            }
            function Mi(c, t, e, i) {
                let h = 0;
                for(let u = 0; u < t; u++)h += i[u] * e[u][c];
                return h;
            }
            function zi(c, t, e, i, h) {
                return c * i * h + t * e;
            }
            function Pi(c, t) {
                return c + t;
            }
            function _n(c, t) {
                return c[this.thread.x] + t[this.thread.x] * this.constants.learningRate;
            }
            function En(c) {
                let t = 0;
                for(let e = 0; e < this.constants.size; e++)t += c[e] ** 2;
                return t / this.constants.size;
            }
            class Ge extends ui {
                constructor(t = {}){
                    super(t), this.texturizeInputData = ()=>{
                        throw new Error("not yet setup");
                    }, this.forwardPropagate = [], this.backwardPropagate = [], this.changesPropagate = [], this.biasesPropagate = [], this.getMSE = ()=>{
                        throw new Error("not yet setup");
                    }, this._addMSE = ()=>{
                        throw new Error("not yet setup");
                    }, this._divideMSESum = ()=>{
                        throw new Error("not yet setup");
                    }, this.outputs = [], this.deltas = [], this.errors = [], this.weights = [], this.changes = [], this.biases = [], this.runInput = (e)=>{
                        let i;
                        this.outputs[0] = e;
                        for(let h = 1; h <= this.outputLayer; h++)X(this.outputs[h]), this.outputs[h] = this.forwardPropagate[h](this.weights[h], this.biases[h], e), i = e = this.outputs[h];
                        return i;
                    }, this.calculateDeltas = (e)=>{
                        for(let i = this.outputLayer; i > 0; i--){
                            X(this.deltas[i]), X(this.errors[i]);
                            let h;
                            i === this.outputLayer ? h = this.backwardPropagate[i](this.outputs[i], e) : h = this.backwardPropagate[i](this.weights[i + 1], this.outputs[i], this.deltas[i + 1]), this.deltas[i] = h.result, this.errors[i] = h.error;
                        }
                    }, this.errorCheckInterval = 100, this.gpu = new wt.GPU({
                        mode: t.mode
                    });
                }
                initialize() {
                    super.initialize(), this.buildRunInput(), this.buildCalculateDeltas(), this.buildGetChanges(), this.buildChangeBiases(), this.buildGetMSE();
                }
                setActivation() {}
                trainPattern(t, e) {
                    return this.runInput(t.input), this.calculateDeltas(t.output), this.adjustWeights(), e ? this.getMSE(this.errors[this.outputLayer]) : null;
                }
                calculateTrainingError(t) {
                    let e = new Float32Array([
                        0
                    ]);
                    for(let h = 0; h < t.length; ++h){
                        const u = e, p = this.trainPattern(t[h], !0);
                        e = this._addMSE(e, p), X(p), X(u);
                    }
                    const i = this._divideMSESum(t.length, e);
                    return X(e), (i instanceof wt.Texture ? i.toArray() : i)[0];
                }
                adjustWeights() {
                    this.getChanges(), this.changeBiases();
                }
                buildRunInput() {
                    let t = null;
                    switch(this.trainOpts.activation){
                        case "sigmoid":
                            t = mn;
                            break;
                        case "relu":
                            t = yn;
                            break;
                        case "leaky-relu":
                            t = xn;
                            break;
                        case "tanh":
                            t = bn;
                            break;
                        default:
                            throw new Error(`Unknown activation ${this.trainOpts.activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`);
                    }
                    for(let e = 1; e <= this.outputLayer; e++)this.forwardPropagate[e] = this.gpu.createKernel(t, {
                        output: [
                            this.sizes[e]
                        ],
                        pipeline: !0,
                        constants: {
                            size: this.sizes[e - 1]
                        },
                        immutable: !0
                    });
                    this.texturizeInputData = this.gpu.createKernel(function(e) {
                        return e[this.thread.x];
                    }, {
                        output: [
                            this.sizes[1]
                        ],
                        pipeline: !0,
                        immutable: !0
                    });
                }
                buildCalculateDeltas() {
                    let t;
                    switch(this.trainOpts.activation){
                        case "sigmoid":
                            t = wn;
                            break;
                        case "relu":
                            t = Tn;
                            break;
                        case "leaky-relu":
                            t = Sn;
                            break;
                        case "tanh":
                            t = vn;
                            break;
                        default:
                            throw new Error(`Unknown activation ${this.trainOpts.activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`);
                    }
                    t = wt.alias(wt.utils.getMinifySafeName(()=>t), t), this.gpu.addFunction(t);
                    for(let e = this.outputLayer; e > 0; e--)e === this.outputLayer ? this.backwardPropagate[this.outputLayer] = this.gpu.createKernelMap({
                        error: Fi
                    }, function(i, h) {
                        const u = i[this.thread.x], p = h[this.thread.x];
                        return t(Fi(u, p), u);
                    }, {
                        output: [
                            this.sizes[this.outputLayer]
                        ],
                        pipeline: !0,
                        immutable: !0
                    }) : this.backwardPropagate[e] = this.gpu.createKernelMap({
                        error: Mi
                    }, function(i, h, u) {
                        const p = h[this.thread.x];
                        return t(Mi(this.thread.x, this.constants.size, i, u), p);
                    }, {
                        output: [
                            this.sizes[e]
                        ],
                        pipeline: !0,
                        constants: {
                            size: this.sizes[e + 1]
                        },
                        immutable: !0
                    });
                }
                buildGetChanges() {
                    for(let t = 1; t <= this.outputLayer; t++)this.changesPropagate[t] = this.gpu.createKernelMap({
                        weights: Pi,
                        changes: zi
                    }, function(e, i, h, u) {
                        const p = zi(this.constants.learningRate, this.constants.momentum, u[this.thread.y][this.thread.x], i[this.thread.y], e[this.thread.x]);
                        return Pi(p, h[this.thread.y][this.thread.x]);
                    }, {
                        output: [
                            this.sizes[t - 1],
                            this.sizes[t]
                        ],
                        pipeline: !0,
                        constants: {
                            size: this.sizes[t - 1],
                            learningRate: this.trainOpts.learningRate,
                            momentum: this.trainOpts.momentum
                        },
                        immutable: !0
                    });
                }
                getChanges() {
                    for(let t = 1; t <= this.outputLayer; t++){
                        const e = this.weights[t], i = this.changes[t], h = this.changesPropagate[t](this.outputs[t - 1], this.deltas[t], e, i);
                        X(e), X(i), this.weights[t] = h.weights, this.changes[t] = h.changes, X(h.result);
                    }
                }
                buildChangeBiases() {
                    for(let t = 1; t <= this.outputLayer; t++)this.biasesPropagate[t] = this.gpu.createKernel(_n, {
                        output: [
                            this.sizes[t]
                        ],
                        pipeline: !0,
                        constants: {
                            learningRate: this.trainOpts.learningRate
                        },
                        immutable: !0
                    });
                }
                changeBiases() {
                    for(let t = 1; t <= this.outputLayer; t++){
                        const e = this.biases[t];
                        this.biases[t] = this.biasesPropagate[t](e, this.deltas[t]), X(e);
                    }
                }
                buildGetMSE() {
                    this.getMSE = this.gpu.createKernel(En, {
                        output: [
                            1
                        ],
                        constants: {
                            size: this.sizes[this.outputLayer]
                        },
                        pipeline: !0,
                        immutable: !0
                    }), this._addMSE = this.gpu.createKernel(function(t, e) {
                        return t[0] + e[0];
                    }, {
                        output: [
                            1
                        ],
                        pipeline: !0,
                        immutable: !0
                    }), this._divideMSESum = this.gpu.createKernel(function(t, e) {
                        const i = e[0];
                        return i > 0 ? i / t : 0;
                    }, {
                        output: [
                            1
                        ]
                    });
                }
                run(t) {
                    if (!this.isRunnable) throw new Error("network not runnable");
                    let e;
                    this.inputLookup ? e = dt.toArray(this.inputLookup, t, this.inputLookupLength) : e = t, this.validateInput(e);
                    const i = this.runInput(e), h = i instanceof wt.Texture ? i.toArray() : i;
                    return this.outputLookup ? dt.toObject(this.outputLookup, h) : h;
                }
                prepTraining(t, e = {}) {
                    this.updateTrainingOptions(e);
                    const i = this.formatData(t), h = Date.now() + this.trainOpts.timeout, u = {
                        error: 1,
                        iterations: 0
                    };
                    this.verifyIsInitialized(i);
                    const p = this.gpu.createKernel(function(d) {
                        return d[this.thread.x];
                    }, {
                        output: [
                            i[0].output.length
                        ],
                        pipeline: !0,
                        immutable: !0
                    });
                    return {
                        preparedData: i.map((d)=>({
                                input: this.texturizeInputData(d.input),
                                output: p(d.output)
                            })),
                        status: u,
                        endTime: h
                    };
                }
                toFunction() {
                    throw new Error(`${this.constructor.name}-toFunction is not yet implemented`);
                }
                toJSON() {
                    var t, e;
                    this.sizes === null && this.initialize();
                    const i = this.weights.map((p)=>(p instanceof wt.Texture ? p.toArray() : p).map((d)=>Array.from(d))), h = this.biases.map((p)=>Array.from(p instanceof wt.Texture ? p.toArray() : p)), u = [];
                    for(let p = 0; p <= this.outputLayer; p++)u.push({
                        weights: (t = i[p]) !== null && t !== void 0 ? t : [],
                        biases: (e = h[p]) !== null && e !== void 0 ? e : []
                    });
                    return {
                        type: "NeuralNetworkGPU",
                        sizes: [
                            ...this.sizes
                        ],
                        layers: u,
                        inputLookup: this.inputLookup ? {
                            ...this.inputLookup
                        } : null,
                        inputLookupLength: this.inputLookupLength,
                        outputLookup: this.outputLookup ? {
                            ...this.outputLookup
                        } : null,
                        outputLookupLength: this.outputLookupLength,
                        options: {
                            ...this.options
                        },
                        trainOpts: this.getTrainOptsJSON()
                    };
                }
            }
            class Ni extends Error {
                constructor(t){
                    super(`Cannot run a ${t.constructor.name} before it is trained.`);
                }
            }
            class kn {
                constructor(t){
                    t ?? (t = {}), t.binaryThresh, t.hiddenLayers, t.decodedSize && t.decodedSize, this.denoiser = new Ge(t);
                }
                denoise(t) {
                    return this.denoiser.run(t);
                }
                decode(t) {
                    if (!this.decoder) throw new Ni(this);
                    return this.decoder.run(t);
                }
                encode(t) {
                    if (!this.denoiser) throw new Ni(this);
                    this.denoiser.run(t);
                    let e = this.encodedLayer;
                    return e instanceof wt.Texture ? e = e.toArray() : e = e.slice(0), e;
                }
                likelyIncludesAnomalies(t, e = .2) {
                    var i;
                    const h = [], u = this.denoise(t);
                    for(let l = 0; l < ((i = t.length) !== null && i !== void 0 ? i : 0); l++)h[l] = Math.abs(t[l] - u[l]);
                    return h.reduce((l, a)=>l + a) / t.length > e;
                }
                train(t, e) {
                    const i = [];
                    for (const u of t)i.push({
                        input: u,
                        output: u
                    });
                    const h = this.denoiser.train(i, e);
                    return this.decoder = this.createDecoder(), h;
                }
                createDecoder() {
                    const t = this.denoiser.toJSON(), e = [], i = [];
                    for(let u = this.encodedLayerIndex; u < this.denoiser.sizes.length; u++)e.push(t.layers[u]), i.push(t.sizes[u]);
                    return t.layers = e, t.sizes = i, t.options.inputSize = t.sizes[0], new Ge().fromJSON(t);
                }
                get encodedLayer() {
                    return this.denoiser.outputs[this.encodedLayerIndex];
                }
                get encodedLayerIndex() {
                    return Math.round(this.denoiser.outputs.length * .5) - 1;
                }
            }
            class ue {
                constructor(t){
                    this.json = {
                        avgs: {
                            error: 0,
                            iterations: 0,
                            testTime: 0,
                            trainTime: 0
                        },
                        stats: {
                            total: 0,
                            testSize: 0,
                            trainSize: 0
                        },
                        sets: []
                    }, this.initClassifier = t;
                }
                testPartition(t, e, i) {
                    const h = this.initClassifier(), u = Date.now(), p = h.train(e, t), d = Date.now(), l = h.test(i), a = Date.now();
                    return {
                        ...l,
                        trainTime: d - u,
                        testTime: a - d,
                        iterations: p.iterations,
                        error: p.error,
                        total: l.total,
                        network: h.toJSON()
                    };
                }
                shuffleArray(t) {
                    for(let e = t.length - 1; e > 0; e--){
                        const i = Math.floor(Math.random() * (e + 1)), h = t[e];
                        t[e] = t[i], t[i] = h;
                    }
                    return t;
                }
                train(t, e = {}, i = 4) {
                    if (t.length < i) throw new Error(`Training set size is too small for ${t.length} k folds of ${i}`);
                    this.shuffleArray(t);
                    const h = t.length / i, u = {
                        trainTime: 0,
                        testTime: 0,
                        iterations: 0,
                        error: 0
                    }, p = {
                        total: 0,
                        testSize: 0,
                        trainSize: 0
                    }, d = {
                        total: 0,
                        testSize: 0,
                        trainSize: 0,
                        truePos: 0,
                        trueNeg: 0,
                        falsePos: 0,
                        falseNeg: 0,
                        precision: 0,
                        recall: 0,
                        accuracy: 0
                    }, l = [];
                    let a = null;
                    for(let o = 0; o < i; o++){
                        const n = t.slice(0), r = n.splice(o * h, h), m = n, b = this.testPartition(e, m, r);
                        a === null && (a = b.hasOwnProperty("falseNeg") && b.hasOwnProperty("falsePos") && b.hasOwnProperty("trueNeg") && b.hasOwnProperty("truePos"), a && Object.assign(p, d)), u.iterations += b.iterations, u.testTime += b.testTime, u.trainTime += b.trainTime, u.error += b.error, p.total += b.total, ue.isBinaryStats(p) && ue.isBinaryPartitionResults(b) && (p.accuracy += b.accuracy, p.falseNeg += b.falseNeg, p.falsePos += b.falsePos, p.precision += b.precision, p.recall += b.recall, p.trueNeg += b.trueNeg, p.truePos += b.truePos), l.push(b);
                    }
                    return u.error /= i, u.iterations /= i, u.testTime /= i, u.trainTime /= i, ue.isBinaryStats(p) && (p.precision = p.truePos / (p.truePos + p.falsePos), p.recall = p.truePos / (p.truePos + p.falseNeg), p.accuracy = (p.trueNeg + p.truePos) / p.total), p.testSize = h, p.trainSize = t.length - h, this.json = {
                        avgs: u,
                        stats: p,
                        sets: l
                    }, this.json;
                }
                toNeuralNetwork() {
                    return this.fromJSON(this.json);
                }
                toJSON() {
                    return this.json;
                }
                fromJSON(t) {
                    const e = t.sets.reduce((i, h)=>i.error < h.error ? i : h);
                    return this.initClassifier().fromJSON(e.network);
                }
            }
            ue.isBinaryStats = (c)=>c.accuracy !== void 0, ue.isBinaryResults = (c)=>c.stats.accuracy !== void 0, ue.isBinaryPartitionResults = (c)=>c.accuracy !== void 0;
            function Ln(c) {
                let t = 0;
                for(let e = 0; e < this.constants.height; e++)for(let i = 0; i < this.constants.width; i++)t += c[e][i] ** 2;
                return t / this.constants.length;
            }
            class In {
                constructor({ width: t, height: e }){
                    this.calculate = Z(Ln, {
                        output: [
                            1
                        ],
                        constants: {
                            width: t,
                            height: e,
                            length: t * e
                        },
                        immutable: !0
                    }), this.addAbsolute = Z(function(i, h) {
                        return i[0] + Math.abs(h[0][0]);
                    }, {
                        output: [
                            1
                        ],
                        immutable: !0
                    }), this.add = Z(function(i, h) {
                        return i[0] + h[0];
                    }, {
                        output: [
                            1
                        ],
                        immutable: !0
                    }), this.divide = Z(function(i, h) {
                        const u = h[0];
                        return u > 0 ? u / i : 0;
                    }, {
                        output: [
                            1
                        ],
                        immutable: !0
                    });
                }
            }
            const Ie = {
                width: 1,
                height: 1,
                depth: null,
                weights: null,
                deltas: null,
                praxis: null,
                praxisOpts: null,
                cleanupDeltas: !0
            };
            class Wt {
                constructor(t){
                    this.praxis = null, this.predictKernel = null, this.compareKernel = null, t ? this.settings = {
                        ...Ie,
                        ...t
                    } : this.settings = {
                        ...Ie
                    }, this.setupPraxis();
                }
                get width() {
                    var t;
                    return (t = this.settings.width) !== null && t !== void 0 ? t : 0;
                }
                get height() {
                    var t;
                    return (t = this.settings.height) !== null && t !== void 0 ? t : 0;
                }
                get depth() {
                    var t;
                    return (t = this.settings.depth) !== null && t !== void 0 ? t : 0;
                }
                get weights() {
                    return this.settings.weights;
                }
                set weights(t) {
                    this.settings.weights = t, this.settings.cleanupDeltas && this.deltas && gn(this.deltas);
                }
                get deltas() {
                    return this.settings.deltas;
                }
                set deltas(t) {
                    this.settings.deltas = t;
                }
                get id() {
                    var t;
                    return (t = this.settings.id) !== null && t !== void 0 ? t : "";
                }
                set id(t) {
                    this.settings.id = t;
                }
                setupPraxis() {
                    const { initPraxis: t, praxis: e, praxisOpts: i } = this.settings;
                    this.praxis || (t ? i ? this.praxis = t(this, i) : this.praxis = t(this) : e && (this.praxis = e));
                }
                validate() {
                    if (Number.isNaN(this.height)) throw new Error(`${this.constructor.name} layer height is not a number`);
                    if (Number.isNaN(this.width)) throw new Error(`${this.constructor.name} layer width is not a number`);
                    if (this.height < 1) throw new Error(`${this.constructor.name} layer height is less than 1`);
                    if (this.width < 1) throw new Error(`${this.constructor.name} layer width is less than 1`);
                }
                setupKernels(t) {}
                reuseKernels(t) {
                    if (t.width !== this.width) throw new Error(`${this.constructor.name} kernel width mismatch ${t.width} is not ${this.width}`);
                    if (t.height !== this.height) throw new Error(`${this.constructor.name} kernel width mismatch ${t.height} is not ${this.height}`);
                    if (t.hasOwnProperty("predictKernel") && t.predictKernel !== null) {
                        if (!t.predictKernel.immutable) throw new Error(`${t.constructor.name}.predictKernel is not reusable, set kernel.immutable = true`);
                        this.predictKernel = t.predictKernel;
                    }
                    if (t.hasOwnProperty("compareKernel") && t.compareKernel !== null) {
                        if (!t.compareKernel.immutable) throw new Error(`${t.constructor.name}.compareKernel is not reusable, set kernel.immutable = true`);
                        this.compareKernel = t.compareKernel;
                    }
                    this.praxis = t.praxis;
                }
                predict(t) {}
                compare(t) {}
                learn(t) {}
                toArray() {
                    return Array.isArray(this.weights) ? this.weights : this.weights.toArray();
                }
                toJSON() {
                    return Wt.toJSON(this);
                }
                static toJSON(t) {
                    const { weights: e } = t;
                    return {
                        width: t.width,
                        height: t.height,
                        depth: t.depth,
                        weights: An(e && e instanceof wt.Texture ? e.toArray() : e),
                        type: t.constructor.name,
                        praxisOpts: t.praxis ? t.praxis.toJSON() : null
                    };
                }
            }
            function An(c) {
                if (c === null) return null;
                if (Array.isArray(c)) {
                    if (typeof c[0] == "number") return c;
                    if (Array.isArray(c[0]) && typeof c[0][0] == "number") return c;
                    if (Array.isArray(c[0][0]) && typeof c[0][0][0] == "number") return c;
                    if (c[0] instanceof Float32Array) return c.map((e)=>Array.from(e));
                    if (c[0][0] instanceof Float32Array) return c.map((e)=>e.map((i)=>Array.from(i)));
                } else if (c) return Array.from(c);
                throw new Error("unexpected value");
            }
            function Mt(c, t) {
                const e = new Array(t);
                for(let i = 0; i < t; i++)e[i] = Vt(c);
                return e;
            }
            function de(c, t, e) {
                const i = new Array(e);
                for(let h = 0; h < e; h++)i[h] = Mt(c, t);
                return i;
            }
            class Te extends Wt {
                constructor(t, e){
                    super(e), this.inputLayer = t;
                    const { width: i, height: h, depth: u } = this;
                    this.predictKernel = null, this.compareKernel = null, this.validate(), u > 0 ? (this.weights = de(i, h, u), this.deltas = de(i, h, u)) : h > 0 && (this.weights = Mt(i, h), this.deltas = Mt(i, h)), this.setupPraxis();
                }
                get width() {
                    return this.inputLayer.width;
                }
                get height() {
                    return this.inputLayer.height;
                }
                get depth() {
                    return this.inputLayer.depth;
                }
            }
            class Se extends Wt {
                constructor(t, e){
                    super(), this.settings = t, this.inputLayer = e;
                }
                get width() {
                    return this.inputLayer.width;
                }
                get height() {
                    return this.inputLayer.height;
                }
                get depth() {
                    return this.inputLayer.depth;
                }
                get filterCount() {
                    return this.settings.filterCount;
                }
                get filterWidth() {
                    return this.settings.filterWidth;
                }
                get filterHeight() {
                    return this.settings.filterHeight;
                }
                get filters() {
                    return this.settings.filters;
                }
                set filters(t) {
                    this.settings.filters = t;
                }
                get filterDeltas() {
                    return this.settings.filterDeltas;
                }
                set filterDeltas(t) {
                    this.settings.filterDeltas = t;
                }
            }
            class Ae {
                constructor(){
                    this.predictKernel = null, this.compareKernel = null, this.praxis = null;
                }
                get width() {
                    return this.settings.width;
                }
                get height() {
                    return this.settings.height;
                }
                get depth() {
                    return this.settings.depth;
                }
                get weights() {
                    return this.settings.weights;
                }
                set weights(t) {
                    this.settings.weights = t;
                }
                get deltas() {
                    return this.settings.deltas;
                }
                set deltas(t) {
                    this.settings.deltas = t;
                }
                toJSON() {
                    return Wt.toJSON(this);
                }
            }
            class De extends Wt {
                constructor(t, e){
                    super({
                        ...e,
                        width: t.width,
                        height: t.height,
                        depth: t.depth
                    }), this.inputLayer = t;
                }
                validate() {
                    var t;
                    if (super.validate(), this.width !== this.inputLayer.width) throw new Error(`width of ${this.width} does not match inputLayer.width of ${this.inputLayer.width}`);
                    if (this.height !== this.inputLayer.height) throw new Error(`height of ${this.height} does not match inputLayer.height of ${this.inputLayer.height}`);
                    if (this.depth !== ((t = this.inputLayer.depth) !== null && t !== void 0 ? t : 0)) throw new Error(`depth of ${this.depth} does not match inputLayer.depth of ${this.inputLayer.depth}`);
                }
            }
            class $e extends Wt {
                constructor(t, e, i){
                    super(i), this.inputLayer1 = t, this.inputLayer2 = e, this.validate(), this.weights = Mt(this.width, this.height), this.deltas = Mt(this.width, this.height), this.setupPraxis();
                }
            }
            function Dn(c, t) {
                return c[this.thread.y][this.thread.x] - t[this.thread.x];
            }
            function $n(c, t) {
                return c[this.thread.y][this.thread.x] - t[this.thread.y][this.thread.x];
            }
            class Oe extends Wt {
                constructor(t, e){
                    if (super(t), this.inputLayer = e, this.validate(), this.depth) throw new Error("Target layer not implemented for depth");
                    this.height ? (this.weights = Mt(this.width, this.height), this.deltas = Mt(this.width, this.height), this.errors = Mt(this.width, this.height)) : (this.weights = Vt(this.width), this.deltas = Vt(this.width), this.errors = Vt(this.width));
                }
                setupKernels() {
                    this.width === 1 ? this.compareKernel = Z(Dn, {
                        output: [
                            this.width,
                            this.height
                        ],
                        immutable: !0
                    }) : this.compareKernel = Z($n, {
                        output: [
                            this.width,
                            this.height
                        ],
                        immutable: !0
                    });
                }
                predict() {
                    X(this.weights), this.weights = Xt(this.inputLayer.weights);
                }
                compare(t) {
                    X(this.deltas), X(this.errors), X(this.inputLayer.deltas), this.deltas = this.compareKernel(this.weights, t), this.inputLayer.deltas = Xt(this.deltas), this.errors = Xt(this.deltas);
                }
                setupPraxis() {}
            }
            function Vi(c, t) {
                return new Oe(c, t);
            }
            class li {
            }
            class ci extends Wt {
            }
            class he extends Wt {
                learn(t) {
                    const { weights: e } = this;
                    if (!this.praxis) throw new Error("this.praxis not defined");
                    this.weights = this.praxis.run(this, t), X(e);
                }
            }
            class pi {
                constructor(t, e = {}){
                    this.layerTemplate = t, this.settings = {
                        ...e
                    }, this.kernel = null;
                }
                get width() {
                    return this.layerTemplate.width;
                }
                get height() {
                    return this.layerTemplate.height;
                }
                get depth() {
                    return this.layerTemplate.depth;
                }
                setupKernels() {}
                reuseKernels(t) {
                    if (t.width !== this.width) throw new Error(`${this.constructor.name} kernel width mismatch ${t.width} is not ${this.width}`);
                    if (t.height !== this.height) throw new Error(`${this.constructor.name} kernel width mismatch ${t.height} is not ${this.height}`);
                    t.hasOwnProperty("kernel") && (this.kernel = t.kernel);
                }
                toJSON() {
                    return {
                        ...this.settings
                    };
                }
            }
            function On(c, t) {
                return c[this.thread.y][this.thread.x] + this.constants.learningRate * t[this.thread.y][this.thread.x];
            }
            const Cn = {
                learningRate: .3
            };
            class Ki extends pi {
                constructor(t, e){
                    super(t), this.settings = {
                        ...Cn,
                        ...e
                    }, this.kernel = null;
                }
                run(t) {
                    return this.kernel(t.weights, t.deltas);
                }
                setupKernels() {
                    var t;
                    this.kernel = Z(On, {
                        output: [
                            this.width,
                            this.height
                        ],
                        constants: {
                            learningRate: (t = this.settings.learningRate) !== null && t !== void 0 ? t : .01
                        }
                    });
                }
            }
            function Gi(c, t) {
                return new Ki(c, t);
            }
            function Rn(c) {
                return c;
            }
            function Fn(c, t, e, i) {
                const h = c[this.thread.y][this.thread.x], u = i[this.thread.y][0], p = t[this.thread.y][this.thread.x], d = e[this.thread.x][0], l = this.constants.learningRate * u * d + this.constants.momentum * h;
                return p + l;
            }
            const Mn = {
                learningRate: .3,
                momentum: .1,
                weightsLayer: null,
                incomingLayer: null,
                deltaLayer: null
            };
            class Ui extends pi {
                constructor(t, e){
                    super(t), this.kernelMap = null, this.settings = {
                        ...Mn,
                        ...e
                    }, this.changes = Mt(t.width, t.height);
                }
                get learningRate() {
                    return this.settings.learningRate;
                }
                get momentum() {
                    return this.settings.momentum;
                }
                get weightsLayer() {
                    return this.settings.weightsLayer;
                }
                set weightsLayer(t) {
                    this.settings.weightsLayer = t;
                }
                get deltaLayer() {
                    return this.settings.deltaLayer;
                }
                set deltaLayer(t) {
                    this.settings.deltaLayer = t;
                }
                get incomingLayer() {
                    return this.settings.incomingLayer;
                }
                set incomingLayer(t) {
                    this.settings.incomingLayer = t;
                }
                run() {
                    const t = this.kernelMap(this.changes, this.weightsLayer.weights, this.incomingLayer.weights, this.deltaLayer.deltas);
                    return this.changes = t.changes, t.result;
                }
                setupKernels() {
                    this.kernelMap = Le({
                        changes: Rn
                    }, Fn, {
                        output: [
                            this.width,
                            this.height
                        ],
                        constants: {
                            learningRate: this.learningRate,
                            momentum: this.momentum
                        }
                    });
                }
            }
            function Bi(c, t) {
                return new Ui(c, t);
            }
            function Wi(c, t, e) {
                return e * t + (1 - t) * c * c;
            }
            function ji(c, t, e) {
                return c > t ? t : c < e ? e : c;
            }
            function zn(c, t, e) {
                const i = t[this.thread.y][this.thread.x], h = ji(i, this.constants.clipValue, -this.constants.clipValue), u = c[this.thread.y][this.thread.x], p = e[this.thread.y][this.thread.x], d = Wi(i, this.constants.decayRate, p);
                return u + -this.constants.learningRate * h / Math.sqrt(d + this.constants.smoothEps) - this.constants.regularizationStrength * u;
            }
            const Pn = {
                decayRate: .999,
                regularizationStrength: 1e-6,
                learningRate: .01,
                smoothEps: 1e-8,
                clipValue: 5
            };
            class fi extends pi {
                constructor(t, e = {}){
                    super(t), this.kernelMap = null, this.settings = {
                        ...Pn,
                        ...e
                    }, this.momenta = Mt(t.width, t.height);
                }
                get clipValue() {
                    return this.settings.clipValue;
                }
                get decayRate() {
                    return this.settings.decayRate;
                }
                get learningRate() {
                    return this.settings.learningRate;
                }
                get regularizationStrength() {
                    return this.settings.regularizationStrength;
                }
                get smoothEps() {
                    return this.settings.smoothEps;
                }
                run(t) {
                    const { momenta: e, result: i } = this.kernelMap(t.weights, t.deltas, this.momenta);
                    return X(this.momenta), this.momenta = e, i;
                }
                setupKernels() {
                    this.kernelMap = Le({
                        momenta: Wi
                    }, zn, {
                        output: [
                            this.width,
                            this.height
                        ],
                        constants: {
                            clipValue: this.clipValue,
                            decayRate: this.decayRate,
                            learningRate: this.learningRate,
                            regularizationStrength: this.regularizationStrength,
                            smoothEps: this.smoothEps
                        },
                        functions: [
                            ji
                        ],
                        immutable: !0
                    });
                }
            }
            function di(c, t) {
                return new fi(c, t);
            }
            var Nn = Object.freeze({
                __proto__: null,
                ArthurDeviationBiases: Ki,
                arthurDeviationBiases: Gi,
                ArthurDeviationWeights: Ui,
                arthurDeviationWeights: Bi,
                MomentumRootMeanSquaredPropagation: fi,
                momentumRootMeanSquaredPropagation: di,
                MRmsProp: fi,
                mRmsProp: di
            });
            function Ue(c, t) {
                c.hasOwnProperty("inputLayer") ? Ue(c.inputLayer, t) : (c.hasOwnProperty("inputLayer1") && Ue(c.inputLayer1, t), c.hasOwnProperty("inputLayer2") && Ue(c.inputLayer2, t)), t(c);
            }
            function Hi(c) {
                const t = c.slice(0);
                for(let e = 0; e < t.length; e++){
                    let i = 0;
                    Ue(t[e], (h)=>{
                        t.includes(h) || (t.splice(e + i, 0, h), i++);
                    });
                }
                return t;
            }
            function Xi(c, t) {
                if (c.width !== t.width) throw new Error(`Layer width mismatch of ${c.width} and ${t.width}`);
                if (c.height !== t.height) throw new Error(`Layer height mismatch of ${c.height} and ${t.height}`);
            }
            function Vn(c, t) {
                return c[this.thread.y][this.thread.x] + t[this.thread.y][this.thread.x];
            }
            class Yi extends $e {
                get width() {
                    return this.inputLayer1.width;
                }
                get height() {
                    return this.inputLayer1.height;
                }
                get depth() {
                    return this.inputLayer1.depth;
                }
                validate() {
                    super.validate(), Xi(this.inputLayer1, this.inputLayer2);
                }
                setupKernels() {
                    this.predictKernel = Z(Vn, {
                        output: [
                            this.width,
                            this.height
                        ],
                        immutable: !0
                    });
                }
                predict() {
                    X(this.weights), this.weights = this.predictKernel(this.inputLayer1.weights, this.inputLayer2.weights);
                }
                compare() {
                    X(this.inputLayer1.deltas), X(this.inputLayer2.deltas), this.inputLayer1.deltas = Xt(this.deltas), this.inputLayer2.deltas = Xt(this.deltas);
                }
            }
            function $t(c, t, e) {
                return new Yi(c, t, e);
            }
            const Kn = {
                ...Ie,
                std: null
            };
            class Ji extends he {
                constructor(t){
                    super(), this.settings = {
                        ...Kn,
                        ...t
                    }, this.setupPraxis(), this.validate(), this.weights || (this.weights = Ee(this.width, this.height, t.std)), this.deltas || (this.deltas = Mt(this.width, this.height));
                }
                predict() {}
                compare() {}
            }
            function Ot(c) {
                return new Ji(c);
            }
            function Gn(c, t) {
                let e = 0;
                for(let i = 0; i < this.constants.size; i++)e += c[this.thread.y][i] * t[i][this.thread.x];
                return e;
            }
            function Un(c, t, e) {
                let i = t[this.thread.y][this.thread.x];
                for(let h = 0; h < this.constants.size; h++)i += c[this.thread.y][h] * e[this.thread.x][h];
                return i;
            }
            function Bn(c, t, e) {
                let i = t[this.thread.y][this.thread.x];
                for(let h = 0; h < this.constants.size; h++)i += c[h][this.thread.x] * e[h][this.thread.y];
                return i;
            }
            class Zi extends $e {
                constructor(){
                    super(...arguments), this.compareKernel1 = null, this.compareKernel2 = null;
                }
                get width() {
                    return this.inputLayer2.width;
                }
                set width(t) {
                    throw new Error("Cannot set width on Multiply");
                }
                get height() {
                    return this.inputLayer1.height;
                }
                set height(t) {
                    throw new Error("Cannot set height on Multiply");
                }
                get depth() {
                    return this.inputLayer1.depth;
                }
                set depth(t) {
                    throw new Error("Cannot set depth on Multiply");
                }
                validate() {
                    if (super.validate(), this.inputLayer1.width !== this.inputLayer2.height) throw new Error(`Layer width mismatch of ${this.inputLayer1.width} and ${this.inputLayer2.height}`);
                }
                setupKernels() {
                    this.predictKernel = Z(Gn, {
                        output: [
                            this.width,
                            this.height
                        ],
                        constants: {
                            size: this.inputLayer2.height
                        },
                        immutable: !0
                    }), this.compareKernel1 = Z(Un, {
                        output: [
                            this.inputLayer1.width,
                            this.inputLayer1.height
                        ],
                        constants: {
                            size: this.inputLayer2.width
                        },
                        immutable: !0
                    }), this.compareKernel2 = Z(Bn, {
                        output: [
                            this.inputLayer2.width,
                            this.inputLayer2.height
                        ],
                        constants: {
                            size: this.inputLayer1.height
                        },
                        immutable: !0
                    });
                }
                reuseKernels(t) {
                    super.reuseKernels(t), this.compareKernel1 = t.compareKernel1, this.compareKernel2 = t.compareKernel2;
                }
                predict() {
                    if (X(this.weights), !this.predictKernel) throw new Error("this.predictKernel is not set");
                    this.weights = this.predictKernel(this.inputLayer1.weights, this.inputLayer2.weights);
                }
                compare() {
                    if (!this.compareKernel1) throw new Error("this.compareKernel1 not set");
                    if (!this.compareKernel2) throw new Error("this.compareKernel2 not set");
                    const t = this.inputLayer1.deltas, e = this.inputLayer2.deltas, i = this.compareKernel1(this.deltas, this.inputLayer1.deltas, this.inputLayer2.weights), h = this.compareKernel2(this.deltas, this.inputLayer2.deltas, this.inputLayer1.weights);
                    this.inputLayer2.deltas = h, this.inputLayer1.deltas = i, X(t), X(e);
                }
                setupPraxis() {}
                toJSON() {
                    return {
                        ...super.toJSON(),
                        width: this.width,
                        height: this.height
                    };
                }
            }
            function zt(c, t, e) {
                return new Zi(c, t, e);
            }
            function Wn(c) {
                return 1 / (1 + Math.exp(-c[this.thread.y][this.thread.x]));
            }
            function jn(c) {
                return 1 / (1 + Math.exp(-c[this.thread.z][this.thread.y][this.thread.x]));
            }
            function Hn(c, t) {
                const e = c[this.thread.y][this.thread.x], i = t[this.thread.y][this.thread.x];
                return e * (1 - e) * i;
            }
            function Xn(c, t) {
                const e = c[this.thread.z][this.thread.y][this.thread.x], i = t[this.thread.z][this.thread.y][this.thread.x];
                return e * (1 - e) * i;
            }
            class qi extends Te {
                setupKernels() {
                    this.depth > 0 ? (this.predictKernel = Z(jn, {
                        output: [
                            this.width,
                            this.height,
                            this.depth
                        ],
                        functions: [
                            H
                        ],
                        immutable: !0
                    }), this.compareKernel = Z(Xn, {
                        output: [
                            this.width,
                            this.height,
                            this.depth
                        ],
                        functions: [
                            Y
                        ],
                        immutable: !0
                    })) : (this.predictKernel = Z(Wn, {
                        output: [
                            this.width,
                            this.height
                        ],
                        functions: [
                            H
                        ],
                        immutable: !0
                    }), this.compareKernel = Z(Hn, {
                        output: [
                            this.width,
                            this.height
                        ],
                        functions: [
                            Y
                        ],
                        immutable: !0
                    }));
                }
                predict() {
                    X(this.weights), this.weights = this.predictKernel(this.inputLayer.weights);
                }
                compare() {
                    X(this.inputLayer.deltas), this.inputLayer.deltas = this.compareKernel(this.weights, this.deltas);
                }
                learn(t) {}
            }
            function le(c, t) {
                return new qi(c, t);
            }
            function Yn(c, t) {
                const { height: e } = c;
                function i(n, r) {
                    const m = Bi(n, r);
                    return m.setupKernels(), m;
                }
                function h(n, r) {
                    const m = Gi(n, r);
                    return m.setupKernels(), m;
                }
                const u = Ot({
                    id: "weights",
                    height: e,
                    width: t.height,
                    initPraxis: i
                }), p = Ot({
                    id: "biases",
                    height: e,
                    initPraxis: h
                }), d = zt(u, t), l = $t(d, p), a = le(l), o = u.praxis;
                return o.weightsLayer = u, o.incomingLayer = t, o.deltaLayer = a, a;
            }
            function Qi(c, t) {
                if (typeof c.stride == "number") return {
                    strideX: c.stride,
                    strideY: c.stride
                };
                {
                    let e = t.stride, i = t.stride;
                    return typeof c.strideX == "number" && (e = c.strideX), typeof c.strideY == "number" && (i = c.strideY), {
                        strideX: e,
                        strideY: i
                    };
                }
            }
            function ts(c, t) {
                if (typeof c.padding == "number") return {
                    paddingX: c.padding,
                    paddingY: c.padding
                };
                {
                    let e = t.padding, i = t.padding;
                    return typeof c.paddingX == "number" && (e = c.paddingX), typeof c.paddingY == "number" && (i = c.paddingY), {
                        paddingX: e,
                        paddingY: i
                    };
                }
            }
            function es(c, t) {
                return new Float32Array(c).fill(t);
            }
            function Jn(c, t, e) {
                const i = this.constants.paddingX - this.thread.x * this.constants.strideX, h = this.thread.x * this.constants.strideX - this.constants.paddingX, u = Math.min(this.constants.filterWidth, i + this.constants.inputWidth), p = this.constants.paddingY - this.thread.y * this.constants.strideY, d = this.thread.y * this.constants.strideY - this.constants.paddingY, l = Math.min(this.constants.filterHeight, p + this.constants.inputHeight);
                let a = 0;
                for(let o = 0; o < this.constants.inputDepth; o++)for(let n = Math.max(0, p), r = Math.max(0, d); n < l; n++, r++)for(let m = Math.max(0, i), b = Math.max(0, h); m < u; m++, b++)a += t[o][n][m] * c[o][r][b];
                return a + e[this.thread.z];
            }
            function Zn(c, t, e) {
                const i = Math.max(0, Math.ceil((this.constants.paddingX - this.thread.x) / this.constants.strideX)), h = i * this.constants.strideX + this.thread.x - this.constants.paddingX, u = Math.min(this.constants.deltaWidth, Math.floor((this.constants.inputWidth - 1 - this.thread.x + this.constants.paddingX) / this.constants.strideX) + 1), p = Math.max(0, Math.ceil((this.constants.paddingY - this.thread.y) / this.constants.strideY)), d = p * this.constants.strideY + this.thread.y - this.constants.paddingY, l = Math.min(this.constants.deltaHeight, Math.floor((this.constants.inputHeight - 1 - this.thread.y + this.constants.paddingY) / this.constants.strideY) + 1);
                let a = c[this.thread.z][this.thread.y][this.thread.x];
                for(let o = p, n = d; o < l; o++, n += this.constants.strideY)for(let r = i, m = h; r < u; r++, m += this.constants.strideX)a += t[this.thread.z][n][m] * e[this.constants.deltaZ][o][r];
                return a;
            }
            function qn(c, t, e) {
                const i = this.thread.x + this.constants.paddingX, h = i < this.constants.filterWidth ? 0 : Math.floor((i - this.constants.filterWidth + this.constants.strideX) / this.constants.strideX), u = i - h * this.constants.strideX, p = Math.min(h + Math.floor(u / this.constants.strideX) + 1, this.constants.deltaWidth), d = this.thread.y + this.constants.paddingY, l = d < this.constants.filterHeight ? 0 : Math.floor((d - this.constants.filterHeight + this.constants.strideY) / this.constants.strideY), a = d - l * this.constants.strideY, o = Math.min(l + Math.floor(a / this.constants.strideY) + 1, this.constants.deltaHeight);
                let n = c[this.thread.z][this.thread.y][this.thread.x], r = l;
                for(let m = a; r < o; m -= this.constants.strideY, r++){
                    let b = h;
                    for(let E = u; b < p; E -= this.constants.strideX, b++)n += t[this.thread.z][m][E] * e[this.constants.deltaZ][r][b];
                }
                return n;
            }
            function Qn(c, t) {
                let e = 0;
                for(let i = 0; i < this.constants.deltaHeight; i++)for(let h = 0; h < this.constants.deltaWidth; h++)e += t[this.thread.z][i][h];
                return c[this.thread.z][this.thread.y][this.thread.x] + e;
            }
            const gi = {
                stride: 0,
                padding: 0,
                bias: .1,
                filterCount: 1,
                filterWidth: 0,
                filterHeight: 0
            };
            class is extends Se {
                constructor(t, e){
                    var i, h, u;
                    super(t, e), this.compareFilterDeltasKernel = null, this.compareInputDeltasKernel = null, this.compareBiasesKernel = null, this.settings = {
                        ...gi,
                        ...t,
                        ...ts(t, gi),
                        ...Qi(t, gi)
                    }, this.weights = (i = t.weights) !== null && i !== void 0 ? i : ke(this.width, this.height, this.depth), this.deltas = de(this.width, this.height, this.depth), this.biases = es(this.depth, this.bias), this.biasDeltas = (h = t.biasDeltas) !== null && h !== void 0 ? h : we(this.depth), this.filters = (u = t.filters) !== null && u !== void 0 ? u : ke(this.filterWidth, this.filterHeight, this.filterCount), this.filterDeltas = de(this.filterWidth, this.filterHeight, this.filterCount), this.validate();
                }
                get strideX() {
                    return this.settings.strideX;
                }
                get strideY() {
                    return this.settings.strideY;
                }
                get paddingX() {
                    return this.settings.paddingX;
                }
                get paddingY() {
                    return this.settings.paddingX;
                }
                get width() {
                    return Math.floor((this.inputLayer.width + this.paddingX * 2 - this.filterWidth) / this.strideX + 1);
                }
                get height() {
                    return Math.floor((this.inputLayer.height + this.paddingY * 2 - this.filterHeight) / this.strideY + 1);
                }
                get bias() {
                    return this.settings.bias;
                }
                get depth() {
                    return this.filterCount;
                }
                get biases() {
                    return this.settings.biases;
                }
                set biases(t) {
                    this.settings.biases = t;
                }
                get biasDeltas() {
                    return this.settings.biasDeltas;
                }
                set biasDeltas(t) {
                    this.settings.biasDeltas = t;
                }
                get filters() {
                    return this.settings.filters;
                }
                set filters(t) {
                    this.settings.filters = t;
                }
                get filterDeltas() {
                    return this.settings.filterDeltas;
                }
                set filterDeltas(t) {
                    this.settings.filterDeltas = t;
                }
                setupKernels() {
                    this.predictKernel = Z(Jn, {
                        constants: {
                            inputWidth: this.inputLayer.width,
                            inputHeight: this.inputLayer.height,
                            inputDepth: this.inputLayer.depth,
                            strideX: this.strideX,
                            strideY: this.strideY,
                            paddingX: this.paddingX,
                            paddingY: this.paddingY,
                            filterWidth: this.filterWidth,
                            filterHeight: this.filterHeight
                        },
                        output: [
                            this.width,
                            this.height,
                            this.depth
                        ],
                        immutable: !0
                    }), this.compareFilterDeltasKernel = Z(Zn, {
                        constants: {
                            deltaWidth: this.width,
                            deltaHeight: this.height,
                            deltaZ: this.depth,
                            inputWidth: this.inputLayer.width,
                            inputHeight: this.inputLayer.height,
                            inputDepth: this.inputLayer.depth,
                            strideX: this.strideX,
                            strideY: this.strideY,
                            paddingX: this.paddingX,
                            paddingY: this.paddingY,
                            filterWidth: this.filterWidth,
                            filterHeight: this.filterHeight
                        },
                        output: [
                            this.width,
                            this.height,
                            this.depth
                        ],
                        immutable: !0
                    }), this.compareInputDeltasKernel = Z(qn, {
                        constants: {
                            deltaWidth: this.width,
                            deltaHeight: this.height,
                            deltaZ: this.depth,
                            strideX: this.strideX,
                            strideY: this.strideY,
                            paddingX: this.paddingX,
                            paddingY: this.paddingY,
                            filterWidth: this.filterWidth,
                            filterHeight: this.filterHeight,
                            filterCount: this.filterCount
                        },
                        output: [
                            this.inputLayer.width,
                            this.inputLayer.height,
                            this.inputLayer.depth
                        ],
                        immutable: !0
                    }), this.compareBiasesKernel = Z(Qn, {
                        output: [
                            1,
                            1,
                            this.depth
                        ],
                        constants: {
                            deltaWidth: this.width,
                            deltaHeight: this.height
                        },
                        immutable: !0
                    });
                }
                predict() {
                    this.weights = this.predictKernel(this.inputLayer.weights, this.filters, this.biases);
                }
                compare() {
                    const { filterDeltas: t, biasDeltas: e } = this;
                    this.filterDeltas = this.compareFilterDeltasKernel(t, this.inputLayer.weights, this.deltas), X(t), this.biasDeltas = this.compareBiasesKernel(e, this.deltas), X(e), X(this.deltas), this.deltas = this.compareInputDeltasKernel(this.filters, this.inputLayer.deltas), X(this.inputLayer.deltas), this.inputLayer.deltas = Xt(this.deltas);
                }
                learn(t) {
                    const { weights: e } = this;
                    this.weights = this.praxis.run(this, t), X(e);
                }
            }
            function tr(c, t) {
                return new is(c, t);
            }
            function er(c) {
                return c;
            }
            function ir(c) {
                return Math.random() < this.constants.probability ? 0 : c[this.thread.y][this.thread.x];
            }
            function sr(c) {
                return c[this.thread.y][this.thread.x] * this.constants.probability;
            }
            function nr(c, t) {
                return c[this.thread.y][this.thread.x] === 0 ? 0 : t[this.thread.y][this.thread.x];
            }
            const rr = {
                ...Ie,
                probability: .5
            };
            class ss extends Se {
                constructor(t, e){
                    super(e, t), this.predictKernelMap = null, this.settings = {
                        ...rr,
                        ...e
                    }, this.dropouts = null, this.validate();
                }
                setupKernels(t) {
                    const e = [
                        this.width,
                        this.height
                    ];
                    t ? (this.predictKernelMap = Le({
                        dropouts: er
                    }, ir, {
                        output: e,
                        immutable: !0
                    }), this.compareKernel = Z(nr, {
                        output: e,
                        immutable: !0
                    })) : this.predictKernelMap = Le({}, sr, {
                        output: e,
                        immutable: !0
                    });
                }
                predict() {
                    X(this.weights), this.dropouts && X(this.dropouts);
                    const { result: t, dropouts: e } = this.predictKernelMap(this.inputLayer.weights);
                    this.weights = t, this.dropouts = e;
                }
                compare() {
                    X(this.deltas), this.deltas = this.compareKernel(this.dropouts, this.inputLayer.deltas);
                }
            }
            function ar(c, t) {
                return new ss(c, t);
            }
            function or(c, t) {
                const { height: e, praxisOpts: i = null } = c, h = Ot({
                    id: "weights",
                    height: e,
                    width: t.height,
                    praxisOpts: i
                }), u = Ot({
                    id: "biases",
                    height: e,
                    praxisOpts: i
                });
                return le($t(zt(h, t, {
                    praxisOpts: i
                }), u, {
                    praxisOpts: i
                }), {
                    praxisOpts: i
                });
            }
            function ur(c, t, e) {
                let i = 0, h = 0;
                for(let u = 0; u < this.constants.inputHeight; u++)for(let p = 0; p < this.constants.inputWidth; p++)i += c[u][p] * t[this.thread.x][h], h++;
                return i + e[this.thread.x];
            }
            function hr(c, t, e) {
                let i = 0, h = 0;
                for(let u = 0; u < this.constants.inputDepth; u++)for(let p = 0; p < this.constants.inputHeight; p++)for(let d = 0; d < this.constants.inputWidth; d++)i += c[u][p][d] * t[this.thread.x][h], h++;
                return i + e[this.thread.x];
            }
            function lr(c, t, e) {
                let i = 0;
                const h = this.thread.x + this.thread.y * this.output.x;
                for(let u = 0; u < this.constants.filterCount; u++)i += e[u][h] * t[0][u];
                return i + c[this.thread.y][this.thread.x];
            }
            function cr(c, t, e) {
                let i = 0;
                const h = this.thread.x + this.thread.y * this.output.x;
                for(let u = 0; u < this.constants.filterCount; u++)i += e[u][h] * t[0][u];
                return i + c[this.thread.z][this.thread.y][this.thread.x];
            }
            function pr(c, t) {
                return c[this.thread.x] + t[this.thread.y][this.thread.x];
            }
            function fr(c, t, e) {
                return c[this.thread.y][this.thread.x] + t[this.thread.y][this.thread.x] * e[this.constants.deltaY][this.constants.deltaX];
            }
            function dr(c, t, e) {
                const i = Math.floor(this.thread.x / (this.constants.inputWidth * this.constants.inputHeight)), h = Math.floor((this.thread.x - i * this.constants.inputWidth * this.constants.inputHeight) / this.constants.inputWidth), u = this.thread.x - this.constants.inputWidth * (h + this.constants.inputHeight * i);
                return c[this.thread.y][this.thread.x] + t[i][h][u] * e[0][this.thread.y];
            }
            class ns extends Se {
                constructor(t, e){
                    super(t, e), this.compareFilterDeltasKernel = null, this.compareInputDeltasKernel = null, this.compareBiasesKernel = null, this.settings = {
                        ...t
                    }, this.validate();
                    const i = e.width * e.height * e.depth;
                    this.biases = es(this.height, this.bias), this.biasDeltas = Vt(this.height), this.filters = Ee(i, this.height), this.filterDeltas = Mt(i, this.height), this.depth > 0 ? (this.weights = ke(this.width, this.height, this.depth), this.deltas = de(this.width, this.height, this.depth)) : this.height > 0 && (this.weights = Ee(this.width, this.height), this.deltas = Mt(this.width, this.height));
                }
                get bias() {
                    return this.settings.bias;
                }
                get biases() {
                    return this.settings.biases;
                }
                set biases(t) {
                    this.settings.biases = t;
                }
                get biasDeltas() {
                    return this.settings.biases;
                }
                set biasDeltas(t) {
                    this.settings.biasDeltas = t;
                }
                validate() {
                    if (super.validate(), this.depth > 0) throw new Error("depth not supported");
                }
                setupKernels() {
                    const { inputLayer: t } = this, e = t.width * t.height * t.depth;
                    t.depth > 0 ? (this.predictKernel = Z(hr, {
                        output: [
                            this.width,
                            this.height
                        ],
                        constants: {
                            inputHeight: t.height,
                            inputWidth: t.width,
                            inputDepth: t.depth
                        }
                    }), this.compareFilterDeltasKernel = Z(dr, {
                        output: [
                            e,
                            this.height
                        ],
                        constants: {
                            deltaX: 0,
                            deltaY: 0,
                            inputWidth: t.width,
                            inputHeight: t.height
                        },
                        immutable: !0
                    }), this.compareInputDeltasKernel = Z(cr, {
                        output: [
                            t.width,
                            t.height,
                            t.depth
                        ],
                        constants: {
                            filterCount: this.height
                        },
                        immutable: !0
                    })) : (this.predictKernel = Z(ur, {
                        output: [
                            this.width,
                            this.height
                        ],
                        constants: {
                            inputHeight: t.height,
                            inputWidth: t.width
                        }
                    }), this.compareFilterDeltasKernel = Z(fr, {
                        output: [
                            e,
                            this.height
                        ],
                        constants: {
                            deltaX: 0,
                            deltaY: 0,
                            inputWidth: t.width,
                            inputHeight: t.height
                        }
                    }), this.compareInputDeltasKernel = Z(lr, {
                        output: [
                            t.width,
                            t.height
                        ],
                        constants: {
                            filterCount: this.height
                        }
                    })), this.compareBiasesKernel = Z(pr, {
                        output: [
                            this.width,
                            this.height
                        ]
                    });
                }
                predict() {
                    this.weights = this.predictKernel(this.inputLayer.weights, this.filters, this.biases);
                }
                compare() {
                    const t = this.inputLayer.deltas;
                    this.inputLayer.deltas = this.compareInputDeltasKernel(t, this.deltas, this.filters), X(t);
                    const { biasDeltas: e, filterDeltas: i } = this;
                    this.biasDeltas = this.compareBiasesKernel(this.biases, this.deltas), this.filterDeltas = this.compareFilterDeltasKernel(i, this.inputLayer.weights, this.deltas), X(e), X(i);
                }
            }
            function gr(c, t) {
                return new ns(c, t);
            }
            function mr(c) {
                return -c[this.thread.y][this.thread.x];
            }
            class rs extends De {
                constructor(t, e){
                    super(t, e), this.validate();
                }
                setupKernels() {
                    this.predictKernel = Z(mr, {
                        output: [
                            this.width,
                            this.height
                        ]
                    });
                }
                predict() {
                    this.weights = this.predictKernel(this.inputLayer.weights);
                }
            }
            function as(c, t) {
                return new rs(c, t);
            }
            function yr(c, t) {
                return c[this.thread.y][this.thread.x] * t[this.thread.y][this.thread.x];
            }
            function xr(c, t) {
                return c[this.thread.y][this.thread.x] * t[this.thread.y][this.thread.x];
            }
            class os extends $e {
                get width() {
                    return this.inputLayer1.width;
                }
                get height() {
                    return this.inputLayer1.height;
                }
                get depth() {
                    return this.inputLayer1.depth;
                }
                validate() {
                    super.validate(), Xi(this.inputLayer1, this.inputLayer2);
                }
                setupKernels() {
                    this.predictKernel = Z(yr, {
                        output: [
                            this.width,
                            this.height
                        ],
                        immutable: !0
                    }), this.compareKernel = Z(xr, {
                        output: [
                            this.width,
                            this.height
                        ],
                        immutable: !0
                    });
                }
                predict() {
                    X(this.weights), this.weights = this.predictKernel(this.inputLayer1.weights, this.inputLayer2.weights);
                }
                compare() {
                    X(this.inputLayer1.deltas), X(this.inputLayer2.deltas), this.inputLayer1.deltas = this.compareKernel(this.inputLayer2.weights, this.deltas), this.inputLayer2.deltas = this.compareKernel(this.inputLayer1.weights, this.deltas);
                }
            }
            function ge(c, t, e) {
                return new os(c, t, e);
            }
            function us(c) {
                return new Float32Array(c).fill(1);
            }
            function hs(c, t) {
                const e = new Array(t);
                for(let i = 0; i < t; i++)e[i] = us(c);
                return e;
            }
            class ls extends he {
                constructor(t){
                    super(t), this.validate(), this.weights = hs(this.width, this.height), this.deltas = Mt(this.width, this.height);
                }
            }
            function cs(c) {
                return new ls(c);
            }
            function br(c) {
                return ot(c[this.thread.y][this.thread.x]);
            }
            function wr(c) {
                return ot(c[this.thread.z][this.thread.y][this.thread.x]);
            }
            function Tr(c, t) {
                return Tt(c[this.thread.y][this.thread.x], t[this.thread.y][this.thread.x]);
            }
            function Sr(c, t) {
                return Tt(c[this.thread.z][this.thread.y][this.thread.x], t[this.thread.z][this.thread.y][this.thread.x]);
            }
            class ps extends Te {
                setupKernels() {
                    this.depth > 0 ? (this.predictKernel = Z(wr, {
                        output: [
                            this.width,
                            this.height,
                            this.depth
                        ],
                        functions: [
                            ot
                        ],
                        immutable: !0
                    }), this.compareKernel = Z(Sr, {
                        output: [
                            this.width,
                            this.height,
                            this.depth
                        ],
                        functions: [
                            Tt
                        ],
                        immutable: !0
                    })) : (this.predictKernel = Z(br, {
                        output: [
                            this.width,
                            this.height
                        ],
                        functions: [
                            ot
                        ],
                        immutable: !0
                    }), this.compareKernel = Z(Tr, {
                        output: [
                            this.width,
                            this.height
                        ],
                        functions: [
                            Tt
                        ],
                        immutable: !0
                    }));
                }
                predict() {
                    X(this.weights), this.weights = this.predictKernel(this.inputLayer.weights);
                }
                compare() {
                    X(this.inputLayer.deltas), this.inputLayer.deltas = this.compareKernel(this.weights, this.deltas);
                }
            }
            function Be(c, t) {
                return new ps(c, t);
            }
            class fs extends he {
                constructor(t){
                    super(t), this.validate(), this.weights = Mt(this.width, this.height), this.deltas = Mt(this.width, this.height);
                }
                predict() {}
                compare() {}
            }
            function ee(c) {
                return new fs(c);
            }
            function vr(c, t, e) {
                const { height: i } = c, h = Ot({
                    height: i,
                    width: e.height
                }), u = Ot({
                    width: i,
                    height: i
                }), p = ee({
                    height: i
                }), d = le($t($t(zt(h, e), zt(u, t)), p)), l = Ot({
                    height: i,
                    width: e.height
                }), a = Ot({
                    width: i,
                    height: i
                }), o = ee({
                    height: i
                }), n = le($t($t(zt(l, e), zt(a, t)), o)), r = Ot({
                    height: i,
                    width: e.height
                }), m = Ot({
                    width: i,
                    height: i
                }), b = ee({
                    height: i
                }), E = Be($t($t(zt(r, e), zt(m, ge(n, t))), b));
                return $t(ge($t(cs({
                    width: d.width,
                    height: d.height
                }), as(d)), E), ge(t, d));
            }
            const _r = {
                weights: null
            };
            class ds extends ci {
                constructor(t){
                    super({
                        ..._r,
                        ...t
                    }), this.reshapeInput = null, this.validate(), this.reshapeInput = null, this.deltas = Mt(this.width, this.height);
                }
                setupKernels() {
                    this.width === 1 && (this.predict = this.predict1D, this.reshapeInput = Z(function(t) {
                        return t[this.thread.y];
                    }, {
                        output: [
                            1,
                            this.height
                        ],
                        immutable: !0
                    }));
                }
                reuseKernels(t) {
                    this.reshapeInput = t.reshapeInput;
                }
                predict(t) {
                    if ((Array.isArray(t) || t instanceof Float32Array) && typeof t[0] == "number" && t.length === this.height * this.width) X(this.weights), this.weights = dn(t, [
                        this.width,
                        this.height
                    ]);
                    else if (Array.isArray(t) && t.length === this.height && (Array.isArray(t[0]) || t[0] instanceof Float32Array) && t[0].length === this.width) this.weights = Xt(t);
                    else throw new Error("Inputs are not of sized correctly");
                }
                predict1D(t) {
                    this.weights && X(this.weights), this.reshapeInput ? this.weights = this.reshapeInput(t) : this.weights = t;
                }
                compare() {}
                learn() {}
            }
            function Er(c) {
                return new ds(c);
            }
            function kr(c) {
                return ct(c[this.thread.y][this.thread.x]);
            }
            function Lr(c) {
                return ct(c[this.thread.z][this.thread.y][this.thread.x]);
            }
            function Ir(c, t) {
                return ht(c[this.thread.y][this.thread.x], t[this.thread.y][this.thread.x]);
            }
            function Ar(c, t) {
                return ht(c[this.thread.z][this.thread.y][this.thread.x], t[this.thread.z][this.thread.y][this.thread.x]);
            }
            class gs extends Te {
                setupKernels() {
                    const { width: t, height: e, depth: i } = this.inputLayer;
                    this.depth > 0 ? (this.predictKernel = Z(Lr, {
                        output: [
                            t,
                            e,
                            i
                        ],
                        functions: [
                            ct
                        ],
                        immutable: !0
                    }), this.compareKernel = Z(Ar, {
                        output: [
                            t,
                            e,
                            i
                        ],
                        functions: [
                            ht
                        ],
                        immutable: !0
                    })) : (this.predictKernel = Z(kr, {
                        output: [
                            t,
                            e
                        ],
                        functions: [
                            ct
                        ],
                        immutable: !0
                    }), this.compareKernel = Z(Ir, {
                        output: [
                            t,
                            e
                        ],
                        functions: [
                            ht
                        ],
                        immutable: !0
                    }));
                }
                predict() {
                    X(this.weights), this.weights = this.predictKernel(this.inputLayer.weights);
                }
                compare() {
                    const { deltas: t } = this;
                    this.deltas = this.compareKernel(this.weights, t), X(t);
                }
            }
            function Dr(c, t) {
                return new gs(c, t);
            }
            function $r(c, t, e) {
                const { height: i } = c;
                if (typeof i != "number") throw new Error("no settings.height given");
                e.setDimensions && e.setDimensions(1, i);
                const h = Ot({
                    width: t.height,
                    height: i,
                    std: .08,
                    id: "inputGateWeights"
                }), u = Ot({
                    width: i,
                    height: i,
                    std: .08,
                    id: "inputGatePeepholes"
                }), p = ee({
                    width: 1,
                    height: i,
                    id: "inputGateBias"
                }), d = le($t($t(zt(h, t), zt(u, e)), p), {
                    id: "inputGate"
                }), l = Ot({
                    width: t.height,
                    height: i,
                    std: .08,
                    id: "forgetGateWeights"
                }), a = Ot({
                    width: i,
                    height: i,
                    std: .08,
                    id: "forgetGatePeepholes"
                }), o = ee({
                    width: 1,
                    height: i,
                    id: "forgetGateBias"
                }), n = le($t($t(zt(l, t), zt(a, e)), o), {
                    id: "forgetGate"
                }), r = Ot({
                    width: t.height,
                    height: i,
                    std: .08,
                    id: "outputGateWeights"
                }), m = Ot({
                    width: i,
                    height: i,
                    std: .08,
                    id: "outputGatePeepholes"
                }), b = ee({
                    width: 1,
                    height: i,
                    id: "outputGateBias"
                }), E = le($t($t(zt(r, t), zt(m, e)), b), {
                    id: "outputGate"
                }), w = Ot({
                    width: t.height,
                    height: i,
                    std: .08,
                    id: "memoryWeights"
                }), v = Ot({
                    width: i,
                    height: i,
                    std: .08,
                    id: "memoryPeepholes"
                }), y = ee({
                    width: 1,
                    height: i,
                    id: "memoryBias"
                }), T = Be($t($t(zt(w, t), zt(v, e)), y), {
                    id: "memory"
                }), _ = ge(n, e, {
                    id: "retainCell"
                }), k = ge(d, T, {
                    id: "writeCell"
                }), C = $t(_, k, {
                    id: "cell"
                });
                return ge(E, Be(C), {
                    id: "activations"
                });
            }
            function Or(c, t) {
                const { height: e } = c, i = Ot({
                    height: e,
                    width: t.height,
                    id: "outputGate",
                    std: .08
                }), h = Ot({
                    height: e,
                    id: "output",
                    std: .08
                }), u = zt(i, t, {
                    id: "outputGateConnected"
                });
                return Vi({
                    id: "target",
                    ...c
                }, $t(u, h));
            }
            function Cr(c) {
                return c;
            }
            function Rr(c) {
                return c;
            }
            function Fr(c) {
                const t = this.thread.x * this.constants.strideX - this.constants.paddingX, e = this.thread.y * this.constants.strideY - this.constants.paddingY, i = t + this.constants.filterWidth, h = e + this.constants.filterHeight, u = Math.max(t, 0), p = Math.max(e, 0), d = Math.min(i, this.constants.inputWidth), l = Math.min(h, this.constants.inputHeight);
                let a = c[this.thread.z][p][u];
                for(let o = p; o < l; o++)for(let n = u; n < d; n++){
                    const r = c[this.thread.z][o][n];
                    r > a && (a = r);
                }
                return a;
            }
            function Mr(c, t, e) {
                const i = this.thread.x + .5, h = this.thread.y + .5, u = 1 / this.constants.strideX, p = 1 / this.constants.strideY, d = Math.max(0, Math.ceil((i - this.constants.filterWidth + this.constants.paddingX) * u)), l = Math.max(0, Math.ceil((h - this.constants.filterHeight + this.constants.paddingY) * p)), a = Math.min(Math.ceil((i + this.constants.paddingX) * u), this.constants.outputWidth), o = Math.min(Math.ceil((h + this.constants.paddingY) * p), this.constants.outputHeight);
                let n = 0;
                for(let r = l; r < o; r++)for(let m = d; m < a; m++){
                    const b = t[r][m], E = e[r][m];
                    Math.abs(b - this.thread.x) < .1 && Math.abs(E - this.thread.y) < .1 && (n += c[r][m]);
                }
                return n;
            }
            const ms = {
                padding: 0,
                stride: 0
            };
            class ys extends Se {
                constructor(t, e){
                    super(t, e), this.predictKernelMap = null, this.settings = {
                        ...t,
                        ...Qi(t, ms),
                        ...ts(t, ms)
                    }, this.weights = ke(this.width, this.height, this.depth), this.deltas = de(this.width, this.height, this.depth), this.validate();
                }
                get strideX() {
                    return this.settings.strideX;
                }
                get strideY() {
                    return this.settings.strideY;
                }
                get paddingX() {
                    return this.settings.paddingX;
                }
                get paddingY() {
                    return this.settings.paddingY;
                }
                get width() {
                    return Math.ceil((this.inputLayer.width + this.paddingX * 2 - this.filterWidth) / this.strideX + 1);
                }
                get height() {
                    return Math.floor((this.inputLayer.height + this.paddingY * 2 - this.filterHeight) / this.strideY + 1);
                }
                get depth() {
                    return this.settings.filterCount;
                }
                get filterCount() {
                    return this.settings.filterCount;
                }
                get switchX() {
                    return this.settings.switchX;
                }
                set switchX(t) {
                    this.settings.switchX = t;
                }
                get switchY() {
                    return this.settings.switchY;
                }
                set switchY(t) {
                    this.settings.switchY = t;
                }
                setupKernels() {
                    this.predictKernelMap = Le({
                        switchX: Rr,
                        switchY: Cr
                    }, Fr, {
                        output: [
                            this.width,
                            this.height,
                            this.depth
                        ],
                        constants: {
                            inputWidth: this.inputLayer.width,
                            inputHeight: this.inputLayer.height,
                            paddingX: this.paddingX,
                            paddingY: this.paddingY,
                            filterHeight: this.filterHeight,
                            filterWidth: this.filterWidth,
                            strideX: this.strideX,
                            strideY: this.strideY
                        }
                    }), this.compareKernel = Z(Mr, {
                        output: [
                            this.inputLayer.width,
                            this.inputLayer.height,
                            this.inputLayer.depth
                        ],
                        constants: {
                            inputWidth: this.inputLayer.width,
                            inputHeight: this.inputLayer.height,
                            outputWidth: this.width,
                            outputHeight: this.height,
                            filterWidth: this.filterWidth,
                            filterHeight: this.filterHeight,
                            paddingX: this.paddingX,
                            paddingY: this.paddingY,
                            strideX: this.strideX,
                            strideY: this.strideY
                        }
                    });
                }
                predict() {
                    const { result: t, switchX: e, switchY: i } = this.predictKernelMap(this.inputLayer.weights);
                    this.switchX = e, this.switchY = i, this.weights = t;
                }
                compare() {
                    const t = this.inputLayer.deltas;
                    this.inputLayer.deltas = this.compareKernel(this.deltas, this.switchX, this.switchY), X(t);
                }
            }
            function zr(c, t) {
                return new ys(c, t);
            }
            class We extends Ae {
                constructor(t){
                    super(), this.praxis = null, this.predictKernel = null, this.compareKernel = null, this.settings = {}, this.recurrentInput = t, this.validate();
                }
                get width() {
                    return this.recurrentInput.width;
                }
                get height() {
                    return this.recurrentInput.height;
                }
                get depth() {
                    return this.recurrentInput.depth;
                }
                get deltas() {
                    return this.recurrentInput.deltas;
                }
                set deltas(t) {
                    const e = this.recurrentInput.deltas;
                    this.recurrentInput.deltas = t, X(e);
                }
                get weights() {
                    return this.recurrentInput.weights;
                }
                set weights(t) {
                    const e = this.recurrentInput.weights;
                    this.recurrentInput.weights = t, X(e);
                }
                validate() {
                    if (Wt.prototype.validate.call(this), this.width !== this.recurrentInput.width) throw new Error(`${this.constructor.name} layer width ${this.width} and ${this.recurrentInput.constructor.name} width (${this.recurrentInput.width}) are not same`);
                    if (this.height !== this.recurrentInput.height) throw new Error(`${this.constructor.name} layer height ${this.height} and ${this.recurrentInput.constructor.name} width (${this.recurrentInput.height}) are not same`);
                }
                setDimensions(t, e) {
                    this.recurrentInput.width = t, this.recurrentInput.height = e;
                }
                predict() {}
                compare() {}
                learn() {}
                setupKernels() {}
                reuseKernels() {}
            }
            class je extends Ae {
                constructor(t){
                    super(), this.praxis = null, this.settings = {}, this.predictKernel = null, this.compareKernel = null, t && (this.settings = {
                        ...t
                    });
                }
                setDimensions(t, e) {
                    this.praxis = null, this.settings = {
                        ...this.settings,
                        width: t,
                        height: e,
                        weights: Mt(t, e),
                        deltas: Mt(t, e)
                    };
                }
                setupKernels() {}
                reuseKernels() {}
                predict() {}
                compare() {}
                learn(t) {
                    const { weights: e } = this;
                    this.weights = this.praxis.run(this, t), X(e);
                }
            }
            function xs() {
                return new je;
            }
            function Pr(c) {
                return V(c[this.thread.y][this.thread.x]);
            }
            function Nr(c, t) {
                return z(c[this.thread.y][this.thread.x], t[this.thread.y][this.thread.x]);
            }
            function Vr(c) {
                return V(c[this.thread.z][this.thread.y][this.thread.x]);
            }
            function Kr(c, t) {
                return z(c[this.thread.z][this.thread.y][this.thread.x], t[this.thread.z][this.thread.y][this.thread.x]);
            }
            class bs extends Te {
                setupKernels() {
                    const { width: t, height: e, depth: i } = this.inputLayer;
                    i > 0 ? (this.predictKernel = Z(Vr, {
                        output: [
                            t,
                            e,
                            i
                        ],
                        functions: [
                            V
                        ],
                        immutable: !0
                    }), this.compareKernel = Z(Kr, {
                        output: [
                            t,
                            e,
                            i
                        ],
                        functions: [
                            z
                        ],
                        immutable: !0
                    })) : (this.predictKernel = Z(Pr, {
                        output: [
                            t,
                            e
                        ],
                        functions: [
                            V
                        ],
                        immutable: !0
                    }), this.compareKernel = Z(Nr, {
                        output: [
                            t,
                            e
                        ],
                        functions: [
                            z
                        ],
                        immutable: !0
                    }));
                }
                predict() {
                    X(this.weights), this.weights = this.predictKernel(this.inputLayer.weights);
                }
                compare() {
                    X(this.inputLayer.deltas), this.inputLayer.deltas = this.compareKernel(this.weights, this.deltas);
                }
            }
            function ws(c, t) {
                return new bs(c, t);
            }
            function Gr(c, t, e) {
                const { height: i } = c;
                if (typeof i != "number") throw new Error("height not set");
                e.setDimensions && e.setDimensions(1, i);
                const h = Ot({
                    id: "weight",
                    height: i,
                    width: t.height,
                    std: .08
                }), u = Ot({
                    id: "transition",
                    height: i,
                    width: i,
                    std: .08
                }), p = ee({
                    id: "bias",
                    height: i
                });
                return ws($t($t(zt(h, t), zt(u, e)), p));
            }
            class Ts extends Wt {
                constructor(t, e){
                    super(t), this.inputLayer = e, this.validate();
                }
                predict() {
                    X(this.weights), this.weights = Xt(this.inputLayer.weights);
                }
                learn() {}
            }
            function Ur(c, t) {
                return new Ts(c, t);
            }
            function Br(c) {
                let t = -1 / 0;
                for(let e = 0; e < this.constants.inputHeight; e++)for(let i = 0; i < this.constants.inputWidth; i++){
                    const h = c[e][i];
                    h > t && (t = h);
                }
                return t;
            }
            function Wr(c) {
                let t = -1 / 0;
                for(let e = 0; e < this.constants.inputDepth; e++)for(let i = 0; i < this.constants.inputHeight; i++)for(let h = 0; h < this.constants.inputWidth; h++){
                    const u = c[e][i][h];
                    u > t && (t = u);
                }
                return t;
            }
            function jr(c) {
                let t = 0;
                for(let e = 0; e < this.constants.inputHeight; e++)for(let i = 0; i < this.constants.inputWidth; i++)t += c[e][i];
                return t;
            }
            function Hr(c) {
                let t = 0;
                for(let e = 0; e < this.constants.inputDepth; e++)for(let i = 0; i < this.constants.inputHeight; i++)for(let h = 0; h < this.constants.inputWidth; h++)t += c[e][i][h];
                return t;
            }
            function Xr(c, t) {
                return Math.exp(c[this.thread.x] - t[0]);
            }
            function Yr(c, t) {
                return Math.exp(c[this.thread.z][this.thread.y][this.thread.x] - t[0]);
            }
            function Jr(c, t) {
                return c[this.thread.y][this.thread.x] / t[0];
            }
            function Zr(c, t) {
                return c[this.thread.z][this.thread.y][this.thread.x] / t[0];
            }
            function qr(c, t) {
                let e = 0;
                return this.thread.x + this.thread.y * this.output.x === c && (e = 1), -(e - t[this.thread.y][this.thread.x]);
            }
            function Qr(c, t) {
                let e = 0;
                return this.thread.x + this.thread.y * this.output.x + this.thread.z * this.output.x * this.output.y === c && (e = 1), -(e - t[this.thread.z][this.thread.y][this.thread.x]);
            }
            class Ss extends De {
                constructor(t, e){
                    super(t, e), this.errors = null, this.getExponentialsKernel = null, this.getMaxValueKernel = null, this.getSumKernel = null, this.validate(), this.depth > 0 ? (this.weights = ke(this.width, this.height, this.depth), this.deltas = de(this.width, this.height, this.depth)) : this.height > 0 ? (this.weights = Ee(this.width, this.height), this.deltas = Mt(this.width, this.height)) : (this.weights = we(this.width), this.deltas = Vt(this.width));
                }
                setupKernels() {
                    const { width: t, height: e, depth: i } = this;
                    i > 0 ? (this.getExponentialsKernel = Z(Yr, {
                        output: [
                            t,
                            e,
                            i
                        ]
                    }), this.getMaxValueKernel = Z(Wr, {
                        output: [
                            1,
                            1,
                            1
                        ],
                        constants: {
                            inputWidth: t,
                            inputHeight: e,
                            inputDepth: i
                        }
                    }), this.getSumKernel = Z(Hr, {
                        output: [
                            1,
                            1,
                            1
                        ],
                        constants: {
                            inputWidth: t,
                            inputHeight: e,
                            inputDepth: i
                        }
                    }), this.predictKernel = Z(Zr, {
                        output: [
                            t,
                            e,
                            i
                        ]
                    }), this.compareKernel = Z(Qr, {
                        output: [
                            t,
                            e,
                            i
                        ],
                        immutable: !0
                    })) : (this.getExponentialsKernel = Z(Xr, {
                        output: [
                            t,
                            e
                        ]
                    }), this.getMaxValueKernel = Z(Br, {
                        output: [
                            1,
                            1
                        ],
                        constants: {
                            inputWidth: t,
                            inputHeight: e
                        }
                    }), this.getSumKernel = Z(jr, {
                        output: [
                            1,
                            1
                        ],
                        constants: {
                            inputWidth: t,
                            inputHeight: e
                        }
                    }), this.predictKernel = Z(Jr, {
                        output: [
                            t,
                            e
                        ]
                    }), this.compareKernel = Z(qr, {
                        output: [
                            t,
                            e
                        ],
                        immutable: !0
                    }));
                }
                predict() {
                    const t = this.getMaxValueKernel(this.inputLayer.weights), e = this.getExponentialsKernel(this.inputLayer.weights, t), i = this.getSumKernel(e);
                    this.weights = this.predictKernel(e, i);
                }
                compare(t) {
                    const { deltas: e, errors: i } = this;
                    this.errors = this.compareKernel(t[0], e), this.deltas = Xt(this.errors), X(e), X(i);
                    const h = this.inputLayer.deltas;
                    this.inputLayer.deltas = Xt(this.deltas), X(h);
                }
            }
            function ta(c, t) {
                return new Ss(c, t);
            }
            class vs extends Wt {
                constructor(t, e){
                    super(e), this.inputLayer = t;
                }
                predict() {
                    X(this.weights), this.weights = Xt(this.inputLayer.weights), this.validate();
                }
                learn() {}
            }
            function ea(c, t) {
                return new vs(c, t);
            }
            function _s(c) {
                return c[this.thread.x][this.thread.y];
            }
            const ia = _s;
            class Es extends De {
                get width() {
                    return this.inputLayer.height;
                }
                get height() {
                    return this.inputLayer.width;
                }
                constructor(t){
                    super(t), this.validate();
                }
                setupKernels() {
                    this.predictKernel = Z(_s, {
                        output: [
                            this.height,
                            this.width
                        ]
                    }), this.compareKernel = Z(ia, {
                        output: [
                            this.width,
                            this.height
                        ]
                    });
                }
                predict() {
                    this.weights = this.predictKernel(this.inputLayer.weights);
                }
                compare() {
                    this.inputLayer.deltas = this.compareKernel(this.deltas);
                }
            }
            function sa(c) {
                return new Es(c);
            }
            const qt = {
                Activation: Te,
                Internal: Ae,
                InternalModel: li,
                EntryPoint: ci,
                Filter: Se,
                Model: he,
                Modifier: De,
                Operator: $e,
                Target: Oe
            };
            var mi = Object.freeze({
                __proto__: null,
                layerTypes: qt,
                Add: Yi,
                add: $t,
                arthurFeedForward: Yn,
                BaseLayer: Wt,
                baseLayerDefaultSettings: Ie,
                Convolution: is,
                convolution: tr,
                Dropout: ss,
                dropout: ar,
                feedForward: or,
                FullyConnected: ns,
                fullyConnected: gr,
                gru: vr,
                Input: ds,
                input: Er,
                LeakyRelu: gs,
                leakyRelu: Dr,
                lstmCell: $r,
                Multiply: Zi,
                multiply: zt,
                MultiplyElement: os,
                multiplyElement: ge,
                Negative: rs,
                negative: as,
                Ones: ls,
                ones: cs,
                output: Or,
                Pool: ys,
                pool: zr,
                Random: Ji,
                random: Ot,
                RecurrentInput: We,
                RecurrentZeros: je,
                rnnCell: Gr,
                Regression: Ts,
                regression: Ur,
                Relu: bs,
                relu: ws,
                Sigmoid: qi,
                sigmoid: le,
                SoftMax: Ss,
                softMax: ta,
                SVM: vs,
                svm: ea,
                Tanh: ps,
                tanh: Be,
                Target: Oe,
                target: Vi,
                Transpose: Es,
                transpose: sa,
                Zeros: fs,
                zeros: ee
            });
            const na = Object.keys(mi);
            function ce(c, t, e) {
                if (!na.find((h)=>h === c.type)) return null;
                const i = mi[c.type];
                if (i.prototype instanceof qt.Filter) {
                    if (!t) throw new Error("inputLayer missing");
                    return new i(c, t);
                } else if (i.prototype instanceof qt.Activation || i.prototype instanceof qt.Modifier) {
                    if (!t) throw new Error("inputLayer missing");
                    return new i(t, c);
                } else {
                    if (i.prototype instanceof qt.Internal) return new i(c);
                    if (i.prototype instanceof qt.Operator) {
                        if (!t) throw new Error("inputLayer1 missing");
                        if (!e) throw new Error("inputLayer2 missing");
                        return new i(t, e, c);
                    } else {
                        if (i.prototype instanceof qt.InternalModel || i.prototype instanceof qt.EntryPoint || i.prototype instanceof qt.Model) return new i(c);
                        if (i === Oe) {
                            if (!t) throw new Error("inputLayer missing");
                            return new i(c, t);
                        }
                    }
                }
                return null;
            }
            const ra = {
                learningRate: .3,
                binaryThresh: .5,
                initPraxis: (c, t)=>{
                    var e;
                    return di(c, (e = c.settings.praxisOpts) !== null && e !== void 0 ? e : t);
                }
            }, yi = {
                iterations: 2e4,
                errorThresh: .005,
                log: !1,
                logPeriod: 10,
                learningRate: .3,
                callbackPeriod: 10,
                errorCheckInterval: 100,
                timeout: 1 / 0
            };
            class Ce {
                constructor(t = {}){
                    this.trainOpts = {}, this.layers = null, this._inputLayer = null, this._hiddenLayers = null, this._outputLayer = null, this._model = null, this.meanSquaredError = null, this.inputLookup = null, this.inputLookupLength = null, this.outputLookup = null, this.outputLookupLength = null, this.options = {
                        ...ra,
                        ...t
                    }, this._updateTrainingOptions({
                        ...yi,
                        ...t
                    });
                }
                static _validateTrainingOptions(t) {
                    const { iterations: e, errorThresh: i, log: h, logPeriod: u, learningRate: p, callback: d, callbackPeriod: l, timeout: a } = t, o = {
                        iterations: ()=>typeof e == "number" && e > 0,
                        errorThresh: ()=>typeof i == "number" && i > 0 && i < 1,
                        log: ()=>typeof h == "function" || typeof h == "boolean",
                        logPeriod: ()=>typeof u == "number" && u > 0,
                        learningRate: ()=>typeof p == "number" && p > 0 && p < 1,
                        callback: ()=>typeof d == "function" || d === null,
                        callbackPeriod: ()=>typeof l == "number" && l > 0,
                        timeout: ()=>typeof a == "number" && a > 0
                    };
                    Object.keys(yi).forEach((n)=>{
                        if (o.hasOwnProperty(n) && !o[n]()) {
                            const r = t[n];
                            throw new Error(`[${n}, ${(r ?? "undefined").toString()}] is out of normal training range, your network will probably not train.`);
                        }
                    });
                }
                _setLogMethod(t) {
                    typeof t == "function" ? this.trainOpts.log = t : t ? this.trainOpts.log = console.log : this.trainOpts.log = !1;
                }
                _updateTrainingOptions(t) {
                    var e;
                    this.trainOpts = {
                        ...yi,
                        ...this.trainOpts,
                        ...t
                    }, Ce._validateTrainingOptions(this.trainOpts), this._setLogMethod((e = t.log) !== null && e !== void 0 ? e : this.trainOpts.log);
                    const { callback: i, callbackPeriod: h, errorCheckInterval: u } = this.trainOpts;
                    i && h !== u && console.warn(`options.callbackPeriod with value of ${(h ?? "undefined").toString()} does not match options.errorCheckInterval with value of ${(u ?? "undefined").toString()}, if logging error, it will repeat.  These values may need to match`);
                }
                _connectOptionsLayers() {
                    const { inputLayerIndex: t, outputLayerIndex: e, layers: i } = this.options;
                    if (!i) throw new Error("this.options.layers in unexpected state");
                    if (typeof t != "number") throw new Error("inputLayerIndex not a number");
                    if (typeof e != "number") throw new Error("inputLayerIndex not a number");
                    const h = i[t];
                    if (!h) throw new Error("inputLayer not found in this.options.layers");
                    const u = i[e];
                    if (!u) throw new Error("outputLayer not found in this.options.layers");
                    return this._inputLayer = h, this._hiddenLayers = i.slice(t, e - t), this._outputLayer = u, i;
                }
                _connectNewLayers() {
                    const { inputLayer: t, outputLayer: e } = this.options;
                    if (!t) throw new Error("inputLayer not defined");
                    const i = [];
                    this._inputLayer = t();
                    const h = this._connectHiddenLayers(this._inputLayer);
                    if (!e) throw new Error("outputLayer not defined");
                    return this._outputLayer = e(h[h.length - 1], h.length), i.push(this._inputLayer), i.push(...h), i.push(this._outputLayer), Hi(i);
                }
                _connectHiddenLayers(t) {
                    this._hiddenLayers = [];
                    const e = [], { hiddenLayers: i } = this.options;
                    if (!i) throw new Error("hiddenLayers not defined");
                    for(let h = 0; h < i.length; h++){
                        const u = i[h](t, h);
                        e.push(u), this._hiddenLayers.push(u), t = u;
                    }
                    return e;
                }
                initialize() {
                    this.layers = this.options.layers ? this._connectOptionsLayers() : this._connectNewLayers(), this.initializeLayers(this.layers), this._model = this.layers.filter((t)=>t instanceof he);
                }
                initializeLayers(t) {
                    var e, i;
                    for(let u = 0; u < t.length; u++){
                        const p = t[u];
                        p.setupKernels(!0), p instanceof he && p.praxis === null && typeof this.options.initPraxis == "function" && (p.praxis = this.options.initPraxis(p, (i = (e = p.settings.praxisOpts) !== null && e !== void 0 ? e : this.options.praxisOpts) !== null && i !== void 0 ? i : {}), p.praxis.setupKernels());
                    }
                    const h = t[t.length - 1];
                    this.meanSquaredError = new In({
                        width: h.width,
                        height: h.height
                    });
                }
                run(t) {
                    let e;
                    if (Array.isArray(t) || t.buffer) e = t;
                    else if (this.inputLookup) e = dt.toArray(this.inputLookup, t, this.inputLookupLength);
                    else throw new Error("input is incompatible with net");
                    let i = this.runInput(e);
                    return i instanceof wt.Texture && (i = i.toArray()), this.outputLookup ? dt.toObject(this.outputLookup, i) : i;
                }
                runInput(t) {
                    if (!this.layers) throw new Error("not initialized");
                    this.layers[0].predict(t);
                    for(let e = 1; e < this.layers.length; e++)this.layers[e].predict();
                    return this.layers[this.layers.length - 1].weights;
                }
                train(t, e = {}) {
                    const { preparedData: i, status: h, endTime: u } = this._prepTraining(t, e);
                    let p = !0;
                    const d = ()=>this._calculateTrainingError(i), l = ()=>this._trainPatterns(i);
                    for(; p;)p = this._trainingTick(h, u, d, l);
                    return h;
                }
                async trainAsync(t, e = {}) {
                    const { preparedData: i, status: h, endTime: u } = this._prepTraining(t, e);
                    return await new Promise((p, d)=>{
                        try {
                            const l = ()=>this._calculateTrainingError(i), a = ()=>this._trainPatterns(i), o = new oe.Thaw(new Array(this.trainOpts.iterations), {
                                delay: !0,
                                each: ()=>this._trainingTick(h, u, l, a) || o.stop(),
                                done: ()=>p(h)
                            });
                            o.tick();
                        } catch (l) {
                            d(l);
                        }
                    });
                }
                _trainingTick(t, e, i, h) {
                    const { trainOpts: u } = this;
                    return t.iterations >= u.iterations || t.error <= u.errorThresh || Date.now() >= e ? !1 : (typeof u.log == "function" && t.iterations % u.logPeriod === 0 ? (t.error = i(), u.log(`iterations: ${t.iterations}, training error: ${t.error}`)) : t.iterations % u.errorCheckInterval === 0 ? t.error = i() : h(), u.callback && t.iterations % u.callbackPeriod === 0 && u.callback(Object.assign(t)), t.iterations++, !0);
                }
                _prepTraining(t, e) {
                    this._updateTrainingOptions(e);
                    const i = this.formatData(t), h = this.trainOpts.timeout ? Date.now() + this.trainOpts.timeout : 0, u = {
                        error: 1,
                        iterations: 0
                    };
                    return this.verifyIsInitialized(), {
                        preparedData: this.transferData(i),
                        status: u,
                        endTime: h
                    };
                }
                verifyIsInitialized() {
                    this._model || this.initialize();
                }
                _calculateTrainingError(t) {
                    let e = new Float32Array([
                        0
                    ]);
                    const i = this.meanSquaredError;
                    for(let u = 0; u < t.length; ++u){
                        const p = e, d = this._trainPattern(t[u].input, t[u].output, !0);
                        e = i.add(e, d), X(d), X(p);
                    }
                    const h = i.divide(t.length, e);
                    if (X(e), h instanceof wt.Texture) {
                        const u = h.toArray();
                        return X(h), u[0];
                    }
                    return h[0];
                }
                _trainPatterns(t) {
                    for(let e = 0; e < t.length; ++e)this._trainPattern(t[e].input, t[e].output, !1);
                }
                _trainPattern(t, e, i) {
                    var h;
                    if (this.runInput(t), this._calculateDeltas(e), this.adjustWeights(), i) {
                        if (!(!((h = this._outputLayer) === null || h === void 0) && h.errors)) throw new Error("outputLayer.errors not defined");
                        return this.meanSquaredError.calculate(this._outputLayer.errors);
                    }
                    return null;
                }
                _calculateDeltas(t) {
                    const e = this.layers;
                    for(let i = e.length - 1; i > -1; i--)e[i].compare(t);
                }
                adjustWeights() {
                    const t = this._model;
                    for(let e = 0; e < t.length; e++)t[e].learn(this.trainOpts.learningRate);
                }
                formatData(t) {
                    if (!Array.isArray(t)) {
                        const u = [];
                        u.push(t), t = u;
                    }
                    const e = t[0].input;
                    let i;
                    if (Array.isArray(t) && !Array.isArray(e) && !(e instanceof Float32Array)) {
                        if (!this.inputLookup) {
                            const u = new te(t, "input");
                            this.inputLookup = u.table, this.inputLookupLength = u.length;
                        }
                        i = t.map((u)=>({
                                input: dt.toArray(this.inputLookup, u.input, this.inputLookupLength)
                            }), this);
                    } else i = t;
                    const h = t[0].output;
                    if (!Array.isArray(h) && !(h instanceof Float32Array)) {
                        if (!this.outputLookup) {
                            const u = new te(t, "output");
                            this.outputLookup = u.table, this.outputLookupLength = u.length;
                        }
                        i = t.map((u, p)=>{
                            const d = dt.toArray(this.outputLookup, u.output, this.inputLookupLength);
                            return {
                                input: i[p].input,
                                output: d
                            };
                        }, this);
                    }
                    return i;
                }
                transferData(t) {
                    const e = new Array(t.length), i = Z(function(u) {
                        return u[this.thread.x];
                    }, {
                        output: [
                            t[0].input.length
                        ],
                        immutable: !0
                    }), h = Z(function(u) {
                        return u[this.thread.x];
                    }, {
                        output: [
                            t[0].output.length
                        ],
                        immutable: !0
                    });
                    for(let u = 0; u < t.length; u++){
                        const p = t[u];
                        e[u] = {
                            input: i(p.input),
                            output: h(p.output)
                        };
                    }
                    return e;
                }
                test() {
                    throw new Error(`${this.constructor.name}-test is not yet implemented`);
                }
                toJSON() {
                    var t;
                    if (this.layers || this.initialize(), !this._model || !this.layers || !this._inputLayer || !this._hiddenLayers || !this._outputLayer) throw new Error("network is not initialized");
                    const e = [];
                    for(let i = 0; i < this.layers.length; i++){
                        const h = this.layers[i], u = h.toJSON();
                        h.hasOwnProperty("inputLayer") ? u.inputLayerIndex = this.layers.indexOf(h.inputLayer) : h.hasOwnProperty("inputLayer1") && h.hasOwnProperty("inputLayer2") && (u.inputLayer1Index = this.layers.indexOf(h.inputLayer1), u.inputLayer2Index = this.layers.indexOf(h.inputLayer2)), e.push(u);
                    }
                    return {
                        type: this.constructor.name,
                        sizes: (t = this.options.sizes) !== null && t !== void 0 ? t : [
                            this._inputLayer.height
                        ].concat(this._hiddenLayers.map((i)=>i.height)).concat([
                            this._outputLayer.height
                        ]),
                        outputLayerIndex: this.layers.indexOf(this._outputLayer),
                        layers: e,
                        inputLayerIndex: this.layers.indexOf(this._inputLayer)
                    };
                }
                static fromJSON(t, e) {
                    var i, h, u, p;
                    const d = t.layers, l = [], a = e ? (i = ce(d[0])) !== null && i !== void 0 ? i : e(d[0]) : ce(d[0]);
                    if (!a) throw new Error("unable to find layer");
                    l.push(a);
                    for(let o = 1; o < d.length; o++){
                        const n = d[o];
                        if (typeof n.inputLayerIndex > "u" && typeof n.inputLayer1Index > "u" && typeof n.inputLayer2Index > "u") {
                            const r = e ? (h = ce(n)) !== null && h !== void 0 ? h : e(n) : ce(n);
                            if (!r) throw new Error("unable to find layer");
                            l.push(r);
                        } else if (typeof n.inputLayerIndex == "number") {
                            const r = l[n.inputLayerIndex];
                            if (!r) throw new Error("inputLayer1 not found");
                            const m = e ? (u = ce(n, r)) !== null && u !== void 0 ? u : e(n, r) : ce(n, r);
                            if (!m) throw new Error("unable to find layer");
                            l.push(m);
                        } else {
                            if (typeof n.inputLayer1Index != "number") throw new Error("Cannot create network from provided JSON. inputLayer1Index not defined.");
                            if (typeof n.inputLayer2Index != "number") throw new Error("Cannot create network from provided JSON. inputLayer2Index not defined.");
                            const r = l[n.inputLayer1Index], m = l[n.inputLayer2Index];
                            if (r === void 0) throw new Error(`Cannot create network from provided JSON. layer of index ${n.inputLayer1Index} not found.`);
                            if (m === void 0) throw new Error(`Cannot create network from provided JSON. layer of index ${n.inputLayer2Index} not found.`);
                            const b = e ? (p = ce(n, r, m)) !== null && p !== void 0 ? p : e(n, r, m) : ce(n, r, m);
                            if (!b) throw new Error("unable to find layer");
                            l.push(b);
                        }
                    }
                    return new this({
                        ...t,
                        layers: l
                    });
                }
                toFunction() {
                    throw new Error(`${this.constructor.name}-toFunction is not yet implemented`);
                }
            }
            function aa(c, t) {
                if (!t) throw new TypeError(`Required parameter 'net' is of type ${typeof t}. Must be of type 'brain.NeuralNetwork'`);
                const e = t.run(c);
                let i = null, h = -1;
                return Object.entries(e).forEach(([u, p])=>{
                    typeof p < "u" && typeof p == "number" && p > h && (i = u, h = p);
                }), i;
            }
            class ks extends Ae {
                constructor(){
                    super(...arguments), this.settings = {}, this.layer = null;
                }
                setLayer(t) {
                    this.layer = t;
                }
                get width() {
                    if (!this.layer) throw new Error("layer not set");
                    return this.layer.width;
                }
                set width(t) {
                    throw new Error(`${this.constructor.name}-width is not yet implemented`);
                }
                get height() {
                    if (!this.layer) throw new Error("layer not set");
                    return this.layer.height;
                }
                set height(t) {
                    throw new Error(`${this.constructor.name}-height is not yet implemented`);
                }
                get deltas() {
                    if (!this.layer) throw new Error("layer not set");
                    return this.layer.deltas;
                }
                set deltas(t) {
                    if (!this.layer) throw new Error("layer not set");
                    X(this.layer.deltas), this.layer.deltas = t;
                }
                get weights() {
                    if (!this.layer) throw new Error("layer not set");
                    return this.layer.weights;
                }
                set weights(t) {
                    if (!this.layer) throw new Error("layer not set");
                    X(this.layer.weights), this.layer.weights = t;
                }
                predict() {}
                compare() {}
                learn() {
                    throw new Error("no longer using");
                }
                setupKernels() {}
                reuseKernels() {}
            }
            class Ls extends Ce {
                constructor(t = {}){
                    super(t), this.trainOpts = {}, this._outputConnection = null, this._layerSets = [], this._hiddenLayerOutputIndices = [], this._model = null;
                }
                _connectLayers() {
                    if (!this.options.inputLayer) throw new Error("inputLayer not found");
                    if (!this.options.outputLayer) throw new Error("outputLayer not found");
                    const t = this.options.inputLayer(), e = this._connectHiddenLayers(t), i = this.options.outputLayer(e[e.length - 1], -1);
                    return {
                        inputLayer: t,
                        hiddenLayers: e,
                        outputLayer: i
                    };
                }
                _connectLayersDeep() {
                    const t = [], e = this._layerSets[this._layerSets.length - 1];
                    let i = 0;
                    function h(p) {
                        const d = e.indexOf(p);
                        if (d < 0) throw new Error("unable to find layer");
                        return t[d];
                    }
                    function u(p) {
                        return {
                            ...p.settings,
                            weights: null,
                            deltas: null,
                            praxis: null
                        };
                    }
                    for(let p = 0; p < e.length; p++){
                        const d = e[p];
                        let l;
                        if (d instanceof Te) l = new d.constructor(h(d.inputLayer), u(d));
                        else if (d instanceof ci) l = new d.constructor(u(d));
                        else if (d instanceof Se) l = new d.constructor(u(d.inputLayer), h(d.inputLayer));
                        else if (d instanceof Ae) {
                            const a = e[this._hiddenLayerOutputIndices[i++]];
                            if (d instanceof ks) throw new Error("unfinished");
                            if (d instanceof We) l = new We(a);
                            else if (d instanceof je) l = new We(a);
                            else throw new Error(`hidden layer ${d.constructor.name} extends unknown hidden layer`);
                        } else if (d instanceof li || d instanceof he) l = d;
                        else if (d instanceof De) l = new d.constructor(h(d.inputLayer), u(d.inputLayer));
                        else if (d instanceof $e) l = new d.constructor(h(d.inputLayer1), h(d.inputLayer2), u(d));
                        else if (d instanceof Oe) l = new d.constructor(u(d), h(d.inputLayer));
                        else throw new Error(`hidden layer ${d.constructor.name} extends unknown hidden layer`);
                        t.push(l);
                    }
                    return t;
                }
                _connectHiddenLayers(t) {
                    const e = [];
                    if (!this.options.hiddenLayers) throw new Error("hiddenLayers not defined");
                    for(let i = 0; i < this.options.hiddenLayers.length; i++){
                        const h = new je, u = this.options.hiddenLayers[i](t, h, i);
                        t = u, e.push(u);
                    }
                    return e;
                }
                initialize() {
                    this._outputConnection = new ks;
                    let t;
                    if (this.options.layers) t = this._connectOptionsLayers();
                    else {
                        const { inputLayer: e, hiddenLayers: i, outputLayer: h } = this._connectLayers();
                        t = Hi([
                            e,
                            ...i,
                            h
                        ]), this._hiddenLayerOutputIndices = i.map((u)=>t.indexOf(u)), this._inputLayer = e, this._hiddenLayers = i, this._outputLayer = h;
                    }
                    this.layers = t, this._layerSets = [
                        t
                    ], this._model = t.filter((e)=>e instanceof he || e instanceof li), this.initializeLayers(t);
                }
                initializeDeep() {
                    const t = this._connectLayersDeep();
                    for(let e = 0; e < t.length; e++){
                        const i = t[e];
                        i.setupKernels(!0), i.reuseKernels(this._layerSets[0][e]);
                    }
                    this._layerSets.push(t);
                }
                run(t) {
                    for(; this._layerSets.length <= t.length;)this.initializeDeep();
                    const e = this.runInputs(t);
                    return e instanceof wt.Texture ? e.toArray() : e;
                }
                runInput(t) {
                    throw new Error("use .runInputs()");
                }
                runInputs(t) {
                    for(; this._layerSets.length < t.length;)this.initializeDeep();
                    const e = t.length - 1;
                    for(let u = 0; u <= e; u++){
                        const p = this._layerSets[u];
                        p[0].predict(t[u]);
                        for(let d = 1; d < p.length; d++)p[d].predict();
                    }
                    const i = this._layerSets[e], h = i[i.length - 1].weights;
                    return this.end(), h;
                }
                train(t, e = {}) {
                    const { preparedData: i, status: h, endTime: u } = this._prepTraining(t, e);
                    let p = !0;
                    const d = ()=>this._calculateTrainingError(i), l = ()=>this._trainPatterns(i);
                    for(; p;)p = this._trainingTick(h, u, d, l);
                    return h;
                }
                end() {
                    const t = this._layerSets.length - 1, e = this._layerSets[t];
                    e[0].predict([
                        new Float32Array([
                            0
                        ])
                    ]);
                    for(let i = 1; i < e.length; i++)e[i].predict();
                }
                transferData(t) {
                    return t;
                }
                _prepTraining(t, e) {
                    this._updateTrainingOptions(e);
                    const i = this.trainOpts.timeout ? Date.now() + this.trainOpts.timeout : 0, h = {
                        error: 1,
                        iterations: 0
                    };
                    return this.verifyIsInitialized(), {
                        preparedData: this.transferData(t),
                        status: h,
                        endTime: i
                    };
                }
                _calculateTrainingError(t) {
                    if (!this.meanSquaredError) throw new Error("this.meanSquaredError not setup");
                    let e = new Float32Array(1);
                    for(let h = 0; h < t.length; ++h){
                        const u = e, p = this._trainPattern(t[h], !0);
                        e = this.meanSquaredError.add(e, p), X(p), X(u);
                    }
                    const i = this.meanSquaredError.divide(t.length, e);
                    return X(e), i instanceof wt.Texture ? i.toArray()[0] : i[0];
                }
                formatData(t) {
                    return t;
                }
                _calculateDeltas(t) {
                    const e = this._layerSets[this._layerSets.length - 1];
                    for(let i = e.length - 2; i >= 0; i--)e[i].compare();
                    for(let i = t.length - 2; i >= 0; i--){
                        const h = this._layerSets[i];
                        h[h.length - 1].compare(t[i + 1]);
                        for(let u = h.length - 2; u >= 0; u--)h[u].compare();
                    }
                }
                adjustWeights() {
                    var t;
                    const e = this._model;
                    for(let i = 0; i < e.length; i++)e[i].learn((t = this.options.learningRate) !== null && t !== void 0 ? t : 0);
                }
                _trainPatterns(t) {
                    for(let e = 0; e < t.length; ++e)this._trainPattern(t[e], !1);
                }
                _trainPattern(t, e) {
                    if (this.runInputs(t), this._calculateDeltas(t), this.adjustWeights(), e) {
                        if (!this.meanSquaredError) throw new Error("this.meanSquaredError not setup");
                        let i = new Float32Array(1);
                        for(let h = 0, u = t.length - 2; h <= u; h++){
                            const p = this._layerSets[h], d = p[p.length - 1], l = i;
                            i = this.meanSquaredError.addAbsolute(l, d.errors), X(l);
                        }
                        return Xt(this.meanSquaredError.divide(t.length, i));
                    }
                    return null;
                }
            }
            class gt {
                constructor(t, e){
                    this.rows = 0, this.columns = 0, t && (this.rows = t), e && (this.columns = e), this.weights = Vt(this.rows * this.columns), this.deltas = Vt(this.rows * this.columns);
                }
                getWeight(t, e) {
                    const i = this.columns * t + e;
                    if (i < 0 || i >= this.weights.length) throw new Error("get accessor is skewed");
                    return this.weights[i];
                }
                setWeight(t, e, i) {
                    const h = this.columns * t + e;
                    if (h < 0 || h >= this.weights.length) throw new Error("set accessor is skewed");
                    return this.weights[h] = i, this;
                }
                getDelta(t, e) {
                    const i = this.columns * t + e;
                    if (i < 0 || i >= this.deltas.length) throw new Error("get accessor is skewed");
                    return this.deltas[i];
                }
                setDelta(t, e, i) {
                    const h = this.columns * t + e;
                    if (h < 0 || h >= this.weights.length) throw new Error("set accessor is skewed");
                    return this.deltas[h] = i, this;
                }
                toJSON() {
                    return {
                        rows: this.rows,
                        columns: this.columns,
                        weights: Array.from(this.weights.slice(0))
                    };
                }
                static fromJSON(t) {
                    const e = new gt(t.rows, t.columns);
                    for(let i = 0, h = t.rows * t.columns; i < h; i++)e.weights[i] = t.weights[i];
                    return e;
                }
                static fromArray(t) {
                    const e = new gt(t.length, t[0].length);
                    return e.fromArray(t), e;
                }
                deltasToArray() {
                    return this.toArray("deltas");
                }
                weightsToArray() {
                    return this.toArray("weights");
                }
                toArray(t = "weights") {
                    const e = new Array(this.rows);
                    return this.iterate({
                        row: (i)=>{
                            e[i] = new Array(this.columns);
                        },
                        column: (i, h)=>{
                            t === "weights" ? e[i][h] = this.getWeight(i, h) : t === "deltas" && (e[i][h] = this.getDelta(i, h));
                        }
                    }), e;
                }
                fromArray(t, e = "weights") {
                    if (t.length !== this.rows) throw new Error("rows do not match");
                    if (t[0].length !== this.columns) throw new Error("columns do not match");
                    return this.iterate({
                        column: (i, h)=>{
                            const u = t[i][h];
                            if (typeof u != "number") throw new Error("value not number");
                            e === "weights" ? this.setWeight(i, h, u) : e === "deltas" && this.setDelta(i, h, u);
                        }
                    }), this;
                }
                iterate(t) {
                    const e = this.rows, i = this.columns;
                    for(let h = 0; h < e; h++){
                        t.row && t.row(h);
                        for(let u = 0; u < i; u++)t.column && t.column(h, u);
                    }
                    return this;
                }
            }
            class Rt extends gt {
                constructor(t, e, i){
                    super(t, e), this.std = i;
                    for(let h = 0, u = this.weights.length; h < u; h++)this.weights[h] = be(-i, i);
                }
            }
            class Jt {
                constructor(t, e = 0){
                    this.values = t, this.indexTable = {}, this.characterTable = {}, this.characters = [], this.specialIndexes = [], this.isSetup = !1, t !== void 0 && this.setup(t, e);
                }
                setup(t, e = 0) {
                    if (this.isSetup) throw new Error("DataFormatter is already setup");
                    this.values = t, this.buildCharactersFromIterable(t), this.buildTables(e), t[0].input && this.addInputOutput(), this.addUnrecognized(), this.isSetup = !0;
                }
                buildCharactersFromIterable(t) {
                    const e = {};
                    for(let i = 0, h = t.length; i < h; i++){
                        const u = t[i];
                        if (u.hasOwnProperty("length")) {
                            const p = u;
                            for(let d = 0, l = p.length; d < l; d++){
                                const a = p[d];
                                e.hasOwnProperty(a) || (e[a] = !0, this.characters.push(a));
                            }
                        } else if (typeof u == "number") {
                            if (e.hasOwnProperty(u)) continue;
                            e[u] = !0, this.characters.push(u);
                        } else if (typeof u == "boolean") {
                            const p = u.toString();
                            if (e.hasOwnProperty(p)) continue;
                            e[p] = !0, this.characters.push(p);
                        } else if (Array.isArray(u) && typeof u[0] == "string") for(let p = 0; p < u.length; p++){
                            const d = u[p];
                            e.hasOwnProperty(d) || (e[d] = !0, this.characters.push(d));
                        }
                        else if (Array.isArray(u) && (typeof u[0] == "number" || typeof u[0] == "boolean")) for(let p = 0; p < u.length; p++){
                            const d = u[p].toString();
                            e.hasOwnProperty(i) || (e[d] = !0, this.characters.push(d));
                        }
                        else if (u.hasOwnProperty("input") && u.hasOwnProperty("output")) {
                            const { input: p, output: d } = u;
                            Array.isArray(p) ? this.addCharacters(p, e) : this.addCharacters(p.toString(), e), Array.isArray(d) ? this.addCharacters(d, e) : this.addCharacters(d.toString(), e);
                        } else throw new Error("Unhandled value");
                    }
                }
                addCharacters(t, e) {
                    for(let i = 0; i < t.length; i++){
                        const h = t[i].toString();
                        e.hasOwnProperty(h) || (e[h] = !0, this.characters.push(h));
                    }
                }
                buildTables(t) {
                    const e = this.characters.length;
                    for(let i = 0; i < e; i++){
                        const h = this.characters[i];
                        i >= t && (this.indexTable[h] = i, this.characterTable[i] = h);
                    }
                }
                toIndexes(t, e = 0) {
                    const i = [], { indexTable: h } = this;
                    switch(typeof t){
                        case "number":
                        case "boolean":
                            t = t.toString();
                    }
                    for(let u = 0, p = t.length; u < p; u++){
                        const d = t[u].toString();
                        let l = h[d];
                        if (l === void 0) if (h.unrecognized) l = h.unrecognized;
                        else throw new Error(`unrecognized character "${d}"`);
                        l < e || i.push(l);
                    }
                    return i;
                }
                toIndexesInputOutput(t, e, i = 0) {
                    const h = this.toIndexesValue(t, i, !0);
                    return typeof e > "u" ? h : h.concat(this.toIndexesValue(e, i, !1));
                }
                toIndexesValue(t, e, i) {
                    if (typeof t == "string") t = t.split("");
                    else if (typeof t == "number" || typeof t == "boolean") t = t.toString().split("");
                    else if (Array.isArray(t) && (typeof t[0] == "number" || typeof t[0] == "boolean" || typeof t[0] == "string")) t = t.map((h)=>h.toString());
                    else throw new Error("unrecognized value");
                    return i && (t = t.concat([
                        "stop-input",
                        "start-output"
                    ])), this.toIndexes(t, e);
                }
                toCharacters(t, e = 0) {
                    const i = [], { indexTable: h, characterTable: u } = this;
                    for(let p = 0, d = t.length; p < d; p++){
                        const l = t[p];
                        if (l < e) continue;
                        let a = u[l];
                        if (a === void 0) if (h.unrecognized) a = u[h.unrecognized];
                        else throw new Error(`unrecognized index "${l}"`);
                        else a !== null && i.push(a.toString());
                    }
                    return i;
                }
                toString(t, e) {
                    return this.toCharacters(t, e).join("");
                }
                addInputOutput() {
                    this.addSpecial("stop-input"), this.addSpecial("start-output");
                }
                addUnrecognized() {
                    this.addSpecial("unrecognized");
                }
                static fromAllPrintable(t, e = [
                    `
`
                ]) {
                    for(let i = 32; i <= 126; i++)e.push(String.fromCharCode(i));
                    return new Jt(e, t);
                }
                static fromAllPrintableInputOutput(t, e = [
                    `
`
                ]) {
                    const i = Jt.fromAllPrintable(t, e);
                    return i.addInputOutput(), i.addUnrecognized(), i;
                }
                static fromStringInputOutput(t, e) {
                    const i = Array.from(new Set(t)).join(""), h = new Jt(i.split(""), e);
                    return h.addInputOutput(), h.addUnrecognized(), h.isSetup = !0, h;
                }
                static fromArrayInputOutput(t, e) {
                    const i = [];
                    for(let p = 0; p < t.length; p++){
                        const d = t[p];
                        i.push(Re(d.input), Re(d.output));
                    }
                    const h = Array.isArray(i) ? i.flat() : i, u = new Jt(Array.from(new Set(h)), e);
                    return u.addInputOutput(), u.addUnrecognized(), u.isSetup = !0, u;
                }
                static fromString(t, e = 0) {
                    const i = Array.from(new Set(t)).join("");
                    return new Jt(i.split(""), e);
                }
                toJSON() {
                    return {
                        indexTable: this.indexTable,
                        characterTable: this.characterTable,
                        values: this.values,
                        characters: this.characters,
                        specialIndexes: this.specialIndexes
                    };
                }
                static fromJSON(t) {
                    const e = new Jt;
                    return e.indexTable = t.indexTable, e.characterTable = t.characterTable, e.values = t.values, e.characters = t.characters, e.specialIndexes = t.specialIndexes, e.isSetup = !0, e;
                }
                addSpecial(t, e = null) {
                    const i = this.indexTable[t] = this.characters.length;
                    this.characterTable[i] = e, this.specialIndexes.push(this.characters.length), this.characters.push(t);
                }
                toFunctionString() {
                    return `
var characterTable = ${JSON.stringify(this.characterTable)};
var indexTable = ${JSON.stringify(this.indexTable)};
var characters = ${JSON.stringify(this.characters)};
var dataFormatter = {
  toIndexes: function ${this.toIndexes.toString()},
  toIndexesInputOutput: function ${this.toIndexesInputOutput.toString()},
  toCharacters: function ${this.toCharacters.toString()},
  toIndexesValue: function ${this.toIndexesValue.toString()},
};`;
                }
                formatDataIn(t, e) {
                    var i;
                    return t === void 0 ? [] : Array.isArray(t) && typeof t[0] == "number" ? t : !((i = this.indexTable) === null || i === void 0) && i.hasOwnProperty("stop-input") ? this.toIndexesInputOutput(t, e) : this.toIndexes(t);
                }
                formatDataOut(t, e) {
                    return this.toCharacters(e).join("");
                }
                format(t) {
                    if (typeof t[0] == "number" && !Array.isArray(t[0]) && (!t[0].hasOwnProperty("input") || !t[0].hasOwnProperty("output"))) return t;
                    const e = [];
                    if (typeof t[0] == "string" || typeof t[0] == "number" || Array.isArray(t[0])) if (this.isSetup) for(let i = 0, h = t.length; i < h; i++)e.push(this.formatDataIn(t[i]));
                    else {
                        this.setup(t);
                        for(let i = 0; i < t.length; i++)e.push(this.formatDataIn(Re(t[i])));
                    }
                    else if (t[0].input && t[0].output) {
                        this.isSetup || this.setup(t);
                        for(let i = 0, h = t.length; i < h; i++)e.push(this.formatDataIn(Re(t[i].input), Re(t[i].output)));
                    } else throw new Error("unrecognized data");
                    return e;
                }
            }
            function Re(c) {
                if (typeof c == "string") return c;
                if (typeof c == "number" || typeof c == "boolean") return c.toString();
                if (Array.isArray(c) && typeof c[0] == "string") return c;
                if (typeof c[0] == "boolean") return c.map((t)=>t.toString());
                if (typeof c[0] == "number") return c.map((t)=>t.toString());
                throw new Error("unrecognized value, expected string[], string, number[], number, boolean[], or boolean");
            }
            function oa(c, t) {
                c.rows = t.rows, c.columns = t.columns, c.weights = t.weights.slice(0), c.deltas = t.deltas.slice(0);
            }
            function ua(c, t, e) {
                for(let i = 0; i < t.weights.length; i++)c.weights[i] = t.weights[i] + e.weights[i], c.deltas[i] = 0;
            }
            function ha(c, t, e) {
                for(let i = 0; i < c.deltas.length; i++)t.deltas[i] = c.deltas[i], e.deltas[i] = c.deltas[i];
            }
            function la(c) {
                for(let t = 0; t < c.weights.length; t++)c.weights[t] = 1, c.deltas[t] = 0;
            }
            function ca(c, t) {
                c.rows = t.rows, c.columns = t.columns, c.weights = t.weights.slice(0), c.deltas = t.deltas.slice(0);
                for(let e = 0; e < t.weights.length; e++)c.weights[e] = -t.weights[e], c.deltas[e] = 0;
            }
            function pa(c, t, e) {
                const i = t.rows, h = t.columns, u = e.columns;
                for(let p = 0; p < i; p++){
                    const d = h * p, l = u * p;
                    for(let a = 0; a < u; a++){
                        let o = 0;
                        for(let n = 0; n < h; n++){
                            const r = u * n, m = d + n, b = r + a;
                            o += t.weights[m] * e.weights[b], t.deltas[m] = 0, e.deltas[b] = 0;
                        }
                        c.weights[l + a] = o;
                    }
                }
            }
            function fa(c, t, e) {
                const i = t.rows, h = t.columns, u = e.columns;
                for(let p = 0; p < i; p++){
                    const d = h * p, l = u * p;
                    for(let a = 0; a < u; a++)for(let o = 0; o < h; o++){
                        const n = u * o, r = d + o, m = n + a, b = c.deltas[l + a];
                        t.deltas[r] += e.weights[m] * b, e.deltas[m] += t.weights[r] * b;
                    }
                }
            }
            function da(c, t, e) {
                const { weights: i } = t;
                for(let h = 0; h < i.length; h++)c.weights[h] = t.weights[h] * e.weights[h], c.deltas[h] = 0;
            }
            function ga(c, t, e) {
                for(let i = 0; i < t.weights.length; i++)t.deltas[i] = e.weights[i] * c.deltas[i], e.deltas[i] = t.weights[i] * c.deltas[i];
            }
            function ma(c, t) {
                for(let e = 0; e < t.weights.length; e++)c.weights[e] = Math.max(0, t.weights[e]), c.deltas[e] = 0;
            }
            function ya(c, t) {
                for(let e = 0; e < c.deltas.length; e++)t.deltas[e] = t.weights[e] > 0 ? c.deltas[e] : 0;
            }
            function xa(c, t, e) {
                const { columns: i } = t, h = i * e;
                for(let u = 0; u < i; u++)c.weights[u] = t.weights[h + u], c.deltas[u] = 0;
            }
            function ba(c, t, e) {
                const { columns: i } = t, h = i * e;
                for(let u = 0; u < i; u++)t.deltas[h + u] = c.deltas[u];
            }
            function wa(c, t) {
                for(let e = 0; e < t.weights.length; e++)c.weights[e] = 1 / (1 + Math.exp(-t.weights[e])), c.deltas[e] = 0;
            }
            function Ta(c, t) {
                for(let e = 0; e < c.deltas.length; e++){
                    const i = c.weights[e];
                    t.deltas[e] = i * (1 - i) * c.deltas[e];
                }
            }
            function He(c) {
                const t = new gt(c.rows, c.columns);
                let e = -999999;
                for(let h = 0; h < c.weights.length; h++)c.weights[h] > e && (e = c.weights[h]);
                let i = 0;
                for(let h = 0; h < c.weights.length; h++)t.weights[h] = Math.exp(c.weights[h] - e), i += t.weights[h];
                for(let h = 0; h < c.weights.length; h++)t.weights[h] /= i;
                return t;
            }
            function Sa(c, t) {
                for(let e = 0; e < t.weights.length; e++)c.weights[e] = Math.tanh(t.weights[e]), c.deltas[e] = 0;
            }
            function va(c, t) {
                for(let e = 0; e < c.deltas.length; e++){
                    const i = c.weights[e];
                    t.deltas[e] = (1 - i * i) * c.deltas[e];
                }
            }
            class Is {
                constructor(){
                    this.states = [], this.inputRow = 0;
                }
                add(t, e) {
                    if (t.weights.length !== e.weights.length) throw new Error("misaligned matrices");
                    const i = new gt(t.rows, t.columns);
                    return this.states.push({
                        name: "add",
                        product: i,
                        left: t,
                        right: e,
                        forwardFn: ua,
                        backpropagationFn: ha
                    }), i;
                }
                allOnes(t, e) {
                    const i = new gt(t, e);
                    return this.states.push({
                        name: "allOnes",
                        product: i,
                        left: i,
                        forwardFn: la,
                        backpropagationFn: ()=>{}
                    }), i;
                }
                cloneNegative(t) {
                    const e = new gt(t.rows, t.columns);
                    return this.states.push({
                        name: "cloneNegative",
                        product: e,
                        left: t,
                        forwardFn: ca,
                        backpropagationFn: ()=>{}
                    }), e;
                }
                subtract(t, e) {
                    if (t.weights.length !== e.weights.length) throw new Error("misaligned matrices");
                    return this.add(this.add(this.allOnes(t.rows, t.columns), this.cloneNegative(t)), e);
                }
                multiply(t, e) {
                    if (t.columns !== e.rows) throw new Error("misaligned matrices");
                    const i = new gt(t.rows, e.columns);
                    return this.states.push({
                        name: "multiply",
                        product: i,
                        left: t,
                        right: e,
                        forwardFn: pa,
                        backpropagationFn: fa
                    }), i;
                }
                multiplyElement(t, e) {
                    if (t.weights.length !== e.weights.length) throw new Error("misaligned matrices");
                    const i = new gt(t.rows, t.columns);
                    return this.states.push({
                        name: "multiplyElement",
                        product: i,
                        left: t,
                        right: e,
                        forwardFn: da,
                        backpropagationFn: ga
                    }), i;
                }
                relu(t) {
                    const e = new gt(t.rows, t.columns);
                    return this.states.push({
                        name: "relu",
                        product: e,
                        left: t,
                        forwardFn: ma,
                        backpropagationFn: ya
                    }), e;
                }
                input(t) {
                    return this.states.push({
                        name: "input",
                        product: t,
                        forwardFn: (e)=>{
                            if (this.inputValue) {
                                if (this.inputValue.length !== e.weights.length) throw new Error("this.inputValue is of wrong dimensions");
                                e.weights = t.weights = this.inputValue;
                            }
                        },
                        backpropagationFn: ()=>{}
                    }), t;
                }
                inputMatrixToRow(t) {
                    const e = this, i = new gt(t.columns, 1);
                    return this.states.push({
                        name: "inputMatrixToRow",
                        product: i,
                        left: t,
                        get right () {
                            return e.inputRow;
                        },
                        forwardFn: xa,
                        backpropagationFn: ba
                    }), i;
                }
                sigmoid(t) {
                    const e = new gt(t.rows, t.columns);
                    return this.states.push({
                        name: "sigmoid",
                        product: e,
                        left: t,
                        forwardFn: wa,
                        backpropagationFn: Ta
                    }), e;
                }
                tanh(t) {
                    const e = new gt(t.rows, t.columns);
                    return this.states.push({
                        name: "tanh",
                        product: e,
                        left: t,
                        forwardFn: Sa,
                        backpropagationFn: va
                    }), e;
                }
                observe(t) {
                    return this.states.push({
                        name: "observe",
                        product: new gt,
                        forwardFn: ()=>{},
                        backpropagationFn: ()=>{}
                    }), t;
                }
                runIndex(t = 0) {
                    this.inputRow = t;
                    let e = this.states[0];
                    for(let i = 0, h = this.states.length; i < h; i++)e = this.states[i], e.hasOwnProperty("forwardFn") && e.forwardFn(e.product, e.left, e.right);
                    return e.product;
                }
                runInput(t) {
                    this.inputValue = t;
                    let e = this.states[0];
                    for(let i = 0, h = this.states.length; i < h; i++)e = this.states[i], e.hasOwnProperty("forwardFn") && e.forwardFn(e.product, e.left, e.right);
                    return e.product;
                }
                backpropagate() {
                    let t = this.states.length, e = this.states[0];
                    for(; t-- > 0;)e = this.states[t], e.hasOwnProperty("backpropagationFn") && e.backpropagationFn(e.product, e.left, e.right);
                    return e.product;
                }
                backpropagateIndex(t = 0) {
                    this.inputRow = t;
                    let e = this.states.length, i = this.states[0];
                    for(; e-- > 0;)i = this.states[e], i.hasOwnProperty("backpropagationFn") && i.backpropagationFn(i.product, i.left, i.right);
                    return i.product;
                }
                predictTarget(t, e) {
                    let i = 0;
                    const h = this.runInput(t);
                    for(let u = 0; u < h.weights.length; u++){
                        const p = h.weights[u] - e[u];
                        i += Math.abs(p), h.deltas[u] = p;
                    }
                    return i;
                }
                predictTargetIndex(t, e) {
                    const i = this.runIndex(t), h = i, u = He(i);
                    return h.deltas = u.weights.slice(0), h.deltas[e] -= 1, -Math.log2(u.weights[e]);
                }
            }
            function xi(c) {
                const { weights: t } = c;
                let e = t[0], i = 0;
                for(let h = 1; h < t.length; h++){
                    const u = t[h];
                    u < e || (i = h, e = u);
                }
                return i;
            }
            function bi(c) {
                const t = be(0, 1), e = c.weights;
                let i = 0, h = 0;
                for(;;){
                    if (i += e[h], i > t) return h;
                    h++;
                }
            }
            const ve = {
                iterations: 2e4,
                errorThresh: .005,
                log: !1,
                logPeriod: 10,
                learningRate: .01,
                callbackPeriod: 10,
                timeout: 1 / 0
            }, Fe = ()=>({
                    inputSize: 20,
                    inputRange: 20,
                    hiddenLayers: [
                        20,
                        20
                    ],
                    outputSize: 20,
                    decayRate: .999,
                    smoothEps: 1e-8,
                    regc: 1e-6,
                    clipval: 5,
                    maxPredictionLength: 100,
                    dataFormatter: new Jt
                });
            class Me {
                constructor(t = {}){
                    this.options = {
                        ...Fe()
                    }, this.trainOpts = {
                        ...ve
                    }, this.stepCache = {}, this.runs = 0, this.ratioClipped = 0, this.model = Object.seal({
                        isInitialized: !1,
                        input: new gt(0, 0),
                        hiddenLayers: [],
                        output: new gt(0, 0),
                        equations: [],
                        allMatrices: [],
                        equationConnections: [],
                        outputConnector: new Rt(0, 0, .08)
                    }), this.initialLayerInputs = [], this.options = {
                        ...this.options,
                        ...t
                    }, this.updateTrainingOptions({
                        ...ve
                    }), t.json && this.fromJSON(t.json);
                }
                initialize() {
                    const { dataFormatter: t } = this.options;
                    t?.characters.length && (this.options.inputSize = this.options.inputRange = this.options.outputSize = t.characters.length), this.model = this.mapModel();
                }
                createHiddenLayers() {
                    const { hiddenLayers: t, inputSize: e } = this.options, i = [];
                    i.push(this.getHiddenLayer(t[0], e));
                    let h = t[0];
                    for(let u = 1; u < t.length; u++){
                        const p = t[u];
                        i.push(this.getHiddenLayer(p, h)), h = p;
                    }
                    return i;
                }
                getHiddenLayer(t, e) {
                    return {
                        weight: new Rt(t, e, .08),
                        transition: new Rt(t, t, .08),
                        bias: new gt(t, 1)
                    };
                }
                getEquation(t, e, i, h) {
                    if (!h.weight || !h.transition || !h.bias) throw new Error("hiddenLayer does not have expected properties");
                    const u = t.relu.bind(t), p = t.add.bind(t), d = t.multiply.bind(t);
                    return u(p(p(d(h.weight, e), d(h.transition, i)), h.bias));
                }
                createInputMatrix() {
                    const { inputRange: t, inputSize: e } = this.options;
                    if (t < 1) throw new Error("this.options.inputRange not an expected number");
                    if (e < 1) throw new Error("this.options.inputSize not an expected number");
                    return new Rt(t + 1, e, .08);
                }
                createOutputMatrices() {
                    const { outputSize: t, hiddenLayers: e } = this.options, i = wi(e);
                    return {
                        outputConnector: new Rt(t + 1, i, .08),
                        output: new gt(t + 1, 1)
                    };
                }
                bindEquation() {
                    const { model: t } = this, { hiddenLayers: e } = this.options, i = new Is, h = [], u = t.equationConnections.length > 0 ? wi(t.equationConnections) : this.initialLayerInputs;
                    let p = this.getEquation(i, i.inputMatrixToRow(t.input), u[0], t.hiddenLayers[0]);
                    h.push(p);
                    for(let d = 1, l = e.length; d < l; d++){
                        if (!u[d]) throw new Error(`Cannot find equation at index ${d}`);
                        p = this.getEquation(i, p, u[d], t.hiddenLayers[d]), h.push(p);
                    }
                    t.equationConnections.push(h), i.add(i.multiply(t.outputConnector, p), t.output), t.equations.push(i);
                }
                mapModel() {
                    const t = [];
                    this.initialLayerInputs = this.options.hiddenLayers.map((p)=>new gt(p, 1));
                    const e = this.createInputMatrix();
                    t.push(e);
                    const i = this.createHiddenLayers();
                    if (!i.length) throw new Error("net.hiddenLayers not set");
                    for(let p = 0, d = i.length; p < d; p++){
                        const l = i[p];
                        for(const a in l)l.hasOwnProperty(a) && t.push(l[a]);
                    }
                    const { output: h, outputConnector: u } = this.createOutputMatrices();
                    return t.push(u), t.push(h), Object.seal({
                        isInitialized: !0,
                        input: e,
                        hiddenLayers: i,
                        output: h,
                        equations: [],
                        allMatrices: t,
                        equationConnections: [],
                        outputConnector: u
                    });
                }
                trainInput(t) {
                    this.runs++;
                    const { model: e } = this, i = t.length;
                    let h = 0, u;
                    for(; e.equations.length <= t.length + 1;)this.bindEquation();
                    for(let p = -1, d = t.length; p < d; p++){
                        const l = p + 1;
                        u = e.equations[l];
                        const a = p === -1 ? 0 : t[p] + 1, o = p === i - 1 ? 0 : t[p + 1] + 1;
                        h += u.predictTargetIndex(a, o);
                    }
                    return Math.pow(2, h / (i - 1)) / 100;
                }
                backpropagate(t) {
                    let e = t.length;
                    const { model: i } = this, { equations: h } = i;
                    for(; e > 0;)h[e].backpropagateIndex(t[e - 1] + 1), e--;
                    h[0].backpropagateIndex(0);
                }
                adjustWeights() {
                    const { regc: t, clipval: e, decayRate: i, smoothEps: h } = this.options, { trainOpts: u, model: p, stepCache: d } = this, { learningRate: l } = u, { allMatrices: a } = p;
                    let o = 0, n = 0;
                    for(let r = 0; r < a.length; r++){
                        const m = a[r], { weights: b, deltas: E } = m;
                        r in d || (d[r] = Vt(m.rows * m.columns));
                        const w = d[r];
                        for(let v = 0; v < b.length; v++){
                            let y = E[v];
                            const T = b[v];
                            w[v] = w[v] * i + (1 - i) * y * y, y > e ? (y = e, o++) : y < -e && (y = -e, o++), n++, b[v] = T + -l * y / Math.sqrt(w[v] + h) - t * T;
                        }
                    }
                    this.ratioClipped = o / n;
                }
                get isRunnable() {
                    return this.model && this.model.equations.length === 0 ? (console.error("No equations bound, did you run train()?"), !1) : !0;
                }
                checkRunnable() {
                    if (!this.isRunnable) throw new Error("Network not runnable");
                }
                run(t = [], e = !1, i = 1) {
                    const h = this.options.maxPredictionLength + (t !== null ? t.length : 0) + (this.options.dataFormatter ? this.options.dataFormatter.specialIndexes.length : 0);
                    this.checkRunnable();
                    const u = this.options.dataFormatter && t.length > 0 ? this.options.dataFormatter.formatDataIn(t) : t, { model: p } = this, d = [];
                    let l = 0;
                    for(;;){
                        const a = l === 0 ? 0 : l < u.length ? u[l - 1] + 1 : d[l - 1];
                        for(; p.equations.length <= l;)this.bindEquation();
                        const n = p.equations[l].runIndex(a), r = new gt(p.output.rows, p.output.columns);
                        if (oa(r, n), i !== 1 && e) for(let E = 0, w = r.weights.length; E < w; E++)r.weights[E] /= i;
                        const m = He(r), b = e ? bi(m) : xi(m);
                        if (l++, b === 0 || l >= h) break;
                        d.push(b);
                    }
                    return this.options.dataFormatter.formatDataOut(u, d.slice(u.length).map((a)=>a - 1));
                }
                verifyIsInitialized() {
                    this.model.isInitialized || this.initialize();
                }
                updateTrainingOptions(t) {
                    var e;
                    this.trainOpts = {
                        ...ve,
                        ...t
                    }, this.validateTrainingOptions(this.trainOpts), this.setLogMethod((e = t.log) !== null && e !== void 0 ? e : this.trainOpts.log);
                }
                validateTrainingOptions(t) {
                    const e = {
                        iterations: ()=>{
                            const i = t.iterations;
                            return typeof i == "number" && i > 0;
                        },
                        errorThresh: ()=>{
                            const i = t.errorThresh;
                            return typeof i == "number" && i > 0 && i < 1;
                        },
                        log: ()=>{
                            const i = t.log;
                            return typeof i == "function" || typeof i == "boolean";
                        },
                        logPeriod: ()=>{
                            const i = t.logPeriod;
                            return typeof i == "number" && i > 0;
                        },
                        learningRate: ()=>{
                            const i = t.learningRate;
                            return typeof i == "number" && i > 0 && i < 1;
                        },
                        callback: ()=>{
                            const i = t.callback;
                            return typeof i == "function" || i === void 0;
                        },
                        callbackPeriod: ()=>{
                            const i = t.callbackPeriod;
                            return typeof i == "number" && i > 0;
                        },
                        timeout: ()=>{
                            const i = t.timeout;
                            return typeof i == "number" && i > 0;
                        }
                    };
                    for(const i in e){
                        const h = t;
                        if (!e[i]()) throw new Error(`[${i}, ${h[i]}] is out of normal training range, your network will probably not train.`);
                    }
                }
                setLogMethod(t) {
                    typeof t == "function" ? this.trainOpts.log = t : t ? this.trainOpts.log = console.log : this.trainOpts.log = !1;
                }
                prepTraining(t, e) {
                    var i;
                    this.updateTrainingOptions(e);
                    const h = this.options.dataFormatter.format(t), u = Date.now() + ((i = this.trainOpts.timeout) !== null && i !== void 0 ? i : 0), p = {
                        error: 1,
                        iterations: 0
                    };
                    return this.verifyIsInitialized(), {
                        preparedData: h,
                        status: p,
                        endTime: u
                    };
                }
                train(t, e = {}) {
                    var i;
                    this.trainOpts = e = {
                        ...ve,
                        ...e
                    };
                    const { iterations: h, errorThresh: u, logPeriod: p, callback: d, callbackPeriod: l } = this.trainOpts, a = e.log === !0 ? console.log : e.log;
                    let o = 1 / 0, n, r;
                    if (!((i = this.options) === null || i === void 0) && i.dataFormatter) r = this.options.dataFormatter.format(t);
                    else if (Array.isArray(t) && Array.isArray(t[0]) && typeof t[0][0] == "number") r = t;
                    else throw new Error("training not in expected format of number[][]");
                    for(this.verifyIsInitialized(), n = 0; n < h && o > u; n++){
                        let m = 0;
                        for(let b = 0; b < r.length; b++){
                            const E = this.trainPattern(r[b], !0);
                            m += E;
                        }
                        if (o = m / t.length, isNaN(o)) throw new Error("Network error rate is unexpected NaN, check network configurations and try again. Most probably input format is not correct or training data is not enough. ");
                        a && n % p === 0 && a(`iterations: ${n}, training error: ${o}`), d && n % l === 0 && d({
                            error: o,
                            iterations: n
                        });
                    }
                    return {
                        error: o,
                        iterations: n
                    };
                }
                addFormat(t) {}
                formatData(t) {
                    const e = [];
                    for(let i = 0; i < t.length; i++)e.push(this.options.dataFormatter.formatDataIn(t[i]));
                    return e;
                }
                toJSON() {
                    this.model.isInitialized || this.initialize();
                    const { model: t, options: e } = this;
                    return {
                        type: this.constructor.name,
                        options: {
                            ...e,
                            dataFormatter: e.dataFormatter.toJSON()
                        },
                        trainOpts: {
                            ...this.trainOpts,
                            timeout: this.trainOpts.timeout === 1 / 0 ? "Infinity" : this.trainOpts.timeout
                        },
                        input: t.input.toJSON(),
                        hiddenLayers: t.hiddenLayers.map((i)=>{
                            const h = {};
                            for(const u in i)i.hasOwnProperty(u) && (h[u] = i[u].toJSON());
                            return h;
                        }),
                        outputConnector: this.model.outputConnector.toJSON(),
                        output: this.model.output.toJSON()
                    };
                }
                fromJSON(t) {
                    const { options: e } = t, i = [], h = gt.fromJSON(t.input);
                    i.push(h);
                    const u = [];
                    t.hiddenLayers.forEach((l)=>{
                        const a = {};
                        for(const o in l)a[o] = gt.fromJSON(l[o]), i.push(a[o]);
                        u.push(a);
                    });
                    const p = gt.fromJSON(t.outputConnector);
                    i.push(p);
                    const d = gt.fromJSON(t.output);
                    return i.push(d), e.dataFormatter ? this.options = {
                        ...Fe(),
                        ...e,
                        dataFormatter: Jt.fromJSON(e.dataFormatter)
                    } : this.options = {
                        ...Fe(),
                        ...e,
                        dataFormatter: new Jt
                    }, this.model = Object.seal({
                        isInitialized: !0,
                        input: h,
                        hiddenLayers: u,
                        output: d,
                        allMatrices: i,
                        outputConnector: p,
                        equations: [],
                        equationConnections: []
                    }), this.initialLayerInputs = this.options.hiddenLayers.map((l)=>new gt(l, 1)), this.bindEquation(), this;
                }
                toFunction(t) {
                    const { model: e } = this, { equations: i } = this.model, h = i[1], { states: u } = h, p = JSON.stringify(this.toJSON());
                    function d(w) {
                        const v = e.equationConnections[0], { states: y } = i[0];
                        for(let T = 0, _ = y.length; T < _; T++)if (y[T].product === w) return T;
                        return v.indexOf(w);
                    }
                    function l(w, v) {
                        for(let y = 0, T = u.length; y < T; y++){
                            const _ = u[y];
                            if (y === v) {
                                const k = d(w);
                                return k > -1 && (w === _.left || w === _.right) ? `typeof prevStates[${k}] === 'object' ? prevStates[${k}].product : new Matrix(${w.rows}, ${w.columns})` : `new Matrix(${w.rows}, ${w.columns})`;
                            }
                            if (w === _.product) return `states[${y}].product`;
                            if (w === _.right) return `states[${y}].right`;
                            if (w === _.left) return `states[${y}].left`;
                        }
                        return "";
                    }
                    function a(w, v) {
                        if (!w || !w.rows || !w.columns) return "null";
                        if (w === e.input) return "json.input";
                        if (w === e.outputConnector) return "json.outputConnector";
                        if (w === e.output) return "json.output";
                        for(let y = 0, T = e.hiddenLayers.length; y < T; y++){
                            const _ = e.hiddenLayers[y];
                            for(const k in _)if (_.hasOwnProperty(k) && _[k] === w) return `json.hiddenLayers[${y}].${k}`;
                        }
                        return l(w, v);
                    }
                    function o(w) {
                        const v = w.toString().split("{");
                        v.shift();
                        const T = v.join("{").split("}");
                        return T.pop(), T.join("}").split(`
`).join(`
        `).replace("product.deltas[i] = 0;", "").replace("product.deltas[column] = 0;", "").replace("left.deltas[leftIndex] = 0;", "").replace("right.deltas[rightIndex] = 0;", "").replace("product.deltas = left.deltas.slice(0);", "");
                    }
                    function n(w) {
                        return `src/recurrent/matrix/${w.replace(/[A-Z]/g, function(v) {
                            return `-${v.toLowerCase()}`;
                        })}.js`;
                    }
                    const r = [], m = {}, b = [];
                    for(let w = 0, v = u.length; w < v; w++){
                        const y = u[w];
                        r.push(`states[${w}] = {
      name: '${y.forwardFn.name}',
      left: ${y.left ? a(y.left, w) : "undefined"},
      right: ${y.right ? a(y.right, w) : "undefined"},
      product: ${a(y.product, w)}
    }`);
                        const T = y.forwardFn.name;
                        m[T] || (m[T] = !0, b.push(`        case '${T}': //compiled from ${n(T)}
          ${o(y.forwardFn.toString())}
          break;`));
                    }
                    const E = `
  if (typeof rawInput === 'undefined') rawInput = [];
  if (typeof isSampleI === 'undefined') isSampleI = false;
  if (typeof temperature === 'undefined') temperature = 1;
  var json = ${p};
  ${this.options.dataFormatter ? `${this.options.dataFormatter.toFunctionString()};
  Object.assign(dataFormatter, json.options.dataFormatter);` : ""}
  ${this.options.dataFormatter && typeof this.options.dataFormatter.formatDataIn == "function" ? `const formatDataIn = function (input, output) { ${o(this.options.dataFormatter.formatDataIn.toString())} }.bind(dataFormatter);` : ""}
  ${this.options.dataFormatter !== null && typeof this.options.dataFormatter.formatDataOut == "function" ? `const formatDataOut = function formatDataOut(input, output) { ${o(this.options.dataFormatter.formatDataOut.toString())} }.bind(dataFormatter);` : ""}
  var maxPredictionLength =
    ${this.options.maxPredictionLength} +
    rawInput.length +
    ${this.options.dataFormatter ? this.options.dataFormatter.specialIndexes.length : 0};
  var input = ${this.options.dataFormatter && typeof this.options.dataFormatter.formatDataIn == "function" ? "formatDataIn(rawInput)" : "rawInput"};
  var _i = 0;
  var output = [];
  var states = [];
  var prevStates;
  while (true) {
    var previousIndex = (_i === 0
        ? 0
        : _i < input.length
          ? input[_i - 1] + 1
          : output[_i - 1])
          ;
    var rowPluckIndex = previousIndex;
    prevStates = states;
    states = [];
    ${r.join(`;
    `)};
    for (var stateIndex = 0, stateMax = ${r.length}; stateIndex < stateMax; stateIndex++) {
      var state = states[stateIndex];
      var product = state.product;
      var left = state.left;
      var right = state.right;
      switch (state.name) {
${b.join(`
`)}
      }
    }

    var logProbabilities = state.product;
    if (temperature !== 1 && isSampleI) {
      for (var q = 0, nq = logProbabilities.weights.length; q < nq; q++) {
        logProbabilities.weights[q] /= temperature;
      }
    }

    var probs = softmax(logProbabilities);
    var nextIndex = isSampleI ? sampleI(probs) : maxI(probs);

    _i++;
    if (nextIndex === 0) {
      break;
    }
    if (_i >= maxPredictionLength) {
      break;
    }

    output.push(nextIndex);
  }
  ${this.options.dataFormatter && typeof this.options.dataFormatter.formatDataOut == "function" ? "return formatDataOut(input, output.slice(input.length).map(function(value) { return value - 1; }))" : "return output.slice(input.length).map(function(value) { return value - 1; })"};
  function Matrix(rows, columns) {
    this.rows = rows;
    this.columns = columns;
    this.weights = zeros(rows * columns);
  }
  ${Vt.toString()}
  ${He.toString().replace("_1.Matrix", "Matrix")}
  ${be.toString()}
  ${bi.toString()}
  ${xi.toString()}`;
                    return new Function("rawInput", "isSampleI", "temperature", t ? t(E) : E);
                }
                trainPattern(t, e) {
                    const i = this.trainInput(t);
                    return this.backpropagate(t), this.adjustWeights(), e ? i : 0;
                }
            }
            function wi(c) {
                return c[c.length - 1];
            }
            class As extends Me {
                getHiddenLayer(t, e) {
                    return Ds(t, e);
                }
                getEquation(t, e, i, h) {
                    return $s(t, e, i, h);
                }
            }
            function Ds(c, t) {
                return {
                    updateGateInputMatrix: new Rt(c, t, .08),
                    updateGateHiddenMatrix: new Rt(c, c, .08),
                    updateGateBias: new gt(c, 1),
                    resetGateInputMatrix: new Rt(c, t, .08),
                    resetGateHiddenMatrix: new Rt(c, c, .08),
                    resetGateBias: new gt(c, 1),
                    cellWriteInputMatrix: new Rt(c, t, .08),
                    cellWriteHiddenMatrix: new Rt(c, c, .08),
                    cellWriteBias: new gt(c, 1)
                };
            }
            function $s(c, t, e, i) {
                if (!i.updateGateInputMatrix || !i.updateGateHiddenMatrix || !i.updateGateBias || !i.resetGateInputMatrix || !i.resetGateHiddenMatrix || !i.resetGateBias || !i.cellWriteInputMatrix || !i.cellWriteHiddenMatrix || !i.cellWriteBias) throw new Error("hiddenLayer does not have expected properties");
                const h = c.sigmoid.bind(c), u = c.add.bind(c), p = c.multiply.bind(c), d = c.multiplyElement.bind(c), l = c.tanh.bind(c), a = c.allOnes.bind(c), o = c.cloneNegative.bind(c), n = h(u(u(p(i.updateGateInputMatrix, t), p(i.updateGateHiddenMatrix, e)), i.updateGateBias)), r = h(u(u(p(i.resetGateInputMatrix, t), p(i.resetGateHiddenMatrix, e)), i.resetGateBias)), m = l(u(u(p(i.cellWriteInputMatrix, t), p(i.cellWriteHiddenMatrix, d(r, e))), i.cellWriteBias));
                return u(d(u(a(n.rows, n.columns), o(n)), m), d(e, n));
            }
            class Os {
                constructor(t, e){
                    this.prop = e, this.length = 0, this.table = {};
                    for(let i = 0; i < t.length; i++){
                        const u = t[i][e];
                        for(let p = 0; p < u.length; p++){
                            const d = u[p];
                            for(const l in d)d.hasOwnProperty(l) && (this.table.hasOwnProperty(l) || (this.table[l] = this.length++));
                        }
                    }
                }
            }
            const Cs = ()=>({
                    ...Fe(),
                    inputSize: 1,
                    hiddenLayers: [
                        20
                    ],
                    outputSize: 1,
                    inputRange: 0
                });
            class Xe extends Me {
                constructor(t = {}){
                    super(), this.inputLookupLength = 0, this.inputLookup = null, this.outputLookup = null, this.outputLookupLength = 0, this.model = Object.seal({
                        isInitialized: !1,
                        hiddenLayers: [],
                        output: new gt(0, 0),
                        equations: [],
                        allMatrices: [],
                        equationConnections: [],
                        outputConnector: new Rt(0, 0, .08)
                    }), this.options = Cs(), this.options = {
                        ...this.options,
                        ...t
                    }, this.updateTrainingOptions({
                        ..._a,
                        ...t
                    }), t.json && this.fromJSON(t.json);
                }
                createInputMatrix() {
                    throw new Error("Input Matrices do not exist on RNNTimeStep");
                }
                createOutputMatrices() {
                    const { outputSize: t } = this.options, e = wi(this.options.hiddenLayers), i = new Rt(t, e, .08);
                    return {
                        output: new Rt(t, 1, .08),
                        outputConnector: i
                    };
                }
                bindEquation() {
                    const { model: t, options: e } = this, { hiddenLayers: i, inputSize: h } = e, u = t.hiddenLayers, p = new Is, d = [], l = t.equationConnections.length > 0 ? t.equationConnections[t.equationConnections.length - 1] : this.initialLayerInputs;
                    let a = this.getEquation(p, p.input(new gt(h, 1)), l[0], u[0]);
                    d.push(a);
                    for(let o = 1, n = i.length; o < n; o++)a = this.getEquation(p, a, l[o], u[o]), d.push(a);
                    t.equationConnections.push(d), p.add(p.multiply(t.outputConnector, a), t.output), t.equations.push(p);
                }
                initialize() {
                    this.model = this.mapModel();
                }
                mapModel() {
                    const t = [];
                    this.initialLayerInputs = this.options.hiddenLayers.map((u)=>new gt(u, 1));
                    const e = this.createHiddenLayers();
                    for(let u = 0, p = e.length; u < p; u++){
                        const d = e[u];
                        for(const l in d)d.hasOwnProperty(l) && t.push(d[l]);
                    }
                    const { outputConnector: i, output: h } = this.createOutputMatrices();
                    return t.push(i), t.push(h), Object.seal({
                        isInitialized: !0,
                        hiddenLayers: e,
                        output: h,
                        equations: [],
                        allMatrices: t,
                        equationConnections: [],
                        outputConnector: i
                    });
                }
                backpropagate() {
                    for(let t = this.model.equations.length - 1; t > -1; t--)this.model.equations[t].backpropagate();
                }
                run(t) {
                    const e = dt.dataShape(t).join(",");
                    switch(e){
                        case "array,number":
                            return this.runArray(t);
                        case "array,array,number":
                            return this.runArrayOfArray(t);
                        case "object,number":
                            return this.runObject(t);
                        case "array,object,number":
                            return this.runArrayOfObject(t);
                        default:
                            throw new Error(`Unrecognized data shape ${e}`);
                    }
                }
                forecast(t, e = 1) {
                    const i = dt.dataShape(t).join(",");
                    switch(i){
                        case "array,number":
                            return this.forecastArray(t, e);
                        case "array,array,number":
                            return this.forecastArrayOfArray(t, e);
                        case "object,number":
                            return this.runObject(t);
                        case "array,object,number":
                            return this.forecastArrayOfObject(t, e);
                        default:
                            throw new Error(`Unrecognized data shape ${i}`);
                    }
                }
                forecastArray(t, e = 1) {
                    this.checkRunnable();
                    const { model: i } = this, { equations: h } = i, u = t.length + e;
                    for(; h.length <= u;)this.bindEquation();
                    let p, d = 0;
                    if (this.options.inputSize === 1) for(let a = 0; a < t.length; a++)p = h[d++].runInput(Float32Array.from([
                        t[a]
                    ]));
                    else for(let a = 0; a < t.length; a++)p = h[d++].runInput(Float32Array.from([]));
                    if (!p) throw new Error("lastOutput not set");
                    const l = [
                        p.weights[0]
                    ];
                    for(let a = 0, o = e - 1; a < o; a++)p = h[d++].runInput(p.weights), l.push(p.weights[0]);
                    return this.end(), Float32Array.from(l);
                }
                forecastArrayOfArray(t, e = 1) {
                    this.checkRunnable();
                    const { model: i } = this, { equations: h } = i, u = t.length + e;
                    for(; h.length <= u;)this.bindEquation();
                    let p, d = 0;
                    for(let a = 0; a < t.length; a++)p = h[d++].runInput(t[a]);
                    if (!p) throw new Error("lastOutput not set");
                    const l = [
                        Float32Array.from(p.weights)
                    ];
                    for(let a = 0, o = e - 1; a < o; a++)p = h[d++].runInput(p.weights), l.push(Float32Array.from(p.weights.slice(0)));
                    return this.end(), l;
                }
                forecastArrayOfObject(t, e = 1) {
                    if (!this.inputLookup) throw new Error("this.inputLookup not set");
                    if (!this.outputLookup) throw new Error("this.outputLookup not set");
                    const i = t.map((h)=>dt.toArray(this.inputLookup, h, this.inputLookupLength));
                    return this.forecastArrayOfArray(i, e).map((h)=>dt.toObject(this.outputLookup, h));
                }
                train(t, e = {}) {
                    this.trainOpts = e = {
                        ...ve,
                        ...e
                    }, this.options.inputSize === 1 && this.options.outputSize === 1 && this.setSize(t), this.verifySize();
                    const i = this.formatData(t);
                    let h = 1 / 0, u;
                    this.verifyIsInitialized();
                    const { iterations: p, errorThresh: d, logPeriod: l, callback: a, callbackPeriod: o } = this.trainOpts, n = e.log === !0 ? console.log : e.log;
                    for(u = 0; u < p && h > d; u++){
                        let r = 0;
                        for(let m = 0; m < i.length; m++){
                            const b = this.trainPattern(i[m], !0);
                            r += b;
                        }
                        if (h = r / i.length, isNaN(h)) throw new Error("Network error rate is unexpected NaN, check network configurations and try again. Most probably input format is not correct or training data is not enough. ");
                        n && u % l === 0 && n(`iterations: ${u}, training error: ${h}`), a && u % o === 0 && a({
                            error: h,
                            iterations: u
                        });
                    }
                    return {
                        error: h,
                        iterations: u
                    };
                }
                trainArrayOfArray(t) {
                    if (t.length < 2) throw new Error("input must be an array of 2 or more");
                    const { equations: e } = this.model;
                    for(; e.length < t.length;)this.bindEquation();
                    let i = 0;
                    for(let h = 0, u = t.length - 1; h < u; h++)i += e[h].predictTarget(t[h], t[h + 1]);
                    return this.end(), i / t.length;
                }
                trainPattern(t, e) {
                    const i = this.trainArrayOfArray(t);
                    return this.backpropagate(), this.adjustWeights(), e ? i : 0;
                }
                setSize(t) {
                    let e = 0;
                    switch(dt.dataShape(t).join(",")){
                        case "array,array,number":
                        case "array,object,number":
                        case "array,datum,array,number":
                        case "array,datum,object,number":
                            e = 1;
                            break;
                        case "array,array,array,number":
                            e = t[0][0].length;
                            break;
                        case "array,array,object,number":
                            e = Object.keys(dt.toTable2D(t)).length;
                            break;
                        case "array,datum,array,array,number":
                            e = t[0].input[0].length;
                            break;
                        case "array,datum,array,object,number":
                            e = Object.keys(dt.toInputTable2D(t)).length;
                            break;
                        default:
                            throw new Error("unknown data shape or configuration");
                    }
                    this.options = Object.seal({
                        ...this.options,
                        inputSize: e,
                        outputSize: e
                    });
                }
                verifySize() {
                    if ((this.options.inputSize || this.options.outputSize) && this.options.inputSize !== this.options.outputSize) throw new Error("manually set inputSize and outputSize mismatch");
                }
                runArray(t) {
                    this.checkRunnable();
                    const { equations: e } = this.model;
                    for(; e.length <= t.length;)this.bindEquation();
                    let i;
                    for(let h = 0; h < t.length; h++)i = e[h].runInput(new Float32Array([
                        t[h]
                    ]));
                    return this.end(), i.weights[0];
                }
                runArrayOfArray(t) {
                    this.checkRunnable();
                    const { model: e } = this, { equations: i } = e;
                    for(; i.length <= t.length;)this.bindEquation();
                    let h;
                    for(let u = 0; u < t.length; u++)h = i[u].runInput(t[u]).weights;
                    return this.end(), h ?? Float32Array.from([]);
                }
                runObject(t) {
                    if (!this.inputLookup) throw new Error("this.inputLookup not set");
                    if (!this.outputLookup) throw new Error("this.outputLookup not set");
                    if (!this.outputLookupLength) throw new Error("this.outputLookupLength not set");
                    if (this.inputLookup === this.outputLookup) {
                        const e = dt.toArrayShort(this.inputLookup, t);
                        return dt.toObjectPartial(this.outputLookup, this.forecastArray(e, this.outputLookupLength - e.length), e.length);
                    }
                    return dt.toObject(this.outputLookup, this.forecastArray(dt.toArray(this.inputLookup, t, this.inputLookupLength), this.outputLookupLength));
                }
                runArrayOfObject(t) {
                    if (this.inputLookup === null) throw new Error("this.inputLookup not set");
                    if (this.outputLookup === null) throw new Error("this.outputLookup not set");
                    const e = t.map((i)=>dt.toArray(this.inputLookup, i, this.inputLookupLength));
                    return this.forecastArrayOfArray(e, 1).map((i)=>dt.toObject(this.outputLookup, i))[0];
                }
                runArrayOfObjectOfArray(t) {
                    if (!this.inputLookup) throw new Error("this.inputLookup not set");
                    if (!this.outputLookup) throw new Error("this.outputLookup not set");
                    return dt.toObject(this.outputLookup, this.runArrayOfArray(dt.toArrays(this.inputLookup, t, this.inputLookupLength)));
                }
                end() {
                    this.model.equations[this.model.equations.length - 1].runInput(new Float32Array(this.options.outputSize));
                }
                requireInputOutputOfOne() {
                    if (this.options.inputSize !== 1) throw new Error("inputSize must be 1 for this data size");
                    if (this.options.outputSize !== 1) throw new Error("outputSize must be 1 for this data size");
                }
                formatArray(t) {
                    const e = [];
                    this.requireInputOutputOfOne();
                    for(let i = 0; i < t.length; i++)e.push(Float32Array.from([
                        t[i]
                    ]));
                    return [
                        e
                    ];
                }
                formatArrayOfArray(t) {
                    const e = [], { inputSize: i, outputSize: h } = this.options;
                    if (i === 1 && h === 1) {
                        for(let u = 0; u < t.length; u++)e.push(Pe(t[u]));
                        return e;
                    }
                    if (i !== t[0].length) throw new Error("inputSize must match data input size");
                    if (h !== t[0].length) throw new Error("outputSize must match data output size");
                    for(let u = 0; u < t.length; u++)e.push(Float32Array.from(t[u]));
                    return [
                        e
                    ];
                }
                formatArrayOfObject(t) {
                    if (this.requireInputOutputOfOne(), !this.inputLookup) {
                        const i = new te(t);
                        this.inputLookup = this.outputLookup = i.table, this.inputLookupLength = this.outputLookupLength = i.length;
                    }
                    const e = [];
                    for(let i = 0; i < t.length; i++)e.push(ai(t[i]));
                    return e;
                }
                formatArrayOfObjectMulti(t) {
                    if (!this.inputLookup) {
                        const i = new te(t);
                        this.inputLookup = this.outputLookup = i.table, this.inputLookupLength = this.outputLookupLength = i.length;
                    }
                    const e = [];
                    for(let i = 0; i < t.length; i++)e.push([
                        Di(t[i], this.inputLookup, this.inputLookupLength)
                    ]);
                    return e;
                }
                formatArrayOfDatumOfArray(t) {
                    const e = [];
                    this.requireInputOutputOfOne();
                    for(let i = 0; i < t.length; i++){
                        const h = t[i];
                        e.push(Ne(h.input, h.output));
                    }
                    return e;
                }
                formatArrayOfDatumOfObject(t) {
                    if (this.requireInputOutputOfOne(), !this.inputLookup) {
                        const i = new te(t, "input");
                        this.inputLookup = i.table, this.inputLookupLength = i.length;
                    }
                    if (!this.outputLookup) {
                        const i = new te(t, "output");
                        this.outputLookup = i.table, this.outputLookupLength = i.length;
                    }
                    const e = [];
                    for(let i = 0; i < t.length; i++){
                        const h = t[i];
                        e.push(hn(h.input, h.output));
                    }
                    return e;
                }
                formatArrayOfArrayOfArray(t) {
                    const e = [];
                    for(let i = 0; i < t.length; i++)e.push(fe(t[i]));
                    return e;
                }
                formatArrayOfArrayOfObject(t) {
                    if (!this.inputLookup) {
                        const i = new te(t);
                        this.inputLookup = this.outputLookup = i.table, this.inputLookupLength = this.outputLookupLength = i.length;
                    }
                    const e = [];
                    for(let i = 0; i < t.length; i++){
                        const h = [];
                        for(let u = 0; u < t[i].length; u++)h.push(Di(t[i][u], this.inputLookup, this.inputLookupLength));
                        e.push(h);
                    }
                    return e;
                }
                formatArrayOfDatumOfArrayOfArray(t) {
                    const e = [], { inputSize: i, outputSize: h } = this.options;
                    if (i !== t[0].input[0].length) throw new Error("inputSize must match data input size");
                    if (h !== t[0].output[0].length) throw new Error("outputSize must match data output size");
                    for(let u = 0; u < t.length; u++){
                        const p = t[u];
                        e.push(Qt(p.input, p.output));
                    }
                    return e;
                }
                formatArrayOfDatumOfArrayOfObject(t) {
                    if (!this.inputLookup) {
                        const i = new Os(t, "input");
                        this.inputLookup = i.table, this.inputLookupLength = i.length;
                    }
                    if (!this.outputLookup) {
                        const i = new Os(t, "output");
                        this.outputLookup = i.table, this.outputLookupLength = i.length;
                    }
                    if (!this.outputLookupLength) throw new Error("this.outputLookupLength not set to usable number");
                    const e = [];
                    for(let i = 0; i < t.length; i++){
                        const h = t[i];
                        e.push(xe(h.input, h.output, this.inputLookup, this.outputLookup, this.inputLookupLength, this.outputLookupLength));
                    }
                    return e;
                }
                formatData(t) {
                    switch(dt.dataShape(t).join(",")){
                        case "array,number":
                            return this.formatArray(t);
                        case "array,array,number":
                            return this.formatArrayOfArray(t);
                        case "array,object,number":
                            return this.options.inputSize === 1 ? this.formatArrayOfObject(t) : this.formatArrayOfObjectMulti(t);
                        case "array,datum,array,number":
                            return this.formatArrayOfDatumOfArray(t);
                        case "array,datum,object,number":
                            return this.formatArrayOfDatumOfObject(t);
                        case "array,array,array,number":
                            return this.formatArrayOfArrayOfArray(t);
                        case "array,array,object,number":
                            return this.formatArrayOfArrayOfObject(t);
                        case "array,datum,array,array,number":
                            return this.formatArrayOfDatumOfArrayOfArray(t);
                        case "array,datum,array,object,number":
                            return this.formatArrayOfDatumOfArrayOfObject(t);
                        default:
                            throw new Error("unknown data shape or configuration");
                    }
                }
                test(t) {
                    const e = [];
                    let i = 0;
                    const h = this.formatData(t);
                    for(let u = 0; u < h.length; u++){
                        const p = h[u], d = this.run(p.splice(0, p.length - 1)), l = p[p.length - 1];
                        let a = 0, o = 0;
                        for(let r = 0; r < d.length; r++){
                            o++;
                            const m = l[r] - d[r];
                            a += m * m;
                        }
                        if (i += a / o, Math.abs(a) > this.trainOpts.errorThresh) {
                            const r = t[u];
                            e.push({
                                value: r,
                                actual: d
                            });
                        }
                    }
                    return {
                        error: i / h.length,
                        misclasses: e,
                        total: h.length
                    };
                }
                addFormat(t) {
                    var e, i, h, u, p, d;
                    switch(dt.dataShape(t).join(",")){
                        case "array,array,number":
                        case "datum,array,array,number":
                        case "array,number":
                        case "datum,array,number":
                            return;
                        case "datum,object,number":
                            {
                                this.inputLookup = dt.addKeys(t.input, (e = this.inputLookup) !== null && e !== void 0 ? e : {}), this.inputLookup && (this.inputLookupLength = Object.keys(this.inputLookup).length), this.outputLookup = dt.addKeys(t.output, (i = this.outputLookup) !== null && i !== void 0 ? i : {}), this.outputLookup && (this.outputLookupLength = Object.keys(this.outputLookup).length);
                                break;
                            }
                        case "object,number":
                            {
                                this.inputLookup = this.outputLookup = dt.addKeys(t, (h = this.inputLookup) !== null && h !== void 0 ? h : {}), this.inputLookup && (this.inputLookupLength = this.outputLookupLength = Object.keys(this.inputLookup).length);
                                break;
                            }
                        case "array,object,number":
                            {
                                const a = t;
                                for(let o = 0; o < a.length; o++)this.inputLookup = this.outputLookup = dt.addKeys(a[o], (u = this.inputLookup) !== null && u !== void 0 ? u : {}), this.inputLookup && (this.inputLookupLength = this.outputLookupLength = Object.keys(this.inputLookup).length);
                                break;
                            }
                        case "datum,array,object,number":
                            {
                                const a = t, o = a.input;
                                for(let r = 0; r < o.length; r++)this.inputLookup = dt.addKeys(o[r], (p = this.inputLookup) !== null && p !== void 0 ? p : {}), this.inputLookup && (this.inputLookupLength = Object.keys(this.inputLookup).length);
                                const n = a.output;
                                for(let r = 0; r < n.length; r++)this.outputLookup = dt.addKeys(n[r], (d = this.outputLookup) !== null && d !== void 0 ? d : {}), this.outputLookup && (this.outputLookupLength = Object.keys(this.outputLookup).length);
                                break;
                            }
                        default:
                            throw new Error("unknown data shape or configuration");
                    }
                }
                toJSON() {
                    this.model || this.initialize();
                    const { model: t } = this, e = {
                        ...this.options,
                        ...Fe
                    };
                    return {
                        type: this.constructor.name,
                        options: e,
                        hiddenLayers: t.hiddenLayers.map((i)=>{
                            const h = {};
                            for(const u in i)i.hasOwnProperty(u) && (h[u] = i[u].toJSON());
                            return h;
                        }),
                        outputConnector: t.outputConnector.toJSON(),
                        output: t.output.toJSON(),
                        inputLookup: this.inputLookup,
                        inputLookupLength: this.inputLookupLength,
                        outputLookup: this.outputLookup,
                        outputLookupLength: this.outputLookupLength
                    };
                }
                fromJSON(t) {
                    const { options: e } = t, i = [], h = [];
                    t.hiddenLayers.forEach((d)=>{
                        const l = {};
                        for(const a in d)l[a] = gt.fromJSON(d[a]), i.push(l[a]);
                        h.push(l);
                    });
                    const u = gt.fromJSON(t.outputConnector);
                    i.push(u);
                    const p = gt.fromJSON(t.output);
                    return i.push(p), this.options = {
                        ...Cs(),
                        ...e
                    }, this.inputLookup = t.inputLookup, this.inputLookupLength = t.inputLookupLength, this.outputLookup = t.outputLookup, this.outputLookupLength = t.outputLookupLength, this.model = Object.seal({
                        isInitialized: !0,
                        hiddenLayers: h,
                        output: p,
                        allMatrices: i,
                        outputConnector: u,
                        equations: [],
                        equationConnections: []
                    }), this.initialLayerInputs = e.hiddenLayers.map((d)=>new gt(d, 1)), this.bindEquation(), this;
                }
                toFunction(t) {
                    const { model: e, inputLookup: i, inputLookupLength: h, outputLookup: u, outputLookupLength: p } = this, { inputSize: d } = this.options, { equations: l } = e, a = l[1], { states: o } = a, n = JSON.stringify(this.toJSON());
                    function r(x) {
                        const g = e.equationConnections[0], { states: I } = l[0];
                        for(let A = 0, P = I.length; A < P; A++)if (I[A].product === x) return A;
                        return g.indexOf(x);
                    }
                    function m(x, g) {
                        for(let I = 0, A = o.length; I < A; I++){
                            const P = o[I];
                            if (I === g) {
                                const O = r(x);
                                switch(x){
                                    case P.left:
                                        if (O > -1) return `typeof prevStates[${O}] === 'object' ? prevStates[${O}].product : new Matrix(${x.rows}, ${x.columns})`;
                                    case P.right:
                                        if (O > -1) return `typeof prevStates[${O}] === 'object' ? prevStates[${O}].product : new Matrix(${x.rows}, ${x.columns})`;
                                    case P.product:
                                        return `new Matrix(${x.rows}, ${x.columns})`;
                                    default:
                                        throw Error("unknown state");
                                }
                            }
                            if (x === P.product) return `states[${I}].product`;
                            if (x === P.right) return `states[${I}].right`;
                            if (x === P.left) return `states[${I}].left`;
                        }
                        return "";
                    }
                    function b(x, g) {
                        if (!x || !x.rows || !x.columns) return "null";
                        if (x === e.outputConnector) return "json.outputConnector";
                        if (x === e.output) return "json.output";
                        for(let I = 0, A = e.hiddenLayers.length; I < A; I++){
                            const P = e.hiddenLayers[I];
                            for(const O in P)if (P.hasOwnProperty(O) && P[O] === x) return `json.hiddenLayers[${I}].${O}`;
                        }
                        return m(x, g);
                    }
                    function E() {
                        return i ? d === 1 ? i === u ? `function lookupInput(input) {
            var table = ${JSON.stringify(i)};
            var result = [];
            for (var p in table) {
              if (!input.hasOwnProperty(p)) break;
              result.push(Float32Array.from([input[p]]));
            }
            return result;
          }` : `function lookupInput(input) {
          var table = ${JSON.stringify(i)};
          var result = [];
          for (var p in table) {
            result.push(Float32Array.from([input[p]]));
          }
          return result;
        }` : `function lookupInput(rawInputs) {
        var table = ${JSON.stringify(i)};
        var result = [];
        for (var i = 0; i < rawInputs.length; i++) {
          var rawInput = rawInputs[i];
          var input = new Float32Array(${h});
          for (var p in table) {
            input[table[p]] = rawInput.hasOwnProperty(p) ? rawInput[p] : 0;
          }
          result.push(input);
        }
        return result;
      }` : "";
                    }
                    function w() {
                        return u ? d === 1 ? i === u ? `function lookupOutputPartial(output, input) {
            var table = ${JSON.stringify(u)};
            var offset = input.length;
            var result = {};
            var i = 0;
            for (var p in table) {
              if (i++ < offset) continue;
              result[p] = output[table[p] - offset][0];
            }
            return result;
          }` : `function lookupOutput(output) {
          var table = ${JSON.stringify(u)};
          var result = {};
          for (var p in table) {
            result[p] = output[table[p]][0];
          }
          return result;
        }` : `function lookupOutput(output) {
        var table = ${JSON.stringify(u)};
        var result = {};
        for (var p in table) {
          result[p] = output[table[p]];
        }
        return result;
      }` : "";
                    }
                    function v(x) {
                        const g = x.toString().split("{");
                        g.shift();
                        const A = g.join("{").split("}");
                        return A.pop(), A.join("}").split(`
`).join(`
        `).replace("product.deltas[i] = 0;", "").replace("product.deltas[column] = 0;", "").replace("left.deltas[leftIndex] = 0;", "").replace("right.deltas[rightIndex] = 0;", "").replace("product.deltas = left.deltas.slice(0);", "");
                    }
                    function y(x) {
                        return `src/recurrent/matrix/${x.replace(/[A-Z]/g, function(g) {
                            return `-${g.toLowerCase()}`;
                        })}.js`;
                    }
                    const T = [], _ = {}, k = [];
                    for(let x = 0, g = o.length; x < g; x++){
                        const I = o[x];
                        T.push(`states[${x}] = {
      name: '${I.forwardFn.name}',
      left: ${I.left ? b(I.left, x) : "undefined"},
      right: ${I.right ? b(I.right, x) : "undefined"},
      product: ${b(I.product, x)}
    }`);
                        const A = I.forwardFn.name;
                        _[A] || (_[A] = !0, I.name === "input" ? (k.push(`case '${A}':`), k.push(i && d === 1 ? "product.weights = _i < input.length ? input[_i]: prevStates[prevStates.length - 1].product.weights;" : d === 1 ? "product.weights = [input[_i]];" : "product.weights = input[_i];"), k.push("break;")) : k.push(`        case '${A}':${A !== "forwardFn" ? ` //compiled from ${y(A)}` : ""}
          ${v(I.forwardFn.toString())}
          break;`));
                    }
                    const C = d === 1 && this.outputLookup, M = `
  var input = ${this.inputLookup ? "lookupInput(rawInput)" : "rawInput"};
  var json = ${n};
  var output = [];
  var states = [];
  var prevStates;
  var state;
  var max = ${C ? i === u ? h : `input.length + ${p - 1}` : "input.length"};
  for (var _i = 0; _i < max; _i++) {
    prevStates = states;
    states = [];
    ${T.join(`;
    `)};
    for (var stateIndex = 0, stateMax = ${T.length}; stateIndex < stateMax; stateIndex++) {
      state = states[stateIndex];
      var product = state.product;
      var left = state.left;
      var right = state.right;

      switch (state.name) {
${k.join(`
`)}
      }
    }
    ${d === 1 && i ? "if (_i >= input.length - 1) { output.push(state.product.weights); }" : "output = state.product.weights;"}
  }
  ${u ? u === i ? "return lookupOutputPartial(output, input)" : "return lookupOutput(output)" : d === 1 ? "return output[0]" : "return output"};
  ${E()}
  ${w()}

  function Matrix(rows, columns) {
    this.rows = rows;
    this.columns = columns;
    this.weights = new Float32Array(rows * columns);
  }
  ${He.toString().replace("_2.default", "Matrix")}
  ${be.toString()}
  ${bi.toString()}
  ${xi.toString()}`;
                    return new Function("rawInput", t ? t(M) : M);
                }
            }
            const _a = {
                ...ve
            };
            class Rs extends Xe {
                getHiddenLayer(t, e) {
                    return Ds(t, e);
                }
                getEquation(t, e, i, h) {
                    return $s(t, e, i, h);
                }
            }
            class Fs extends Me {
                getHiddenLayer(t, e) {
                    return Ms(t, e);
                }
                getEquation(t, e, i, h) {
                    return zs(t, e, i, h);
                }
            }
            function Ms(c, t) {
                return {
                    inputMatrix: new Rt(c, t, .08),
                    inputHidden: new Rt(c, c, .08),
                    inputBias: new gt(c, 1),
                    forgetMatrix: new Rt(c, t, .08),
                    forgetHidden: new Rt(c, c, .08),
                    forgetBias: new gt(c, 1),
                    outputMatrix: new Rt(c, t, .08),
                    outputHidden: new Rt(c, c, .08),
                    outputBias: new gt(c, 1),
                    cellActivationMatrix: new Rt(c, t, .08),
                    cellActivationHidden: new Rt(c, c, .08),
                    cellActivationBias: new gt(c, 1)
                };
            }
            function zs(c, t, e, i) {
                if (!i.inputMatrix || !i.inputHidden || !i.inputBias || !i.forgetMatrix || !i.forgetHidden || !i.forgetBias || !i.outputMatrix || !i.outputHidden || !i.outputBias || !i.cellActivationMatrix || !i.cellActivationHidden || !i.cellActivationBias) throw new Error("hiddenLayer does not have expected properties");
                const h = c.sigmoid.bind(c), u = c.add.bind(c), p = c.multiply.bind(c), d = c.multiplyElement.bind(c), l = c.tanh.bind(c), a = h(u(u(p(i.inputMatrix, t), p(i.inputHidden, e)), i.inputBias)), o = h(u(u(p(i.forgetMatrix, t), p(i.forgetHidden, e)), i.forgetBias)), n = h(u(u(p(i.outputMatrix, t), p(i.outputHidden, e)), i.outputBias)), r = l(u(u(p(i.cellActivationMatrix, t), p(i.cellActivationHidden, e)), i.cellActivationBias)), m = d(o, e), b = d(a, r), E = u(m, b);
                return d(n, l(E));
            }
            class Ps extends Xe {
                getHiddenLayer(t, e) {
                    return Ms(t, e);
                }
                getEquation(t, e, i, h) {
                    return zs(t, e, i, h);
                }
            }
            function Ea(c, t) {
                const e = [];
                for(; c < t; c++)e.push(c);
                return e;
            }
            function ka(c) {
                return Array.isArray(c) ? Float32Array.from(c) : Float32Array.from(Object.values(c));
            }
            function La({ pixelX: c, pixelY: t, radius: e, inputs: i, row: h, line: u, fontSize: p, fontClassName: d }) {
                let l = `<rect
              x="${c / 2 - e}"
              y="${t / 2 + h * t - e}"
              width="${2 * e}"
              height="${2 * e}"
              stroke="black"
              stroke-width="1"
              fill="${i.color}"
              class="${i.className}" />
            <line
              x1="${c / 4}"
              y1="${t / 2 + h * t}"
              x2="${c / 2 - e}"
              y2="${t / 2 + h * t}"
              style="stroke:${u.color};stroke-width:${u.width}"
              class="${u.className}" />`;
                return i.labels && (l += `<text
              x="${c / 8}"
              y="${t / 2 + h * t - 5}"
              fill="black"
              font-size="${p}"
              class="${d}">${i.labels[h]}</text>`), l;
            }
            function Ia({ pixelX: c, pixelY: t, row: e, column: i, radius: h, hidden: u }) {
                return `<circle
            cx="${c / 2 + i * c}"
            cy="${t / 2 + e * t}"
            r="${h}"
            stroke="black"
            stroke-width="1"
            fill="${u.color}"
            class="${u.className}" />`;
            }
            function Aa({ pixelX: c, pixelY: t, row: e, column: i, line: h, outputs: u, radius: p }) {
                return `<circle
            cx="${c / 2 + i * c}"
            cy="${t / 2 + e * t}"
            r="${p}"
            stroke="black"
            stroke-width="1"
            fill="${u.color}"
            class="${u.className}" />
          <line
            x1="${c / 2 + i * c + p}"
            y1="${t / 2 + e * t}"
            x2="${c / 2 + i * c + c / 4}"
            y2="${t / 2 + e * t}"
            style="stroke:${h.color};stroke-width:${h.width}"
            class="${h.className}" />`;
            }
            function Da({ pixelX: c, pixelY: t, row: e, column: i, radius: h, lineY: u, line: p, previousConnectionIndex: d }) {
                return `<line
            x1="${c / 2 + (i - 1) * c + h}"
            y1="${u / 2 + d * u}"
            x2="${c / 2 + i * c - h}"
            y2="${t / 2 + e * t}"
            style="stroke:${p.color};stroke-width:${p.width}"
            class="${p.className}" />`;
            }
            function Ti(c) {
                const { sizes: t, height: e, width: i } = c;
                let h = "";
                const u = i / t.length;
                for(let p = 0; p < t.length; p++){
                    const d = t[p], l = e / d;
                    for(let a = 0; a < d; a++)if (p === 0) h += La({
                        pixelX: u,
                        pixelY: l,
                        row: a,
                        ...c
                    });
                    else {
                        p === t.length - 1 ? h += Aa({
                            pixelX: u,
                            pixelY: l,
                            row: a,
                            column: p,
                            ...c
                        }) : h += Ia({
                            pixelX: u,
                            pixelY: l,
                            row: a,
                            column: p,
                            ...c
                        });
                        const o = t[p - 1], n = e / o;
                        for(let r = 0; r < o; r++)h += Da({
                            pixelX: u,
                            pixelY: l,
                            row: a,
                            column: p,
                            lineY: n,
                            previousConnectionIndex: r,
                            ...c
                        });
                    }
                }
                return h;
            }
            function $a({ pixelX: c, pixelY: t, row: e, column: i, radius: h, recurrentLine: u }) {
                const p = c / 2 + i * c + h + 1, d = t / 2 + e * t, l = p - h * 2 - 2, a = d, o = l + 100, n = a + 50, r = p - 100, m = d + 50;
                return `<path
              d="M ${p} ${d} C ${o} ${n}, ${r} ${m}, ${l} ${a}"
              stroke="${u.color}"
              stroke-width="${u.width}"
              fill="transparent"
              stroke-linecap="round"
              marker-end="url(#arrow)"
              class="${u.className}" />`;
            }
            function Ns(c) {
                const { width: t, height: e, recurrentLine: i, sizes: h, radius: u } = c, p = t / h.length;
                let d = `<defs>
              <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
                <path d="M0,0 L0,6 L9,3 z" fill="${i.color}" />
              </marker>
            </defs>`;
                d += Ti(c);
                for(let l = 1; l < h.length; l++){
                    const a = h[l], o = e / a;
                    for(let n = 0; n < a; n++)d += $a({
                        pixelX: p,
                        pixelY: o,
                        row: n,
                        column: l,
                        radius: u,
                        recurrentLine: i
                    });
                }
                return d;
            }
            function Oa(c) {
                const { options: t } = c;
                if (!t) throw new Error("options not defined");
                if (!t.inputLayer) throw new Error("options.inputLater not defined");
                if (!t.hiddenLayers) throw new Error("options.hiddenLayers not defined");
                if (t.hiddenLayers.length < 1) throw new Error("options.hiddenLayers is empty");
                if (!t.outputLayer) throw new Error("options.outputLayer not defined");
                const e = t.inputLayer(), i = [];
                i.push(t.hiddenLayers[0](e, 0));
                for(let u = 1; u < t.hiddenLayers.length; u++)i.push(t.hiddenLayers[u](i[u - 1], u));
                const h = t.outputLayer(i[i.length - 1], i.length);
                return {
                    inputSize: e.height,
                    hiddenLayers: i.map((u)=>u.height),
                    outputSize: h.height
                };
            }
            function Ca(c) {
                const t = [], { options: e } = c;
                if (!e.inputLayer) throw new Error("inputLayer not defined");
                if (!e.outputLayer) throw new Error("outputLayer not defined");
                const i = e.inputLayer();
                t.push(e.hiddenLayers[0](i, xs(), 0));
                for(let u = 1; u < e.hiddenLayers.length; u++)t.push(e.hiddenLayers[u](t[u - 1], xs(), u));
                const h = e.outputLayer(t[t.length - 1], -1);
                return {
                    inputSize: i.height,
                    hiddenLayers: t.map((u)=>u.height),
                    outputSize: h.height
                };
            }
            function Ye(c, t, e) {
                return `<svg
            xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            version="1.1"
            width="${t}"
            height="${e}">${c}</svg>`;
            }
            function Ra(c) {
                return c.sizes;
            }
            function Fa(c) {
                const { options: t, sizes: e } = c, { inputSize: i, outputSize: h, hiddenLayers: u } = t;
                if (!e) {
                    if (typeof i == "number" && i < 1) throw new Error("inputSize not set");
                    if (typeof h == "number" && h < 1) throw new Error("outputSize not set");
                    if (u?.some((p)=>p < 1)) throw new Error("hiddenLayers not set");
                }
                return typeof i == "number" && Array.isArray(u) && typeof h == "number" ? [
                    i
                ].concat(u).concat([
                    h
                ]) : e;
            }
            function Vs(c) {
                const { options: t } = c, { inputSize: e, outputSize: i, hiddenLayers: h } = t;
                return [
                    e
                ].concat(h).concat([
                    i
                ]);
            }
            function Ma() {
                return {
                    line: {
                        width: .5,
                        color: "black",
                        className: "connection"
                    },
                    recurrentLine: {
                        width: 1,
                        color: "red",
                        className: "recurrence"
                    },
                    inputs: {
                        color: "rgba(0, 128, 0, 0.5)",
                        labels: null,
                        className: "input"
                    },
                    outputs: {
                        color: "rgba(100, 149, 237, 0.5)",
                        className: "output"
                    },
                    hidden: {
                        color: "rgba(255, 127, 80, 0.5)",
                        className: "hidden-neuron"
                    },
                    fontSize: "14px",
                    fontClassName: "label",
                    radius: 8,
                    width: 400,
                    height: 250,
                    sizes: []
                };
            }
            function za(c, t) {
                const e = {
                    ...Ma(),
                    ...t
                }, { width: i, height: h, inputs: u } = e;
                let p = [];
                if (c instanceof ui || c instanceof Ge) p = Fa(c);
                else if (c instanceof Ls) {
                    const { inputSize: d, hiddenLayers: l, outputSize: a } = Ca(c);
                    p = [
                        d
                    ].concat(l).concat([
                        a
                    ]);
                } else if (c instanceof Ce) {
                    const { inputSize: d, hiddenLayers: l, outputSize: a } = Oa(c);
                    p = [
                        d
                    ].concat(l).concat([
                        a
                    ]);
                } else {
                    if (c instanceof Me || c instanceof Fs || c instanceof As || c instanceof Xe || c instanceof Ps || c instanceof Rs) return Ye(Ns({
                        ...e,
                        sizes: Je(Vs(c), u.labels)
                    }), i, h);
                    if (c.hasOwnProperty("type")) switch(c.type){
                        case "NeuralNetwork":
                        case "NeuralNetworkGPU":
                            return Ye(Ti({
                                ...e,
                                sizes: Je(Ra(c), u.labels)
                            }), i, h);
                        case "RNN":
                        case "GRU":
                        case "LSTM":
                        case "RNNTimeStep":
                        case "GRUTimeStep":
                        case "LSTMTimeStep":
                            return Ye(Ns({
                                ...e,
                                sizes: Je(Vs(c), u.labels)
                            }), i, h);
                        default:
                            throw new Error("unrecognized network");
                    }
                    else if (c.hasOwnProperty("inputSize") && c.hasOwnProperty("hiddenLayers") && c.hasOwnProperty("outputSize")) {
                        const { inputSize: d, hiddenLayers: l, outputSize: a } = c;
                        p = [
                            d,
                            ...l,
                            a
                        ];
                    } else if (c.hasOwnProperty("sizes")) p = c.sizes;
                    else throw new Error("unrecognized network");
                }
                return Ye(Ti({
                    ...e,
                    sizes: Je(p, u.labels)
                }), i, h);
            }
            function Je(c, t) {
                if (!c) throw new Error("sizes not set");
                if (c.some((e)=>e < 1)) throw new Error("sizes not set correctly");
                if (t && t.length !== c[0]) throw new Error("not enough labels for inputs");
                return c;
            }
            const Pa = {
                RNNTimeStep: Xe,
                LSTMTimeStep: Ps,
                GRUTimeStep: Rs,
                RNN: Me,
                LSTM: Fs,
                GRU: As
            }, Na = {
                max: oi,
                mse: Ke,
                ones: us,
                ones2D: hs,
                random: pn,
                randomWeight: $i,
                randos: we,
                range: Ea,
                toArray: ka,
                DataFormatter: Jt,
                zeros: Vt,
                toSVG: za
            };
            N.AE = kn, N.CrossValidate = ue, N.FeedForward = Ce, N.NeuralNetwork = ui, N.NeuralNetworkGPU = Ge, N.Recurrent = Ls, N.activation = lt, N.layer = mi, N.layerTypes = qt, N.likely = aa, N.lookup = dt, N.praxis = Nn, N.recurrent = Pa, N.utilities = Na, Object.defineProperty(N, "__esModule", {
                value: !0
            });
        });
    })(Ai, Ai.exports);
    var lo = Ai.exports;
    const Ii = ho(lo);
    class ri {
        network;
        inputSize;
        hiddenSize;
        outputSize;
        lastInputs = [];
        constructor($, N, V, z){
            if (this.inputSize = $, this.hiddenSize = N, this.outputSize = V, z) this.network = z;
            else {
                this.network = new Ii.NeuralNetwork({
                    inputSize: this.inputSize,
                    hiddenLayers: [
                        this.hiddenSize,
                        this.hiddenSize
                    ],
                    outputSize: this.outputSize,
                    activation: "sigmoid"
                });
                const j = new Array($).fill(0).map(()=>Math.random()), H = new Array(V).fill(0).map(()=>Math.random());
                this.network.train([
                    {
                        input: j,
                        output: H
                    }
                ], {
                    iterations: 1
                });
            }
        }
        predict($) {
            return this.network.run($);
        }
        mutate($, N) {
            const V = this.network.toJSON();
            V.layers && this.mutateLayers(V.layers, $, N), this.network = new Ii.NeuralNetwork({
                inputSize: this.inputSize,
                hiddenLayers: [
                    this.hiddenSize,
                    this.hiddenSize
                ],
                outputSize: this.outputSize,
                activation: "sigmoid"
            }), this.network.fromJSON(V);
        }
        mutateLayers($, N, V) {
            for (const z of $){
                if (z.weights) for(const j in z.weights){
                    const H = z.weights[j];
                    for(const Y in H)Math.random() < N && (H[Y] += (Math.random() * 2 - 1) * V, H[Y] > 10 && (H[Y] = 10), H[Y] < -10 && (H[Y] = -10));
                }
                if (z.biases) for(const j in z.biases)Math.random() < N && (z.biases[j] += (Math.random() * 2 - 1) * V, z.biases[j] > 10 && (z.biases[j] = 10), z.biases[j] < -10 && (z.biases[j] = -10));
            }
        }
        copy() {
            const $ = this.network.toJSON(), N = new Ii.NeuralNetwork({
                inputSize: this.inputSize,
                hiddenLayers: [
                    this.hiddenSize,
                    this.hiddenSize
                ],
                outputSize: this.outputSize,
                activation: "sigmoid"
            });
            return N.fromJSON($), new ri(this.inputSize, this.hiddenSize, this.outputSize, N);
        }
        getNetwork() {
            return this.network;
        }
    }
    class co {
        size;
        world;
        constructor($, N = 2e3){
            this.size = N;
            const V = {
                x: 0,
                y: 0
            };
            this.world = new $.World(V);
        }
        getPhysicsWorld() {
            return this.world;
        }
        step() {
            this.world.step();
        }
        wrapPosition($) {
            let { x: N, y: V } = $.translation();
            const z = this.size / 2;
            let j = !1;
            N > z ? (N -= this.size, j = !0) : N < -z && (N += this.size, j = !0), V > z ? (V -= this.size, j = !0) : V < -z && (V += this.size, j = !0), j && $.setTranslation({
                x: N,
                y: V
            }, !0);
        }
    }
    class po {
        body;
        leftThruster = 0;
        rightThruster = 0;
        THRUSTER_MAX = 500;
        THRUSTER_STEP;
        sensors = [];
        SENSOR_COUNT = 9;
        SENSOR_ANGLE_SPREAD = Math.PI * .5;
        SENSOR_LENGTH = 400;
        brain;
        alive = !0;
        score = 0;
        isBest = !1;
        constructor($, N, V){
            this.THRUSTER_STEP = this.THRUSTER_MAX / 10;
            const z = this.SENSOR_COUNT * 2, j = 10, H = 2;
            V ? this.brain = V : this.brain = new ri(z, j, H);
            for(let Tt = 0; Tt < this.SENSOR_COUNT; Tt++){
                const kt = -this.SENSOR_ANGLE_SPREAD / 2 + Tt * this.SENSOR_ANGLE_SPREAD / (this.SENSOR_COUNT - 1);
                this.sensors.push({
                    angle: kt,
                    length: this.SENSOR_LENGTH,
                    reading: 1,
                    detectedType: "NONE",
                    endX: 0,
                    endY: 0
                });
            }
            const Y = $.RigidBodyDesc.dynamic().setTranslation(0, 0).setLinearDamping(.5).setAngularDamping(2);
            this.body = N.createRigidBody(Y);
            const bt = new Float32Array([
                0,
                15,
                -10,
                -10,
                10,
                -10
            ]), ot = $.ColliderDesc.convexHull(bt);
            ot.setSensor(!0), N.createCollider(ot, this.body);
        }
        updateSensors($, N, V) {
            const z = this.body.translation(), j = this.body.rotation();
            for (const H of this.sensors){
                const Y = j + Math.PI / 2 + H.angle, bt = Math.cos(Y), ot = Math.sin(Y), Tt = z.x, kt = z.y;
                let ct = this.SENSOR_LENGTH, ht = "NONE";
                for (const ut of $){
                    let lt = ut.x - Tt, vt = ut.y - kt;
                    lt > V / 2 && (lt -= V), lt < -V / 2 && (lt += V), vt > V / 2 && (vt -= V), vt < -V / 2 && (vt += V);
                    const Kt = Tt + lt, It = kt + vt, wt = this.rayCircleIntersect(Tt, kt, bt, ot, Kt, It, ut.radius);
                    wt !== null && wt < ct && (ct = wt, ht = "FOOD");
                }
                for (const ut of N){
                    let lt = ut.x - Tt, vt = ut.y - kt;
                    lt > V / 2 && (lt -= V), lt < -V / 2 && (lt += V), vt > V / 2 && (vt -= V), vt < -V / 2 && (vt += V);
                    const Kt = Tt + lt, It = kt + vt, wt = this.rayCircleIntersect(Tt, kt, bt, ot, Kt, It, ut.radius);
                    wt !== null && wt < ct && (ct = wt, ht = "POISON");
                }
                H.reading = 1 - ct / this.SENSOR_LENGTH, H.detectedType = ht, H.endX = Tt + bt * ct, H.endY = kt + ot * ct;
            }
        }
        rayCircleIntersect($, N, V, z, j, H, Y) {
            const bt = j - $, ot = H - N, Tt = bt * V + ot * z;
            let kt = $ + V * Tt, ct = N + z * Tt;
            const ht = (kt - j) * (kt - j) + (ct - H) * (ct - H);
            if (ht > Y * Y) return null;
            const ut = Math.sqrt(Y * Y - ht), lt = Tt - ut;
            return lt < 0 || lt > this.SENSOR_LENGTH ? null : lt;
        }
        updateThrusters($, N, V, z) {
            ($ || N || V || z) && ($ && (this.leftThruster = Math.min(this.leftThruster + this.THRUSTER_STEP, this.THRUSTER_MAX)), N && (this.leftThruster = Math.max(this.leftThruster - this.THRUSTER_STEP, 0)), V && (this.rightThruster = Math.min(this.rightThruster + this.THRUSTER_STEP, this.THRUSTER_MAX)), z && (this.rightThruster = Math.max(this.rightThruster - this.THRUSTER_STEP, 0))), this.applyThrusterForces();
        }
        think() {
            const $ = [];
            for (const V of this.sensors){
                $.push(V.reading);
                let z = 0;
                V.detectedType === "FOOD" && (z = 1), V.detectedType === "POISON" && (z = -1), $.push(z);
            }
            this.brain.lastInputs = $;
            const N = this.brain.predict($);
            this.leftThruster = N[0] * this.THRUSTER_MAX, this.rightThruster = N[1] * this.THRUSTER_MAX;
        }
        die() {
            this.alive = !1, this.body.setLinvel({
                x: 0,
                y: 0
            }, !0), this.body.setAngvel(0, !0);
        }
        reset($) {
            this.alive = !0, this.score = 0, $ && (this.brain = $), this.body.setTranslation({
                x: 0,
                y: 0
            }, !0), this.body.setLinvel({
                x: 0,
                y: 0
            }, !0), this.body.setAngvel(0, !0), this.body.setRotation(0, !0);
        }
        applyThrusterForces() {
            const $ = this.body.rotation(), N = -Math.sin($), V = Math.cos($), z = {
                x: -10,
                y: -10
            }, j = {
                x: 10,
                y: -10
            }, H = (bt, ot)=>({
                    x: bt.x * Math.cos(ot) - bt.y * Math.sin(ot),
                    y: bt.x * Math.sin(ot) + bt.y * Math.cos(ot)
                }), Y = this.body.translation();
            if (this.leftThruster > 0) {
                const bt = H(z, $);
                this.body.applyImpulseAtPoint({
                    x: N * this.leftThruster * .1,
                    y: V * this.leftThruster * .1
                }, {
                    x: Y.x + bt.x,
                    y: Y.y + bt.y
                }, !0);
            }
            if (this.rightThruster > 0) {
                const bt = H(j, $);
                this.body.applyImpulseAtPoint({
                    x: N * this.rightThruster * .1,
                    y: V * this.rightThruster * .1
                }, {
                    x: Y.x + bt.x,
                    y: Y.y + bt.y
                }, !0);
            }
        }
        draw($) {
            const N = this.getPosition();
            $.save(), $.lineWidth = 1;
            for (const z of this.sensors)z.detectedType === "FOOD" ? $.strokeStyle = "#00ff00" : z.detectedType === "POISON" ? $.strokeStyle = "#ff0000" : $.strokeStyle = "rgba(200, 200, 200, 0.2)", $.beginPath(), $.moveTo(0, 0), $.lineTo(z.endX - N.x, z.endY - N.y), $.stroke();
            $.restore(), $.save(), $.rotate(this.body.rotation()), $.beginPath(), $.moveTo(0, 15), $.lineTo(-10, -10), $.lineTo(10, -10), $.closePath(), $.fillStyle = this.isBest ? "#ffd700" : "#fff", $.fill(), $.strokeStyle = this.isBest ? "#ffffff" : "#4facfe", $.lineWidth = this.isBest ? 4 : 2, $.stroke(), this.isBest && ($.shadowBlur = 15, $.shadowColor = "#ffd700", $.stroke(), $.shadowBlur = 0);
            const V = 30;
            if (this.leftThruster > 0) {
                const z = this.leftThruster / this.THRUSTER_MAX * V;
                $.beginPath(), $.moveTo(-7, -10), $.lineTo(-7, -10 - z), $.strokeStyle = "#ff4b2b", $.lineWidth = 4, $.stroke();
            }
            if (this.rightThruster > 0) {
                const z = this.rightThruster / this.THRUSTER_MAX * V;
                $.beginPath(), $.moveTo(7, -10), $.lineTo(7, -10 - z), $.strokeStyle = "#ff4b2b", $.lineWidth = 4, $.stroke();
            }
            $.restore();
        }
        getBody() {
            return this.body;
        }
        getPosition() {
            return this.body.translation();
        }
        getVelocity() {
            return this.body.linvel();
        }
        getAngularVelocity() {
            return this.body.angvel();
        }
        getLeftThrusterPercent() {
            return this.leftThruster / this.THRUSTER_MAX * 100;
        }
        getRightThrusterPercent() {
            return this.rightThruster / this.THRUSTER_MAX * 100;
        }
    }
    class fo {
        keys = {};
        constructor(){
            window.addEventListener("keydown", ($)=>this.keys[$.key.toLowerCase()] = !0), window.addEventListener("keyup", ($)=>this.keys[$.key.toLowerCase()] = !1);
        }
        isKeyPressed($) {
            return this.keys[$.toLowerCase()] || !1;
        }
    }
    class go {
        x = 0;
        y = 0;
        follow($, N) {
            this.x = $, this.y = N;
        }
        applyTransform($, N) {
            $.save(), $.translate(N.width / 2, N.height / 2), $.scale(1, -1), $.translate(-this.x, -this.y);
        }
        resetTransform($) {
            $.restore();
        }
    }
    class mo {
        canvas;
        ctx;
        worldSize;
        constructor($){
            this.worldSize = $, this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d"), document.getElementById("app").appendChild(this.canvas), this.resize(), window.addEventListener("resize", ()=>this.resize());
        }
        resize() {
            this.canvas.width = window.innerWidth, this.canvas.height = window.innerHeight;
        }
        clear() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
        drawWorld($, N, V) {
            this.ctx.save(), this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2), this.ctx.scale(1, -1), this.ctx.save(), this.ctx.translate(-$.x, -$.y), this.drawGrid(), this.drawBorders(), N.forEach((z)=>this.drawItemWithGhosts(z, $.x, $.y)), V.forEach((z)=>this.drawItemWithGhosts(z, $.x, $.y)), this.ctx.restore(), this.ctx.restore();
        }
        drawGrid() {
            this.ctx.strokeStyle = "rgba(255, 255, 255, 0.05)", this.ctx.lineWidth = 1;
            for(let $ = -this.worldSize / 2; $ <= this.worldSize / 2; $ += 100)this.ctx.beginPath(), this.ctx.moveTo($, -this.worldSize / 2), this.ctx.lineTo($, this.worldSize / 2), this.ctx.stroke(), this.ctx.beginPath(), this.ctx.moveTo(-this.worldSize / 2, $), this.ctx.lineTo(this.worldSize / 2, $), this.ctx.stroke();
        }
        drawBorders() {
            this.ctx.strokeStyle = "#4facfe", this.ctx.lineWidth = 6, this.ctx.strokeRect(-this.worldSize / 2, -this.worldSize / 2, this.worldSize, this.worldSize);
            const $ = 20;
            this.ctx.fillStyle = "#4facfe";
            const N = this.worldSize / 2;
            this.ctx.fillRect(-N - 3, -N - 3, $, $), this.ctx.fillRect(N - $ + 3, -N - 3, $, $), this.ctx.fillRect(-N - 3, N - $ + 3, $, $), this.ctx.fillRect(N - $ + 3, N - $ + 3, $, $);
        }
        drawItemWithGhosts($, N, V) {
            const z = Math.max(this.canvas.width, this.canvas.height) / 2 + 100, j = this.worldSize / 2;
            $.draw(this.ctx);
            const H = [];
            $.x - N < -j + z && H.push({
                dx: this.worldSize,
                dy: 0
            }), $.x - N > j - z && H.push({
                dx: -this.worldSize,
                dy: 0
            }), $.y - V < -j + z && H.push({
                dx: 0,
                dy: this.worldSize
            }), $.y - V > j - z && H.push({
                dx: 0,
                dy: -this.worldSize
            });
            for (const Y of H)this.ctx.save(), this.ctx.translate(Y.dx, Y.dy), $.draw(this.ctx), this.ctx.restore();
        }
        drawBoidAtCenter($) {
            this.ctx.save(), this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2), this.ctx.scale(1, -1), $(this.ctx), this.ctx.restore();
        }
        drawMinimap($, N, V, z) {
            const Y = this.canvas.width - 200 - 20, bt = 20;
            this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.fillStyle = "rgba(0, 0, 0, 0.7)", this.ctx.fillRect(Y, bt, 200, 200), this.ctx.strokeStyle = "#4facfe", this.ctx.lineWidth = 2, this.ctx.strokeRect(Y, bt, 200, 200);
            const ot = 200 / this.worldSize, Tt = (ut)=>(ut + this.worldSize / 2) * ot, kt = (ut)=>(this.worldSize / 2 - ut) * ot;
            this.ctx.strokeStyle = "rgba(79, 172, 254, 0.5)", this.ctx.lineWidth = 1, this.ctx.strokeRect(Y, bt, 200, 200), this.ctx.fillStyle = "#00ff88", V.forEach((ut)=>{
                const lt = Y + Tt(ut.x), vt = bt + kt(ut.y);
                this.ctx.fillRect(lt - 1.5, vt - 1.5, 3, 3);
            }), this.ctx.fillStyle = "#ff4444", z.forEach((ut)=>{
                const lt = Y + Tt(ut.x), vt = bt + kt(ut.y);
                this.ctx.fillRect(lt - 1.5, vt - 1.5, 3, 3);
            });
            const ct = Y + Tt($), ht = bt + kt(N);
            this.ctx.fillStyle = "#ffffff", this.ctx.beginPath(), this.ctx.arc(ct, ht, 4, 0, Math.PI * 2), this.ctx.fill(), this.ctx.strokeStyle = "#4facfe", this.ctx.lineWidth = 2, this.ctx.stroke(), this.ctx.restore();
        }
        drawBrain($) {
            const V = $.getNetwork().toJSON();
            if (!V.layers) return;
            const z = [];
            if ($.lastInputs && $.lastInputs.length > 0) {
                z.push([
                    ...$.lastInputs
                ]);
                let ct = $.lastInputs;
                for (const ht of V.layers){
                    const ut = [], lt = Object.keys(ht.weights || {}).map((It)=>parseInt(It)), Kt = (lt.length > 0 ? Math.max(...lt) : 0) + 1;
                    for(let It = 0; It < Kt; It++){
                        let wt = 0;
                        if (ht.biases && ht.biases[It] && (wt += ht.biases[It]), ht.weights && ht.weights[It]) {
                            const oe = ht.weights[It];
                            for(const fe in oe){
                                const Qt = parseInt(fe);
                                Qt < ct.length && (wt += oe[fe] * ct[Qt]);
                            }
                        }
                        const dt = 1 / (1 + Math.exp(-wt));
                        ut.push(dt);
                    }
                    z.push(ut), ct = ut;
                }
            }
            const j = 20, H = 300, Y = 200, bt = this.canvas.height - Y - 20;
            this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.fillStyle = "rgba(0, 0, 0, 0.8)", this.ctx.fillRect(j, bt, H, Y), this.ctx.strokeStyle = "#4facfe", this.ctx.lineWidth = 2, this.ctx.strokeRect(j, bt, H, Y);
            const ot = [];
            V.sizes ? ot.push(...V.sizes) : (ot.push(18), ot.push(10), ot.push(10), ot.push(2));
            const Tt = H / (ot.length + 1), kt = [];
            for(let ct = 0; ct < ot.length; ct++){
                const ht = ot[ct], ut = j + (ct + 1) * Tt, lt = [], vt = Math.min(30, (Y - 40) / ht), Kt = bt + Y / 2 - (ht - 1) * vt / 2;
                for(let It = 0; It < ht; It++){
                    const wt = Kt + It * vt;
                    lt.push({
                        x: ut,
                        y: wt
                    });
                }
                kt.push(lt);
            }
            if (V.layers) for(let ct = 0; ct < V.layers.length; ct++){
                const ht = ct + 1, ut = ct, lt = V.layers[ct], vt = kt[ht], Kt = kt[ut];
                if (!vt || !Kt || !lt.weights) continue;
                const It = z[ut];
                for(const wt in lt.weights){
                    const dt = parseInt(wt), oe = lt.weights[wt];
                    if (!(dt >= vt.length)) for(const fe in oe){
                        const Qt = parseInt(fe), Pe = oe[fe];
                        if (Qt >= Kt.length) continue;
                        const Ne = Kt[Qt], Ve = vt[dt];
                        let xe = .05;
                        if (It && Qt < It.length) {
                            const ai = Math.abs(It[Qt] * Pe);
                            xe = Math.min(ai + .1, .8);
                        }
                        this.ctx.beginPath(), this.ctx.moveTo(Ne.x, Ne.y), this.ctx.lineTo(Ve.x, Ve.y), Pe > 0 ? this.ctx.strokeStyle = `rgba(0, 255, 0, ${xe})` : this.ctx.strokeStyle = `rgba(255, 0, 0, ${xe})`, this.ctx.lineWidth = xe * 2, this.ctx.stroke();
                    }
                }
            }
            for(let ct = 0; ct < kt.length; ct++){
                const ht = z[ct];
                for(let ut = 0; ut < kt[ct].length; ut++){
                    const lt = kt[ct][ut];
                    let vt = 0;
                    ht && ut < ht.length && (vt = ht[ut]), this.ctx.beginPath(), this.ctx.arc(lt.x, lt.y, 4, 0, Math.PI * 2);
                    const Kt = 20 + vt * 80;
                    this.ctx.fillStyle = `hsl(120, 0%, ${Kt}%)`, vt > .5 ? (this.ctx.strokeStyle = "#fff", this.ctx.lineWidth = 2) : (this.ctx.strokeStyle = "rgba(255,255,255,0.3)", this.ctx.lineWidth = 1), this.ctx.stroke(), this.ctx.fill(), vt > .05 && (this.ctx.beginPath(), this.ctx.moveTo(lt.x, lt.y), this.ctx.lineTo(lt.x + vt * 15, lt.y), this.ctx.strokeStyle = "#fff", this.ctx.lineWidth = 1, this.ctx.stroke());
                }
            }
            this.ctx.restore();
        }
    }
    class yo {
        element;
        leftStat;
        rightStat;
        velStat;
        rotStat;
        foodStat;
        poisonStat;
        collectedStat;
        trainingStat;
        constructor($, N, V){
            this.element = document.createElement("div"), this.element.style.position = "absolute", this.element.style.top = "20px", this.element.style.left = "20px", this.element.style.padding = "20px", this.element.style.background = "rgba(0, 0, 0, 0.7)", this.element.style.borderRadius = "12px", this.element.style.backdropFilter = "blur(10px)", this.element.style.border = "1px solid rgba(255, 255, 255, 0.1)", this.element.style.pointerEvents = "none", this.element.style.fontSize = "14px", this.element.innerHTML = `
            <div style="margin-bottom: 10px; font-weight: bold; color: #4facfe;">BOID SYSTEMS</div>
            <div id="seed-stat">Seed: ${$}</div>
            <div style="margin-top: 8px; opacity: 0.7;">---</div>
            <div id="left-stat">Left Thruster: 0</div>
            <div id="right-stat">Right Thruster: 0</div>
            <div id="vel-stat">Velocity: 0</div>
            <div id="rot-stat">Rotation Power: 0</div>
            <div style="margin-top: 8px; opacity: 0.7;">---</div>
            <div id="food-stat">Food: ${N}</div>
            <div id="poison-stat">Poison: ${V}</div>
            <div id="collected-stat">Collected: 0 food, 0 poison</div>
            <div style="margin-top: 8px; opacity: 0.7;">---</div>
            <div id="training-stat">Mode: Manual | Gen: 0 | Best: 0</div>
            <div style="margin-top: 10px; opacity: 0.6; font-size: 12px;">Q/A: Left | W/S: Right | T: Auto Mode</div>
            <button id="reset-btn" style="
                margin-top: 15px;
                width: 100%;
                background: #ff4b2b;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 6px;
                cursor: pointer;
                font-weight: bold;
                pointer-events: auto;
                transition: opacity 0.2s;
            " onmouseover="this.style.opacity='0.8'" onmouseout="this.style.opacity='1'">RESET EVOLUTION</button>
        `, document.body.appendChild(this.element), document.getElementById("reset-btn").addEventListener("click", ()=>{
                confirm("Are you sure you want to reset all evolution progress?") && (localStorage.clear(), window.location.reload());
            }), this.leftStat = document.getElementById("left-stat"), this.rightStat = document.getElementById("right-stat"), this.velStat = document.getElementById("vel-stat"), this.rotStat = document.getElementById("rot-stat"), this.foodStat = document.getElementById("food-stat"), this.poisonStat = document.getElementById("poison-stat"), this.collectedStat = document.getElementById("collected-stat"), this.trainingStat = document.getElementById("training-stat");
        }
        updateStats($, N, V, z, j, H, Y, bt, ot, Tt, kt, ct) {
            this.leftStat.innerText = `Left Thruster: ${Math.round($)}%`, this.rightStat.innerText = `Right Thruster: ${Math.round(N)}%`;
            const ht = Math.sqrt(V.x * V.x + V.y * V.y), ut = Math.round(Math.atan2(V.y, V.x) * 180 / Math.PI);
            this.velStat.innerText = `Velocity: ${Math.round(ht)} | Angle: ${ut}°`, this.rotStat.innerText = `Rotation Power: ${z.toFixed(2)}`, this.foodStat.innerText = `Food: ${j}`, this.poisonStat.innerText = `Poison: ${H}`, this.collectedStat.innerText = `Collected: ${Y} food, ${bt} poison`, this.trainingStat.innerText = `Mode: ${ot ? "AUTO" : "MANUAL"} | Gen: ${Tt} | Score: ${ct} | Best: ${kt}`, ot ? this.trainingStat.style.color = "#00ff00" : this.trainingStat.style.color = "#ffffff";
        }
    }
    class xo {
        x;
        y;
        radius;
        color;
        constructor($, N, V = 24){
            this.x = $, this.y = N, this.radius = V, this.color = "#00ff88";
        }
        isColliding($, N, V) {
            const z = this.x - $, j = this.y - N;
            return Math.sqrt(z * z + j * j) < this.radius + V;
        }
        draw($) {
            $.beginPath(), $.arc(this.x, this.y, this.radius, 0, Math.PI * 2), $.fillStyle = this.color, $.fill(), $.strokeStyle = "#00ff88", $.lineWidth = 2, $.stroke();
        }
    }
    class bo {
        x;
        y;
        radius;
        color;
        constructor($, N, V = 16){
            this.x = $, this.y = N, this.radius = V, this.color = "#ff4444";
        }
        isColliding($, N, V) {
            const z = this.x - $, j = this.y - N;
            return Math.sqrt(z * z + j * j) < this.radius + V;
        }
        draw($) {
            $.beginPath(), $.arc(this.x, this.y, this.radius, 0, Math.PI * 2), $.fillStyle = this.color, $.fill(), $.strokeStyle = "#ff0000", $.lineWidth = 2, $.stroke();
        }
    }
    class wo {
        foodCollected = 0;
        poisonCollected = 0;
        collisionRadius;
        worldSize;
        rng;
        constructor($, N, V){
            this.worldSize = $, this.collisionRadius = N, this.rng = V;
        }
        checkCollisions($, N, V, z) {
            let j = 0, H = 0;
            for(let Y = V.length - 1; Y >= 0; Y--)V[Y].isColliding($, N, this.collisionRadius) && (V.splice(Y, 1), V.push(this.spawnFood()), this.foodCollected++, j++);
            for(let Y = z.length - 1; Y >= 0; Y--)z[Y].isColliding($, N, this.collisionRadius) && (z.splice(Y, 1), z.push(this.spawnPoison()), this.poisonCollected++, H++);
            return {
                foodCollected: j,
                poisonCollected: H
            };
        }
        spawnFood() {
            const $ = this.worldSize / 2, N = this.rng.randomRange(-$ + 50, $ - 50), V = this.rng.randomRange(-$ + 50, $ - 50);
            return new xo(N, V);
        }
        spawnPoison() {
            const $ = this.worldSize / 2, N = this.rng.randomRange(-$ + 50, $ - 50), V = this.rng.randomRange(-$ + 50, $ - 50);
            return new bo(N, V);
        }
        getFoodCollected() {
            return this.foodCollected;
        }
        getPoisonCollected() {
            return this.poisonCollected;
        }
    }
    class To {
        world;
        boids = [];
        inputManager;
        camera;
        renderer;
        hud;
        collisionManager;
        foods = [];
        poisons = [];
        rng;
        WORLD_SIZE = 2e3;
        FOOD_COUNT = 40;
        POISON_COUNT = 15;
        BOID_COLLISION_RADIUS = 15;
        POPULATION_SIZE = 10;
        trainMode = !1;
        score = 0;
        maxFitness = 0;
        generation = 1;
        bestBrainJSON = null;
        timeAlive = 0;
        MAX_TIME_ALIVE = 3e3;
        constructor($){
            const N = Date.now();
            this.rng = new uo(N), console.log("World Seed:", N), this.world = new co($, this.WORLD_SIZE), this.inputManager = new fo, this.camera = new go, this.renderer = new mo(this.WORLD_SIZE), this.hud = new yo(N, this.FOOD_COUNT, this.POISON_COUNT), this.collisionManager = new wo(this.WORLD_SIZE, this.BOID_COLLISION_RADIUS, this.rng), this.loadBestBrain();
            for(let V = 0; V < this.POPULATION_SIZE; V++){
                const z = new po($, this.world.getPhysicsWorld());
                this.bestBrainJSON && (z.brain.getNetwork().fromJSON(this.bestBrainJSON), V > 0 && z.brain.mutate(.1, .1)), this.boids.push(z);
            }
            this.initializeItems(), window.addEventListener("keydown", (V)=>{
                V.key.toLowerCase() === "t" && this.toggleTrainMode();
            });
        }
        loadBestBrain() {
            const $ = localStorage.getItem("bestBrain");
            if ($) try {
                this.bestBrainJSON = JSON.parse($), console.log("Loaded best brain from storage");
            } catch (z) {
                console.error("Failed to parse best brain", z);
            }
            const N = localStorage.getItem("generation");
            N && (this.generation = parseInt(N));
            const V = localStorage.getItem("maxFitness");
            V && (this.maxFitness = parseFloat(V));
        }
        saveBestBrain($) {
            $.brain && (this.bestBrainJSON = $.brain.getNetwork().toJSON(), localStorage.setItem("bestBrain", JSON.stringify(this.bestBrainJSON)), localStorage.setItem("generation", this.generation.toString()), localStorage.setItem("maxFitness", this.maxFitness.toString()));
        }
        toggleTrainMode() {
            this.trainMode = !this.trainMode, console.log("Train Mode:", this.trainMode);
        }
        initializeItems() {
            for(let $ = 0; $ < this.FOOD_COUNT; $++)this.foods.push(this.collisionManager.spawnFood());
            for(let $ = 0; $ < this.POISON_COUNT; $++)this.poisons.push(this.collisionManager.spawnPoison());
        }
        update() {
            let $ = !0, N = null, V = -1 / 0;
            for (const z of this.boids){
                if (!z.alive) continue;
                $ = !1, z.updateSensors(this.foods, this.poisons, this.WORLD_SIZE), z.think(), this.boids.indexOf(z) === 0 ? z.updateThrusters(this.inputManager.isKeyPressed("q"), this.inputManager.isKeyPressed("a"), this.inputManager.isKeyPressed("w"), this.inputManager.isKeyPressed("s")) : z.updateThrusters(!1, !1, !1, !1), this.world.wrapPosition(z.getBody());
                const j = z.getPosition(), H = this.collisionManager.checkCollisions(j.x, j.y, this.foods, this.poisons);
                this.trainMode && (z.score += H.foodCollected * 10, z.score -= H.poisonCollected * 20, H.poisonCollected > 0 && z.die()), z.score > V && (V = z.score, N = z);
            }
            this.boids.forEach((z)=>z.isBest = z === N), N && (this.score = N.score), this.world.step(), this.trainMode && (this.timeAlive++, ($ || this.timeAlive > this.MAX_TIME_ALIVE) && this.resetGeneration());
        }
        resetGeneration() {
            let $ = this.boids[0], N = -1 / 0;
            for (const z of this.boids)z.score > N && (N = z.score, $ = z);
            console.log(`Generation ${this.generation} ended. Top Score: ${N}`), N > this.maxFitness && (this.maxFitness = N, this.saveBestBrain($), console.log("New record!"));
            const V = $.brain.getNetwork().toJSON();
            for(let z = 0; z < this.boids.length; z++){
                const j = this.boids[z], H = new ri(18, 10, 2);
                H.getNetwork().fromJSON(V), z > 0 && H.mutate(.1, .2), j.reset(H);
            }
            this.foods = [], this.poisons = [], this.initializeItems(), this.score = 0, this.timeAlive = 0, this.generation++;
        }
        draw() {
            this.renderer.clear();
            const $ = this.boids.find((V)=>V.isBest) || this.boids[0], N = $.getPosition();
            this.camera.follow(N.x, N.y), this.renderer.drawWorld(this.camera, this.foods, this.poisons);
            for (const V of this.boids)V.alive && this.renderer.drawBoidAtCenter((z)=>{
                const j = V.getPosition(), H = {
                    x: this.camera.x,
                    y: this.camera.y
                };
                z.save(), z.translate(j.x - H.x, j.y - H.y), V.draw(z), z.restore();
            });
            this.renderer.drawMinimap(N.x, N.y, this.foods, this.poisons), $.brain && this.renderer.drawBrain($.brain), this.hud.updateStats($.getLeftThrusterPercent(), $.getRightThrusterPercent(), $.getVelocity(), $.getAngularVelocity(), this.foods.length, this.poisons.length, this.collisionManager.getFoodCollected(), this.collisionManager.getPoisonCollected(), this.trainMode, this.generation, this.maxFitness, this.score);
        }
        loop = ()=>{
            this.update(), this.draw(), requestAnimationFrame(this.loop);
        };
        start() {
            console.log("Starting game loop..."), this.loop();
        }
    }
    async function So() {
        console.log("Starting boid simulation...");
        const At = await oo(()=>import("./rapier-D9GItMpu.js"), [], import.meta.url);
        At.init && await At.init(), console.log("RAPIER module ready"), new To(At).start();
    }
    So().catch(console.error);
})();
